diff --git a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLLexer.cpp b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLLexer.cpp
index 777ce3a..427de74 100644
--- a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLLexer.cpp
+++ b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLLexer.cpp
@@ -531,6 +531,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(undef);
   KEYWORD(null);
   KEYWORD(none);
+  KEYWORD(poison);
   KEYWORD(to);
   KEYWORD(caller);
   KEYWORD(within);
@@ -624,6 +625,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(amdgpu_ps);
   KEYWORD(amdgpu_cs);
   KEYWORD(amdgpu_kernel);
+  KEYWORD(amdgpu_gfx);
   KEYWORD(tailcc);
 
   KEYWORD(cc);
@@ -651,6 +653,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(nest);
   KEYWORD(noalias);
   KEYWORD(nobuiltin);
+  KEYWORD(nocallback);
   KEYWORD(nocapture);
   KEYWORD(noduplicate);
   KEYWORD(nofree);
@@ -660,6 +663,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(nonlazybind);
   KEYWORD(nomerge);
   KEYWORD(nonnull);
+  KEYWORD(noprofile);
   KEYWORD(noredzone);
   KEYWORD(noreturn);
   KEYWORD(nosync);
@@ -697,6 +701,8 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(writeonly);
   KEYWORD(zeroext);
   KEYWORD(immarg);
+  KEYWORD(byref);
+  KEYWORD(mustprogress);
 
   KEYWORD(type);
   KEYWORD(opaque);
@@ -721,6 +727,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(vscale);
   KEYWORD(x);
   KEYWORD(blockaddress);
+  KEYWORD(dso_local_equivalent);
 
   // Metadata types.
   KEYWORD(distinct);
@@ -834,6 +841,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   TYPEKEYWORD("label",     Type::getLabelTy(Context));
   TYPEKEYWORD("metadata",  Type::getMetadataTy(Context));
   TYPEKEYWORD("x86_mmx",   Type::getX86_MMXTy(Context));
+  TYPEKEYWORD("x86_amx",   Type::getX86_AMXTy(Context));
   TYPEKEYWORD("token",     Type::getTokenTy(Context));
 
 #undef TYPEKEYWORD
diff --git a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLParser.cpp b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLParser.cpp
index c9f21ee..2a3fb8f 100644
--- a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLParser.cpp
+++ b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLParser.cpp
@@ -65,20 +65,20 @@ bool LLParser::Run(bool UpgradeDebugInfo,
   Lex.Lex();
 
   if (Context.shouldDiscardValueNames())
-    return Error(
+    return error(
         Lex.getLoc(),
         "Can't read textual IR with a Context that discards named Values");
 
   if (M) {
-    if (ParseTargetDefinitions())
+    if (parseTargetDefinitions())
       return true;
 
     if (auto LayoutOverride = DataLayoutCallback(M->getTargetTriple()))
       M->setDataLayout(*LayoutOverride);
   }
 
-  return ParseTopLevelEntities() || ValidateEndOfModule(UpgradeDebugInfo) ||
-         ValidateEndOfIndex();
+  return parseTopLevelEntities() || validateEndOfModule(UpgradeDebugInfo) ||
+         validateEndOfIndex();
 }
 
 bool LLParser::parseStandaloneConstantValue(Constant *&C,
@@ -786,18 +826,25 @@ bool LLParser::ParseStandaloneMetadata() {
 }
 
 // Skips a single module summary entry.
-bool LLParser::SkipModuleSummaryEntry() {
+bool LLParser::skipModuleSummaryEntry() {
   // Each module summary entry consists of a tag for the entry
-  // type, followed by a colon, then the fields surrounded by nested sets of
-  // parentheses. The "tag:" looks like a Label. Once parsing support is
-  // in place we will look for the tokens corresponding to the expected tags.
+  // type, followed by a colon, then the fields which may be surrounded by
+  // nested sets of parentheses. The "tag:" looks like a Label. Once parsing
+  // support is in place we will look for the tokens corresponding to the
+  // expected tags.
   if (Lex.getKind() != lltok::kw_gv && Lex.getKind() != lltok::kw_module &&
-      Lex.getKind() != lltok::kw_typeid)
-    return TokError(
-        "Expected 'gv', 'module', or 'typeid' at the start of summary entry");
+      Lex.getKind() != lltok::kw_typeid && Lex.getKind() != lltok::kw_flags &&
+      Lex.getKind() != lltok::kw_blockcount)
+    return tokError(
+        "Expected 'gv', 'module', 'typeid', 'flags' or 'blockcount' at the "
+        "start of summary entry");
+  if (Lex.getKind() == lltok::kw_flags)
+    return parseSummaryIndexFlags();
+  if (Lex.getKind() == lltok::kw_blockcount)
+    return parseBlockCount();
   Lex.Lex();
-  if (ParseToken(lltok::colon, "expected ':' at start of summary entry") ||
-      ParseToken(lltok::lparen, "expected '(' at start of summary entry"))
+  if (parseToken(lltok::colon, "expected ':' at start of summary entry") ||
+      parseToken(lltok::lparen, "expected '(' at start of summary entry"))
     return true;
   // Now walk through the parenthesized entry, until the number of open
   // parentheses goes back down to 0 (the first '(' was parsed above).
@@ -928,33 +975,31 @@ bool LLParser::parseIndirectSymbol(const std::string &Name, LocTy NameLoc,
       Lex.getKind() != lltok::kw_getelementptr &&
       Lex.getKind() != lltok::kw_addrspacecast &&
       Lex.getKind() != lltok::kw_inttoptr) {
-    if (ParseGlobalTypeAndValue(Aliasee))
+    if (parseGlobalTypeAndValue(Aliasee))
       return true;
   } else {
     // The bitcast dest type is not present, it is implied by the dest type.
     ValID ID;
-    if (ParseValID(ID))
+    if (parseValID(ID))
       return true;
     if (ID.Kind != ValID::t_Constant)
-      return Error(AliaseeLoc, "invalid aliasee");
+      return error(AliaseeLoc, "invalid aliasee");
     Aliasee = ID.ConstantVal;
   }
 
   Type *AliaseeType = Aliasee->getType();
   auto *PTy = dyn_cast<PointerType>(AliaseeType);
   if (!PTy)
-    return Error(AliaseeLoc, "An alias or ifunc must have pointer type");
+    return error(AliaseeLoc, "An alias or ifunc must have pointer type");
   unsigned AddrSpace = PTy->getAddressSpace();
 
   if (IsAlias && Ty != PTy->getElementType())
-    return Error(
-        ExplicitTypeLoc,
-        "explicit pointee type doesn't match operand's pointee type");
+    return error(ExplicitTypeLoc,
+                 "explicit pointee type doesn't match operand's pointee type");
 
   if (!IsAlias && !PTy->getElementType()->isFunctionTy())
-    return Error(
-        ExplicitTypeLoc,
-        "explicit pointee type should be a function type");
+    return error(ExplicitTypeLoc,
+                 "explicit pointee type should be a function type");
 
   GlobalValue *GVal = nullptr;
 
@@ -1176,37 +1222,37 @@ bool LLParser::ParseGlobal(const std::string &Name, LocTy NameLoc,
-/// ParseFnAttributeValuePairs
+/// parseFnAttributeValuePairs
 ///   ::= <attr> | <attr> '=' <value>
-bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
+bool LLParser::parseFnAttributeValuePairs(AttrBuilder &B,
                                           std::vector<unsigned> &FwdRefAttrGrps,
                                           bool inAttrGrp, LocTy &BuiltinLoc) {
   bool HaveError = false;
@@ -1294,6 +1340,7 @@ bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
     case lltok::kw_argmemonly: B.addAttribute(Attribute::ArgMemOnly); break;
     case lltok::kw_builtin: B.addAttribute(Attribute::Builtin); break;
     case lltok::kw_cold: B.addAttribute(Attribute::Cold); break;
+    case lltok::kw_hot: B.addAttribute(Attribute::Hot); break;
     case lltok::kw_convergent: B.addAttribute(Attribute::Convergent); break;
     case lltok::kw_inaccessiblememonly:
       B.addAttribute(Attribute::InaccessibleMemOnly); break;
@@ -1302,8 +1349,14 @@ bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
     case lltok::kw_inlinehint: B.addAttribute(Attribute::InlineHint); break;
     case lltok::kw_jumptable: B.addAttribute(Attribute::JumpTable); break;
     case lltok::kw_minsize: B.addAttribute(Attribute::MinSize); break;
+    case lltok::kw_mustprogress:
+      B.addAttribute(Attribute::MustProgress);
+      break;
     case lltok::kw_naked: B.addAttribute(Attribute::Naked); break;
     case lltok::kw_nobuiltin: B.addAttribute(Attribute::NoBuiltin); break;
+    case lltok::kw_nocallback:
+      B.addAttribute(Attribute::NoCallback);
+      break;
     case lltok::kw_noduplicate: B.addAttribute(Attribute::NoDuplicate); break;
     case lltok::kw_nofree: B.addAttribute(Attribute::NoFree); break;
     case lltok::kw_noimplicitfloat:
@@ -1315,6 +1368,7 @@ bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
     case lltok::kw_noreturn: B.addAttribute(Attribute::NoReturn); break;
     case lltok::kw_nosync: B.addAttribute(Attribute::NoSync); break;
     case lltok::kw_nocf_check: B.addAttribute(Attribute::NoCfCheck); break;
+    case lltok::kw_noprofile: B.addAttribute(Attribute::NoProfile); break;
     case lltok::kw_norecurse: B.addAttribute(Attribute::NoRecurse); break;
     case lltok::kw_nounwind: B.addAttribute(Attribute::NoUnwind); break;
     case lltok::kw_null_pointer_is_valid:
@@ -1382,13 +1435,14 @@ bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
     case lltok::kw_swifterror:
     case lltok::kw_swiftself:
     case lltok::kw_immarg:
+    case lltok::kw_byref:
       break;
     }
   }
@@ -1516,56 +1570,56 @@ Comdat *LLParser::getComdat(const std::string &Name, LocTy Loc) {
 // Helper Routines.
 //===----------------------------------------------------------------------===//
 
-/// ParseToken - If the current token has the specified kind, eat it and return
+/// parseToken - If the current token has the specified kind, eat it and return
 /// success.  Otherwise, emit the specified error and return failure.
-bool LLParser::ParseToken(lltok::Kind T, const char *ErrMsg) {
+bool LLParser::parseToken(lltok::Kind T, const char *ErrMsg) {
   if (Lex.getKind() != T)
-    return TokError(ErrMsg);
+    return tokError(ErrMsg);
   Lex.Lex();
   return false;
 }
 
-/// ParseStringConstant
+/// parseStringConstant
 ///   ::= StringConstant
-bool LLParser::ParseStringConstant(std::string &Result) {
+bool LLParser::parseStringConstant(std::string &Result) {
   if (Lex.getKind() != lltok::StringConstant)
-    return TokError("expected string constant");
+    return tokError("expected string constant");
   Result = Lex.getStrVal();
   Lex.Lex();
   return false;
 }
 
-/// ParseUInt32
+/// parseUInt32
 ///   ::= uint32
-bool LLParser::ParseUInt32(uint32_t &Val) {
+bool LLParser::parseUInt32(uint32_t &Val) {
   if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned())
-    return TokError("expected integer");
+    return tokError("expected integer");
   uint64_t Val64 = Lex.getAPSIntVal().getLimitedValue(0xFFFFFFFFULL+1);
   if (Val64 != unsigned(Val64))
-    return TokError("expected 32-bit integer (too large)");
+    return tokError("expected 32-bit integer (too large)");
   Val = Val64;
   Lex.Lex();
   return false;
 }
 
-/// ParseUInt64
+/// parseUInt64
 ///   ::= uint64
-bool LLParser::ParseUInt64(uint64_t &Val) {
+bool LLParser::parseUInt64(uint64_t &Val) {
   if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned())
-    return TokError("expected integer");
+    return tokError("expected integer");
   Val = Lex.getAPSIntVal().getLimitedValue();
   Lex.Lex();
   return false;
 }
 
-/// ParseTLSModel
+/// parseTLSModel
 ///   := 'localdynamic'
 ///   := 'initialexec'
 ///   := 'localexec'
-bool LLParser::ParseTLSModel(GlobalVariable::ThreadLocalMode &TLM) {
+bool LLParser::parseTLSModel(GlobalVariable::ThreadLocalMode &TLM) {
   switch (Lex.getKind()) {
     default:
-      return TokError("expected localdynamic, initialexec or localexec");
+      return tokError("expected localdynamic, initialexec or localexec");
     case lltok::kw_localdynamic:
       TLM = GlobalVariable::LocalDynamicTLSModel;
       break;

@@ -1593,39 +1647,40 @@ bool LLParser::ParseOptionalThreadLocal(GlobalVariable::ThreadLocalMode &TLM) {
-/// ParseOptionalAddrSpace
+/// parseOptionalAddrSpace
 ///   := /*empty*/
 ///   := 'addrspace' '(' uint32 ')'
-bool LLParser::ParseOptionalAddrSpace(unsigned &AddrSpace, unsigned DefaultAS) {
+bool LLParser::parseOptionalAddrSpace(unsigned &AddrSpace, unsigned DefaultAS) {
   AddrSpace = DefaultAS;
   if (!EatIfPresent(lltok::kw_addrspace))
     return false;
-  return ParseToken(lltok::lparen, "expected '(' in address space") ||
-         ParseUInt32(AddrSpace) ||
-         ParseToken(lltok::rparen, "expected ')' in address space");
+  return parseToken(lltok::lparen, "expected '(' in address space") ||
+         parseUInt32(AddrSpace) ||
+         parseToken(lltok::rparen, "expected ')' in address space");
 }
 
-/// ParseStringAttribute
+/// parseStringAttribute
 ///   := StringConstant
 ///   := StringConstant '=' StringConstant
-bool LLParser::ParseStringAttribute(AttrBuilder &B) {
+bool LLParser::parseStringAttribute(AttrBuilder &B) {
   std::string Attr = Lex.getStrVal();
   Lex.Lex();
   std::string Val;
-  if (EatIfPresent(lltok::equal) && ParseStringConstant(Val))
+  if (EatIfPresent(lltok::equal) && parseStringConstant(Val))
     return true;
   B.addAttribute(Attr, Val);
   return false;
 }
 
-/// ParseOptionalParamAttrs - Parse a potentially empty list of parameter attributes.
-bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
+/// parseOptionalParamAttrs - parse a potentially empty list of parameter
+/// attributes.
+bool LLParser::parseOptionalParamAttrs(AttrBuilder &B) {
   bool HaveError = false;
 
   B.clear();
@@ -1636,45 +1691,59 @@ bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
     default:  // End of attributes.
       return HaveError;
     case lltok::StringConstant: {
-      if (ParseStringAttribute(B))
+      if (parseStringAttribute(B))
         return true;
       continue;
     }
     case lltok::kw_align: {
       MaybeAlign Alignment;
-      if (ParseOptionalAlignment(Alignment, true))
+      if (parseOptionalAlignment(Alignment, true))
         return true;
       B.addAlignmentAttr(Alignment);
       continue;
     }
     case lltok::kw_byval: {
       Type *Ty;
-      if (ParseByValWithOptionalType(Ty))
+      if (parseRequiredTypeAttr(Ty, lltok::kw_byval))
         return true;
       B.addByValAttr(Ty);
       continue;
     }
+    case lltok::kw_sret: {
+      Type *Ty;
+      if (parseRequiredTypeAttr(Ty, lltok::kw_sret))
+        return true;
+      B.addStructRetAttr(Ty);
+      continue;
+    }
     case lltok::kw_preallocated: {
       Type *Ty;
-      if (ParsePreallocated(Ty))
+      if (parsePreallocated(Ty))
         return true;
       B.addPreallocatedAttr(Ty);
       continue;
     }
     case lltok::kw_dereferenceable: {
       uint64_t Bytes;
-      if (ParseOptionalDerefAttrBytes(lltok::kw_dereferenceable, Bytes))
+      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable, Bytes))
         return true;
       B.addDereferenceableAttr(Bytes);
       continue;
     }
     case lltok::kw_dereferenceable_or_null: {
       uint64_t Bytes;
-      if (ParseOptionalDerefAttrBytes(lltok::kw_dereferenceable_or_null, Bytes))
+      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable_or_null, Bytes))
         return true;
       B.addDereferenceableOrNullAttr(Bytes);
       continue;
     }
+    case lltok::kw_byref: {
+      Type *Ty;
+      if (parseByRef(Ty))
+        return true;
+      B.addByRefAttr(Ty);
+      continue;
+    }
     case lltok::kw_inalloca:        B.addAttribute(Attribute::InAlloca); break;
     case lltok::kw_inreg:           B.addAttribute(Attribute::InReg); break;
     case lltok::kw_nest:            B.addAttribute(Attribute::Nest); break;
@@ -1689,7 +1758,6 @@ bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
     case lltok::kw_readonly:        B.addAttribute(Attribute::ReadOnly); break;
     case lltok::kw_returned:        B.addAttribute(Attribute::Returned); break;
     case lltok::kw_signext:         B.addAttribute(Attribute::SExt); break;
-    case lltok::kw_sret:            B.addAttribute(Attribute::StructRet); break;
     case lltok::kw_swifterror:      B.addAttribute(Attribute::SwiftError); break;
     case lltok::kw_swiftself:       B.addAttribute(Attribute::SwiftSelf); break;
     case lltok::kw_writeonly:       B.addAttribute(Attribute::WriteOnly); break;
@@ -1703,6 +1771,7 @@ bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
     case lltok::kw_inlinehint:
     case lltok::kw_jumptable:
     case lltok::kw_minsize:
+    case lltok::kw_mustprogress:
     case lltok::kw_naked:
     case lltok::kw_nobuiltin:
     case lltok::kw_noduplicate:
@@ -1710,6 +1779,7 @@ bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
     case lltok::kw_noinline:
     case lltok::kw_nonlazybind:
     case lltok::kw_nomerge:
+    case lltok::kw_noprofile:
     case lltok::kw_noredzone:
     case lltok::kw_noreturn:
     case lltok::kw_nocf_check:
@@ -1731,7 +1801,8 @@ bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
     case lltok::kw_shadowcallstack:
     case lltok::kw_strictfp:
     case lltok::kw_uwtable:
-      HaveError |= Error(Lex.getLoc(), "invalid use of function-only attribute");
+      HaveError |=
+          error(Lex.getLoc(), "invalid use of function-only attribute");
       break;
     }
 
@@ -1751,27 +1823,27 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     default:  // End of attributes.
       return HaveError;
     case lltok::StringConstant: {
-      if (ParseStringAttribute(B))
+      if (parseStringAttribute(B))
         return true;
       continue;
     }
     case lltok::kw_dereferenceable: {
       uint64_t Bytes;
-      if (ParseOptionalDerefAttrBytes(lltok::kw_dereferenceable, Bytes))
+      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable, Bytes))
         return true;
       B.addDereferenceableAttr(Bytes);
       continue;
     }
     case lltok::kw_dereferenceable_or_null: {
       uint64_t Bytes;
-      if (ParseOptionalDerefAttrBytes(lltok::kw_dereferenceable_or_null, Bytes))
+      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable_or_null, Bytes))
         return true;
       B.addDereferenceableOrNullAttr(Bytes);
       continue;
     }
     case lltok::kw_align: {
       MaybeAlign Alignment;
-      if (ParseOptionalAlignment(Alignment))
+      if (parseOptionalAlignment(Alignment))
         return true;
       B.addAlignmentAttr(Alignment);
       continue;
@@ -1785,7 +1857,7 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     case lltok::kw_signext:         B.addAttribute(Attribute::SExt); break;
     case lltok::kw_zeroext:         B.addAttribute(Attribute::ZExt); break;
 
-    // Error handling.
+    // error handling.
     case lltok::kw_byval:
     case lltok::kw_inalloca:
     case lltok::kw_nest:
@@ -1795,7 +1867,9 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     case lltok::kw_swifterror:
     case lltok::kw_swiftself:
     case lltok::kw_immarg:
-      HaveError |= Error(Lex.getLoc(), "invalid use of parameter-only attribute");
+    case lltok::kw_byref:
+      HaveError |=
+          error(Lex.getLoc(), "invalid use of parameter-only attribute");
       break;
 
     case lltok::kw_alignstack:
@@ -1806,6 +1880,7 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     case lltok::kw_inlinehint:
     case lltok::kw_jumptable:
     case lltok::kw_minsize:
+    case lltok::kw_mustprogress:
     case lltok::kw_naked:
     case lltok::kw_nobuiltin:
     case lltok::kw_noduplicate:
@@ -1813,6 +1888,7 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     case lltok::kw_noinline:
     case lltok::kw_nonlazybind:
     case lltok::kw_nomerge:
+    case lltok::kw_noprofile:
     case lltok::kw_noredzone:
     case lltok::kw_noreturn:
     case lltok::kw_nocf_check:
@@ -2059,6 +2136,7 @@ bool LLParser::ParseOptionalCallingConv(unsigned &CC) {
   case lltok::kw_hhvm_ccc:       CC = CallingConv::HHVM_C; break;
   case lltok::kw_cxx_fast_tlscc: CC = CallingConv::CXX_FAST_TLS; break;
   case lltok::kw_amdgpu_vs:      CC = CallingConv::AMDGPU_VS; break;
+  case lltok::kw_amdgpu_gfx:     CC = CallingConv::AMDGPU_Gfx; break;
   case lltok::kw_amdgpu_ls:      CC = CallingConv::AMDGPU_LS; break;
   case lltok::kw_amdgpu_hs:      CC = CallingConv::AMDGPU_HS; break;
   case lltok::kw_amdgpu_es:      CC = CallingConv::AMDGPU_ES; break;
@@ -2077,28 +2155,28 @@ bool LLParser::ParseOptionalCallingConv(unsigned &CC) {
   return false;
 }
 
-/// ParseMetadataAttachment
+/// parseMetadataAttachment
 ///   ::= !dbg !42
-bool LLParser::ParseMetadataAttachment(unsigned &Kind, MDNode *&MD) {
+bool LLParser::parseMetadataAttachment(unsigned &Kind, MDNode *&MD) {
   assert(Lex.getKind() == lltok::MetadataVar && "Expected metadata attachment");
 
   std::string Name = Lex.getStrVal();
   Kind = M->getMDKindID(Name);
   Lex.Lex();
 
-  return ParseMDNode(MD);
+  return parseMDNode(MD);
 }
 
-/// ParseInstructionMetadata
+/// parseInstructionMetadata
 ///   ::= !dbg !42 (',' !dbg !57)*
-bool LLParser::ParseInstructionMetadata(Instruction &Inst) {
+bool LLParser::parseInstructionMetadata(Instruction &Inst) {
   do {
     if (Lex.getKind() != lltok::MetadataVar)
-      return TokError("expected metadata after comma");
+      return tokError("expected metadata after comma");
 
     unsigned MDK;
     MDNode *N;
-    if (ParseMetadataAttachment(MDK, N))
+    if (parseMetadataAttachment(MDK, N))
       return true;
 
     Inst.setMetadata(MDK, N);
@@ -2110,31 +2188,31 @@ bool LLParser::ParseInstructionMetadata(Instruction &Inst) {
   return false;
 }
 
-/// ParseGlobalObjectMetadataAttachment
+/// parseGlobalObjectMetadataAttachment
 ///   ::= !dbg !57
-bool LLParser::ParseGlobalObjectMetadataAttachment(GlobalObject &GO) {
+bool LLParser::parseGlobalObjectMetadataAttachment(GlobalObject &GO) {
   unsigned MDK;
   MDNode *N;
-  if (ParseMetadataAttachment(MDK, N))
+  if (parseMetadataAttachment(MDK, N))
     return true;
 
   GO.addMetadata(MDK, *N);
   return false;
 }
 
-/// ParseOptionalFunctionMetadata
+/// parseOptionalFunctionMetadata
 ///   ::= (!dbg !57)*
-bool LLParser::ParseOptionalFunctionMetadata(Function &F) {
+bool LLParser::parseOptionalFunctionMetadata(Function &F) {
   while (Lex.getKind() == lltok::MetadataVar)
-    if (ParseGlobalObjectMetadataAttachment(F))
+    if (parseGlobalObjectMetadataAttachment(F))
       return true;
   return false;
 }
 
-/// ParseOptionalAlignment
+/// parseOptionalAlignment
 ///   ::= /* empty */
 ///   ::= 'align' 4
-bool LLParser::ParseOptionalAlignment(MaybeAlign &Alignment, bool AllowParens) {
+bool LLParser::parseOptionalAlignment(MaybeAlign &Alignment, bool AllowParens) {
   Alignment = None;
   if (!EatIfPresent(lltok::kw_align))
     return false;
@@ -2148,26 +2226,26 @@ bool LLParser::ParseOptionalAlignment(MaybeAlign &Alignment, bool AllowParens) {
       HaveParens = true;
   }
 
-  if (ParseUInt32(Value))
+  if (parseUInt32(Value))
     return true;
 
   if (HaveParens && !EatIfPresent(lltok::rparen))
-    return Error(ParenLoc, "expected ')'");
+    return error(ParenLoc, "expected ')'");
 
   if (!isPowerOf2_32(Value))
-    return Error(AlignLoc, "alignment is not a power of two");
+    return error(AlignLoc, "alignment is not a power of two");
   if (Value > Value::MaximumAlignment)
-    return Error(AlignLoc, "huge alignments are not supported yet");
+    return error(AlignLoc, "huge alignments are not supported yet");
   Alignment = Align(Value);
   return false;
 }
 
-/// ParseOptionalDerefAttrBytes
+/// parseOptionalDerefAttrBytes
 ///   ::= /* empty */
 ///   ::= AttrKind '(' 4 ')'
 ///
 /// where AttrKind is either 'dereferenceable' or 'dereferenceable_or_null'.
-bool LLParser::ParseOptionalDerefAttrBytes(lltok::Kind AttrKind,
+bool LLParser::parseOptionalDerefAttrBytes(lltok::Kind AttrKind,
                                            uint64_t &Bytes) {
   assert((AttrKind == lltok::kw_dereferenceable ||
           AttrKind == lltok::kw_dereferenceable_or_null) &&
@@ -2178,24 +2256,25 @@ bool LLParser::ParseOptionalDerefAttrBytes(lltok::Kind AttrKind,
     return false;
   LocTy ParenLoc = Lex.getLoc();
   if (!EatIfPresent(lltok::lparen))
-    return Error(ParenLoc, "expected '('");
+    return error(ParenLoc, "expected '('");
   LocTy DerefLoc = Lex.getLoc();
-  if (ParseUInt64(Bytes)) return true;
+  if (parseUInt64(Bytes))
+    return true;
   ParenLoc = Lex.getLoc();
   if (!EatIfPresent(lltok::rparen))
-    return Error(ParenLoc, "expected ')'");
+    return error(ParenLoc, "expected ')'");
   if (!Bytes)
-    return Error(DerefLoc, "dereferenceable bytes must be non-zero");
+    return error(DerefLoc, "dereferenceable bytes must be non-zero");
   return false;
 }
 
-/// ParseOptionalCommaAlign
+/// parseOptionalCommaAlign
 ///   ::=
 ///   ::= ',' align 4
 ///
 /// This returns with AteExtraComma set to true if it ate an excess comma at the
 /// end.
-bool LLParser::ParseOptionalCommaAlign(MaybeAlign &Alignment,
+bool LLParser::parseOptionalCommaAlign(MaybeAlign &Alignment,
                                        bool &AteExtraComma) {
   AteExtraComma = false;
   while (EatIfPresent(lltok::comma)) {
@@ -2206,22 +2285,22 @@ bool LLParser::ParseOptionalCommaAlign(MaybeAlign &Alignment,
     }
 
     if (Lex.getKind() != lltok::kw_align)
-      return Error(Lex.getLoc(), "expected metadata or 'align'");
+      return error(Lex.getLoc(), "expected metadata or 'align'");
 
-    if (ParseOptionalAlignment(Alignment)) return true;
+    if (parseOptionalAlignment(Alignment))
+      return true;
   }
 
   return false;
 }
 
-/// ParseOptionalCommaAddrSpace
+/// parseOptionalCommaAddrSpace
 ///   ::=
 ///   ::= ',' addrspace(1)
 ///
 /// This returns with AteExtraComma set to true if it ate an excess comma at the
 /// end.
-bool LLParser::ParseOptionalCommaAddrSpace(unsigned &AddrSpace,
-                                           LocTy &Loc,
+bool LLParser::parseOptionalCommaAddrSpace(unsigned &AddrSpace, LocTy &Loc,
                                            bool &AteExtraComma) {
   AteExtraComma = false;
   while (EatIfPresent(lltok::comma)) {
@@ -2233,9 +2312,9 @@ bool LLParser::ParseOptionalCommaAddrSpace(unsigned &AddrSpace,
 
     Loc = Lex.getLoc();
     if (Lex.getKind() != lltok::kw_addrspace)
-      return Error(Lex.getLoc(), "expected metadata or 'addrspace'");
+      return error(Lex.getLoc(), "expected metadata or 'addrspace'");
 
-    if (ParseOptionalAddrSpace(AddrSpace))
+    if (parseOptionalAddrSpace(AddrSpace))
       return true;
   }
 
@@ -2248,18 +2327,18 @@ bool LLParser::parseAllocSizeArguments(unsigned &BaseSizeArg,
 
   auto StartParen = Lex.getLoc();
   if (!EatIfPresent(lltok::lparen))
-    return Error(StartParen, "expected '('");
+    return error(StartParen, "expected '('");
 
-  if (ParseUInt32(BaseSizeArg))
+  if (parseUInt32(BaseSizeArg))
     return true;
 
   if (EatIfPresent(lltok::comma)) {
     auto HowManyAt = Lex.getLoc();
     unsigned HowMany;
-    if (ParseUInt32(HowMany))
+    if (parseUInt32(HowMany))
       return true;
     if (HowMany == BaseSizeArg)
-      return Error(HowManyAt,
+      return error(HowManyAt,
                    "'allocsize' indices can't refer to the same parameter");
     HowManyArg = HowMany;
   } else
@@ -2267,42 +2346,42 @@ bool LLParser::parseAllocSizeArguments(unsigned &BaseSizeArg,
 
   auto EndParen = Lex.getLoc();
   if (!EatIfPresent(lltok::rparen))
-    return Error(EndParen, "expected ')'");
+    return error(EndParen, "expected ')'");
   return false;
 }
 
-/// ParseScopeAndOrdering
+/// parseScopeAndOrdering
 ///   if isAtomic: ::= SyncScope? AtomicOrdering
 ///   else: ::=
 ///
 /// This sets Scope and Ordering to the parsed values.
-bool LLParser::ParseScopeAndOrdering(bool isAtomic, SyncScope::ID &SSID,
+bool LLParser::parseScopeAndOrdering(bool IsAtomic, SyncScope::ID &SSID,
                                      AtomicOrdering &Ordering) {
-  if (!isAtomic)
+  if (!IsAtomic)
     return false;
 
-  return ParseScope(SSID) || ParseOrdering(Ordering);
+  return parseScope(SSID) || parseOrdering(Ordering);
 }
 
-/// ParseScope
+/// parseScope
 ///   ::= syncscope("singlethread" | "<target scope>")?
 ///
 /// This sets synchronization scope ID to the ID of the parsed value.
-bool LLParser::ParseScope(SyncScope::ID &SSID) {
+bool LLParser::parseScope(SyncScope::ID &SSID) {
   SSID = SyncScope::System;
   if (EatIfPresent(lltok::kw_syncscope)) {
     auto StartParenAt = Lex.getLoc();
     if (!EatIfPresent(lltok::lparen))
-      return Error(StartParenAt, "Expected '(' in syncscope");
+      return error(StartParenAt, "Expected '(' in syncscope");
 
     std::string SSN;
     auto SSNAt = Lex.getLoc();
-    if (ParseStringConstant(SSN))
-      return Error(SSNAt, "Expected synchronization scope name");
+    if (parseStringConstant(SSN))
+      return error(SSNAt, "Expected synchronization scope name");
 
     auto EndParenAt = Lex.getLoc();
     if (!EatIfPresent(lltok::rparen))
-      return Error(EndParenAt, "Expected ')' in syncscope");
+      return error(EndParenAt, "Expected ')' in syncscope");
 
     SSID = Context.getOrInsertSyncScopeID(SSN);
   }
@@ -2310,13 +2389,14 @@ bool LLParser::ParseScope(SyncScope::ID &SSID) {
   return false;
 }
 
-/// ParseOrdering
+/// parseOrdering
 ///   ::= AtomicOrdering
 ///
 /// This sets Ordering to the parsed value.
-bool LLParser::ParseOrdering(AtomicOrdering &Ordering) {
+bool LLParser::parseOrdering(AtomicOrdering &Ordering) {
   switch (Lex.getKind()) {
-  default: return TokError("Expected ordering on atomic instruction");
+  default:
+    return tokError("Expected ordering on atomic instruction");
   case lltok::kw_unordered: Ordering = AtomicOrdering::Unordered; break;
   case lltok::kw_monotonic: Ordering = AtomicOrdering::Monotonic; break;
   // Not specified yet:
@@ -2332,50 +2412,53 @@ bool LLParser::ParseOrdering(AtomicOrdering &Ordering) {
   return false;
 }
 
-/// ParseOptionalStackAlignment
+/// parseOptionalStackAlignment
 ///   ::= /* empty */
 ///   ::= 'alignstack' '(' 4 ')'
-bool LLParser::ParseOptionalStackAlignment(unsigned &Alignment) {
+bool LLParser::parseOptionalStackAlignment(unsigned &Alignment) {
   Alignment = 0;
   if (!EatIfPresent(lltok::kw_alignstack))
     return false;
   LocTy ParenLoc = Lex.getLoc();
   if (!EatIfPresent(lltok::lparen))
-    return Error(ParenLoc, "expected '('");
+    return error(ParenLoc, "expected '('");
   LocTy AlignLoc = Lex.getLoc();
-  if (ParseUInt32(Alignment)) return true;
+  if (parseUInt32(Alignment))
+    return true;
   ParenLoc = Lex.getLoc();
   if (!EatIfPresent(lltok::rparen))
-    return Error(ParenLoc, "expected ')'");
+    return error(ParenLoc, "expected ')'");
   if (!isPowerOf2_32(Alignment))
-    return Error(AlignLoc, "stack alignment is not a power of two");
+    return error(AlignLoc, "stack alignment is not a power of two");
   return false;
 }
 
-/// ParseIndexList - This parses the index list for an insert/extractvalue
+/// parseIndexList - This parses the index list for an insert/extractvalue
 /// instruction.  This sets AteExtraComma in the case where we eat an extra
 /// comma at the end of the line and find that it is followed by metadata.
 /// Clients that don't allow metadata can call the version of this function that
 /// only takes one argument.
 ///
-/// ParseIndexList
+/// parseIndexList
 ///    ::=  (',' uint32)+
 ///
-bool LLParser::ParseIndexList(SmallVectorImpl<unsigned> &Indices,
+bool LLParser::parseIndexList(SmallVectorImpl<unsigned> &Indices,
                               bool &AteExtraComma) {
   AteExtraComma = false;
 
   if (Lex.getKind() != lltok::comma)
-    return TokError("expected ',' as start of index list");
+    return tokError("expected ',' as start of index list");
 
   while (EatIfPresent(lltok::comma)) {
     if (Lex.getKind() == lltok::MetadataVar) {
-      if (Indices.empty()) return TokError("expected index");
+      if (Indices.empty())
+        return tokError("expected index");
       AteExtraComma = true;
       return false;
     }
     unsigned Idx = 0;
-    if (ParseUInt32(Idx)) return true;
+    if (parseUInt32(Idx))
+      return true;
     Indices.push_back(Idx);
   }
 
@@ -2386,12 +2469,12 @@ bool LLParser::ParseIndexList(SmallVectorImpl<unsigned> &Indices,
 // Type Parsing.
 //===----------------------------------------------------------------------===//
 
-/// ParseType - Parse a type.
-bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
+/// parseType - parse a type.
+bool LLParser::parseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
   SMLoc TypeLoc = Lex.getLoc();
   switch (Lex.getKind()) {
   default:
-    return TokError(Msg);
+    return tokError(Msg);
   case lltok::Type:
     // Type ::= 'float' | 'void' (etc)
     Result = Lex.getTyVal();
@@ -2399,23 +2482,23 @@ bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
     break;
   case lltok::lbrace:
     // Type ::= StructType
-    if (ParseAnonStructType(Result, false))
+    if (parseAnonStructType(Result, false))
       return true;
     break;
   case lltok::lsquare:
     // Type ::= '[' ... ']'
     Lex.Lex(); // eat the lsquare.
-    if (ParseArrayVectorType(Result, false))
+    if (parseArrayVectorType(Result, false))
       return true;
     break;
   case lltok::less: // Either vector or packed struct.
     // Type ::= '<' ... '>'
     Lex.Lex();
     if (Lex.getKind() == lltok::lbrace) {
-      if (ParseAnonStructType(Result, true) ||
-          ParseToken(lltok::greater, "expected '>' at end of packed struct"))
+      if (parseAnonStructType(Result, true) ||
+          parseToken(lltok::greater, "expected '>' at end of packed struct"))
         return true;
-    } else if (ParseArrayVectorType(Result, true))
+    } else if (parseArrayVectorType(Result, true))
       return true;
     break;
   case lltok::LocalVar: {
@@ -2449,23 +2532,23 @@ bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
   }
   }
 
-  // Parse the type suffixes.
+  // parse the type suffixes.
   while (true) {
     switch (Lex.getKind()) {
     // End of type.
     default:
       if (!AllowVoid && Result->isVoidTy())
-        return Error(TypeLoc, "void type only allowed for function results");
+        return error(TypeLoc, "void type only allowed for function results");
       return false;
 
     // Type ::= Type '*'
     case lltok::star:
       if (Result->isLabelTy())
-        return TokError("basic block pointers are invalid");
+        return tokError("basic block pointers are invalid");
       if (Result->isVoidTy())
-        return TokError("pointers to void are invalid - use i8* instead");
+        return tokError("pointers to void are invalid - use i8* instead");
       if (!PointerType::isValidElementType(Result))
-        return TokError("pointer to this type is invalid");
+        return tokError("pointer to this type is invalid");
       Result = PointerType::getUnqual(Result);
       Lex.Lex();
       break;
@@ -2473,14 +2556,14 @@ bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
     // Type ::= Type 'addrspace' '(' uint32 ')' '*'
     case lltok::kw_addrspace: {
       if (Result->isLabelTy())
-        return TokError("basic block pointers are invalid");
+        return tokError("basic block pointers are invalid");
       if (Result->isVoidTy())
-        return TokError("pointers to void are invalid; use i8* instead");
+        return tokError("pointers to void are invalid; use i8* instead");
       if (!PointerType::isValidElementType(Result))
-        return TokError("pointer to this type is invalid");
+        return tokError("pointer to this type is invalid");
       unsigned AddrSpace;
-      if (ParseOptionalAddrSpace(AddrSpace) ||
-          ParseToken(lltok::star, "expected '*' in address space"))
+      if (parseOptionalAddrSpace(AddrSpace) ||
+          parseToken(lltok::star, "expected '*' in address space"))
         return true;
 
       Result = PointerType::get(Result, AddrSpace);
@@ -2489,55 +2572,55 @@ bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
 
     /// Types '(' ArgTypeListI ')' OptFuncAttrs
     case lltok::lparen:
-      if (ParseFunctionType(Result))
+      if (parseFunctionType(Result))
         return true;
       break;
     }
   }
 }
 
-/// ParseParameterList
+/// parseParameterList
 ///    ::= '(' ')'
 ///    ::= '(' Arg (',' Arg)* ')'
 ///  Arg
 ///    ::= Type OptionalAttributes Value OptionalAttributes
-bool LLParser::ParseParameterList(SmallVectorImpl<ParamInfo> &ArgList,
+bool LLParser::parseParameterList(SmallVectorImpl<ParamInfo> &ArgList,
                                   PerFunctionState &PFS, bool IsMustTailCall,
                                   bool InVarArgsFunc) {
-  if (ParseToken(lltok::lparen, "expected '(' in call"))
+  if (parseToken(lltok::lparen, "expected '(' in call"))
     return true;
 
   while (Lex.getKind() != lltok::rparen) {
     // If this isn't the first argument, we need a comma.
     if (!ArgList.empty() &&
-        ParseToken(lltok::comma, "expected ',' in argument list"))
+        parseToken(lltok::comma, "expected ',' in argument list"))
       return true;
 
-    // Parse an ellipsis if this is a musttail call in a variadic function.
+    // parse an ellipsis if this is a musttail call in a variadic function.
     if (Lex.getKind() == lltok::dotdotdot) {
       const char *Msg = "unexpected ellipsis in argument list for ";
       if (!IsMustTailCall)
-        return TokError(Twine(Msg) + "non-musttail call");
+        return tokError(Twine(Msg) + "non-musttail call");
       if (!InVarArgsFunc)
-        return TokError(Twine(Msg) + "musttail call in non-varargs function");
+        return tokError(Twine(Msg) + "musttail call in non-varargs function");
       Lex.Lex();  // Lex the '...', it is purely for readability.
-      return ParseToken(lltok::rparen, "expected ')' at end of argument list");
+      return parseToken(lltok::rparen, "expected ')' at end of argument list");
     }
 
-    // Parse the argument.
+    // parse the argument.
     LocTy ArgLoc;
     Type *ArgTy = nullptr;
     AttrBuilder ArgAttrs;
     Value *V;
-    if (ParseType(ArgTy, ArgLoc))
+    if (parseType(ArgTy, ArgLoc))
       return true;
 
     if (ArgTy->isMetadataTy()) {
-      if (ParseMetadataAsValue(V, PFS))
+      if (parseMetadataAsValue(V, PFS))
         return true;
     } else {
       // Otherwise, handle normal operands.
-      if (ParseOptionalParamAttrs(ArgAttrs) || ParseValue(ArgTy, V, PFS))
+      if (parseOptionalParamAttrs(ArgAttrs) || parseValue(ArgTy, V, PFS))
         return true;
     }
     ArgList.push_back(ParamInfo(
@@ -2545,45 +2628,41 @@ bool LLParser::ParseParameterList(SmallVectorImpl<ParamInfo> &ArgList,
   }
 
   if (IsMustTailCall && InVarArgsFunc)
-    return TokError("expected '...' at end of argument list for musttail call "
+    return tokError("expected '...' at end of argument list for musttail call "
                     "in varargs function");
 
   Lex.Lex();  // Lex the ')'.
   return false;
 }
 
-/// ParseByValWithOptionalType
-///   ::= byval
-///   ::= byval(<ty>)
-bool LLParser::ParseByValWithOptionalType(Type *&Result) {
+/// parseRequiredTypeAttr
+///   ::= attrname(<ty>)
+bool LLParser::parseRequiredTypeAttr(Type *&Result, lltok::Kind AttrName) {
   Result = nullptr;
-  if (!EatIfPresent(lltok::kw_byval))
+  if (!EatIfPresent(AttrName))
     return true;
   if (!EatIfPresent(lltok::lparen))
-    return false;
-  if (ParseType(Result))
+    return error(Lex.getLoc(), "expected '('");
+  if (parseType(Result))
     return true;
   if (!EatIfPresent(lltok::rparen))
-    return Error(Lex.getLoc(), "expected ')'");
+    return error(Lex.getLoc(), "expected ')'");
   return false;
 }
 
-/// ParsePreallocated
+/// parsePreallocated
 ///   ::= preallocated(<ty>)
-bool LLParser::ParsePreallocated(Type *&Result) {
-  Result = nullptr;
-  if (!EatIfPresent(lltok::kw_preallocated))
-    return true;
-  if (!EatIfPresent(lltok::lparen))
-    return Error(Lex.getLoc(), "expected '('");
-  if (ParseType(Result))
-    return true;
-  if (!EatIfPresent(lltok::rparen))
-    return Error(Lex.getLoc(), "expected ')'");
-  return false;
+bool LLParser::parsePreallocated(Type *&Result) {
+  return parseRequiredTypeAttr(Result, lltok::kw_preallocated);
+}
+
+/// parseByRef
+///   ::= byref(<type>)
+bool LLParser::parseByRef(Type *&Result) {
+  return parseRequiredTypeAttr(Result, lltok::kw_byref);
 }
 
-/// ParseOptionalOperandBundles
+/// parseOptionalOperandBundles
 ///    ::= /*empty*/
 ///    ::= '[' OperandBundle [, OperandBundle ]* ']'
 ///
@@ -2592,7 +2671,7 @@ bool LLParser::ParsePreallocated(Type *&Result) {
 ///    ::= bundle-tag '(' Type Value [, Type Value ]* ')'
 ///
 /// bundle-tag ::= String Constant
-bool LLParser::ParseOptionalOperandBundles(
+bool LLParser::parseOptionalOperandBundles(
     SmallVectorImpl<OperandBundleDef> &BundleList, PerFunctionState &PFS) {
   LocTy BeginLoc = Lex.getLoc();
   if (!EatIfPresent(lltok::lsquare))
@@ -2601,26 +2680,26 @@ bool LLParser::ParseOptionalOperandBundles(
   while (Lex.getKind() != lltok::rsquare) {
     // If this isn't the first operand bundle, we need a comma.
     if (!BundleList.empty() &&
-        ParseToken(lltok::comma, "expected ',' in input list"))
+        parseToken(lltok::comma, "expected ',' in input list"))
       return true;
 
     std::string Tag;
-    if (ParseStringConstant(Tag))
+    if (parseStringConstant(Tag))
       return true;
 
-    if (ParseToken(lltok::lparen, "expected '(' in operand bundle"))
+    if (parseToken(lltok::lparen, "expected '(' in operand bundle"))
       return true;
 
     std::vector<Value *> Inputs;
     while (Lex.getKind() != lltok::rparen) {
       // If this isn't the first input, we need a comma.
       if (!Inputs.empty() &&
-          ParseToken(lltok::comma, "expected ',' in input list"))
+          parseToken(lltok::comma, "expected ',' in input list"))
         return true;
 
       Type *Ty = nullptr;
       Value *Input = nullptr;
-      if (ParseType(Ty) || ParseValue(Ty, Input, PFS))
+      if (parseType(Ty) || parseValue(Ty, Input, PFS))
         return true;
       Inputs.push_back(Input);
     }
@@ -2631,13 +2710,13 @@ bool LLParser::ParseOptionalOperandBundles(
   }
 
   if (BundleList.empty())
-    return Error(BeginLoc, "operand bundle set must not be empty");
+    return error(BeginLoc, "operand bundle set must not be empty");
 
   Lex.Lex(); // Lex the ']'.
   return false;
 }
 
-/// ParseArgumentList - Parse the argument list for a function type or function
+/// parseArgumentList - parse the argument list for a function type or function
 /// prototype.
 ///   ::= '(' ArgTypeListI ')'
 /// ArgTypeListI
@@ -2646,17 +2725,17 @@ bool LLParser::ParseOptionalOperandBundles(
 ///   ::= ArgTypeList ',' '...'
 ///   ::= ArgType (',' ArgType)*
 ///
-bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
-                                 bool &isVarArg){
+bool LLParser::parseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
+                                 bool &IsVarArg) {
   unsigned CurValID = 0;
-  isVarArg = false;
+  IsVarArg = false;
   assert(Lex.getKind() == lltok::lparen);
   Lex.Lex(); // eat the (.
 
   if (Lex.getKind() == lltok::rparen) {
     // empty
   } else if (Lex.getKind() == lltok::dotdotdot) {
-    isVarArg = true;
+    IsVarArg = true;
     Lex.Lex();
   } else {
     LocTy TypeLoc = Lex.getLoc();
@@ -2664,25 +2743,25 @@ bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
     AttrBuilder Attrs;
     std::string Name;
 
-    if (ParseType(ArgTy) ||
-        ParseOptionalParamAttrs(Attrs)) return true;
+    if (parseType(ArgTy) || parseOptionalParamAttrs(Attrs))
+      return true;
 
     if (ArgTy->isVoidTy())
-      return Error(TypeLoc, "argument can not have void type");
+      return error(TypeLoc, "argument can not have void type");
 
     if (Lex.getKind() == lltok::LocalVar) {
       Name = Lex.getStrVal();
       Lex.Lex();
     } else if (Lex.getKind() == lltok::LocalVarID) {
       if (Lex.getUIntVal() != CurValID)
-        return Error(TypeLoc, "argument expected to be numbered '%" +
+        return error(TypeLoc, "argument expected to be numbered '%" +
                                   Twine(CurValID) + "'");
       ++CurValID;
       Lex.Lex();
     }
 
     if (!FunctionType::isValidArgumentType(ArgTy))
-      return Error(TypeLoc, "invalid type for function argument");
+      return error(TypeLoc, "invalid type for function argument");
 
     ArgList.emplace_back(TypeLoc, ArgTy,
                          AttributeSet::get(ArgTy->getContext(), Attrs),
@@ -2691,16 +2770,17 @@ bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
     while (EatIfPresent(lltok::comma)) {
       // Handle ... at end of arg list.
       if (EatIfPresent(lltok::dotdotdot)) {
-        isVarArg = true;
+        IsVarArg = true;
         break;
       }
 
       // Otherwise must be an argument type.
       TypeLoc = Lex.getLoc();
-      if (ParseType(ArgTy) || ParseOptionalParamAttrs(Attrs)) return true;
+      if (parseType(ArgTy) || parseOptionalParamAttrs(Attrs))
+        return true;
 
       if (ArgTy->isVoidTy())
-        return Error(TypeLoc, "argument can not have void type");
+        return error(TypeLoc, "argument can not have void type");
 
       if (Lex.getKind() == lltok::LocalVar) {
         Name = Lex.getStrVal();
@@ -2708,7 +2788,7 @@ bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
       } else {
         if (Lex.getKind() == lltok::LocalVarID) {
           if (Lex.getUIntVal() != CurValID)
-            return Error(TypeLoc, "argument expected to be numbered '%" +
+            return error(TypeLoc, "argument expected to be numbered '%" +
                                       Twine(CurValID) + "'");
           Lex.Lex();
         }
@@ -2717,7 +2797,7 @@ bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
       }
 
       if (!ArgTy->isFirstClassType())
-        return Error(TypeLoc, "invalid type for function argument");
+        return error(TypeLoc, "invalid type for function argument");
 
       ArgList.emplace_back(TypeLoc, ArgTy,
                            AttributeSet::get(ArgTy->getContext(), Attrs),
@@ -2725,28 +2805,28 @@ bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
     }
   }
 
-  return ParseToken(lltok::rparen, "expected ')' at end of argument list");
+  return parseToken(lltok::rparen, "expected ')' at end of argument list");
 }
 
-/// ParseFunctionType
+/// parseFunctionType
 ///  ::= Type ArgumentList OptionalAttrs
-bool LLParser::ParseFunctionType(Type *&Result) {
+bool LLParser::parseFunctionType(Type *&Result) {
   assert(Lex.getKind() == lltok::lparen);
 
   if (!FunctionType::isValidReturnType(Result))
-    return TokError("invalid function return type");
+    return tokError("invalid function return type");
 
   SmallVector<ArgInfo, 8> ArgList;
-  bool isVarArg;
-  if (ParseArgumentList(ArgList, isVarArg))
+  bool IsVarArg;
+  if (parseArgumentList(ArgList, IsVarArg))
     return true;
 
   // Reject names on the arguments lists.
   for (unsigned i = 0, e = ArgList.size(); i != e; ++i) {
     if (!ArgList[i].Name.empty())
-      return Error(ArgList[i].Loc, "argument name invalid in function type");
+      return error(ArgList[i].Loc, "argument name invalid in function type");
     if (ArgList[i].Attrs.hasAttributes())
-      return Error(ArgList[i].Loc,
+      return error(ArgList[i].Loc,
                    "argument attributes invalid in function type");
   }
 
@@ -2754,27 +2834,28 @@ bool LLParser::ParseFunctionType(Type *&Result) {
   for (unsigned i = 0, e = ArgList.size(); i != e; ++i)
     ArgListTy.push_back(ArgList[i].Ty);
 
-  Result = FunctionType::get(Result, ArgListTy, isVarArg);
+  Result = FunctionType::get(Result, ArgListTy, IsVarArg);
   return false;
 }
 
-/// ParseAnonStructType - Parse an anonymous struct type, which is inlined into
+/// parseAnonStructType - parse an anonymous struct type, which is inlined into
 /// other structs.
-bool LLParser::ParseAnonStructType(Type *&Result, bool Packed) {
+bool LLParser::parseAnonStructType(Type *&Result, bool Packed) {
   SmallVector<Type*, 8> Elts;
-  if (ParseStructBody(Elts)) return true;
+  if (parseStructBody(Elts))
+    return true;
 
   Result = StructType::get(Context, Elts, Packed);
   return false;
 }
 
-/// ParseStructDefinition - Parse a struct in a 'type' definition.
-bool LLParser::ParseStructDefinition(SMLoc TypeLoc, StringRef Name,
-                                     std::pair<Type*, LocTy> &Entry,
+/// parseStructDefinition - parse a struct in a 'type' definition.
+bool LLParser::parseStructDefinition(SMLoc TypeLoc, StringRef Name,
+                                     std::pair<Type *, LocTy> &Entry,
                                      Type *&ResultTy) {
   // If the type was already defined, diagnose the redefinition.
   if (Entry.first && !Entry.second.isValid())
-    return Error(TypeLoc, "redefinition of type");
+    return error(TypeLoc, "redefinition of type");
 
   // If we have opaque, just return without filling in the definition for the
   // struct.  This counts as a definition as far as the .ll file goes.
@@ -2797,12 +2878,12 @@ bool LLParser::ParseStructDefinition(SMLoc TypeLoc, StringRef Name,
   // forward referenced and not allowed to be recursive.
   if (Lex.getKind() != lltok::lbrace) {
     if (Entry.first)
-      return Error(TypeLoc, "forward references to non-struct type");
+      return error(TypeLoc, "forward references to non-struct type");
 
     ResultTy = nullptr;
     if (isPacked)
-      return ParseArrayVectorType(ResultTy, true);
-    return ParseType(ResultTy);
+      return parseArrayVectorType(ResultTy, true);
+    return parseType(ResultTy);
   }
 
   // This type is being defined, so clear the location to indicate this.
@@ -2815,8 +2896,8 @@ bool LLParser::ParseStructDefinition(SMLoc TypeLoc, StringRef Name,
   StructType *STy = cast<StructType>(Entry.first);
 
   SmallVector<Type*, 8> Body;
-  if (ParseStructBody(Body) ||
-      (isPacked && ParseToken(lltok::greater, "expected '>' in packed struct")))
+  if (parseStructBody(Body) ||
+      (isPacked && parseToken(lltok::greater, "expected '>' in packed struct")))
     return true;
 
   STy->setBody(Body, isPacked);
@@ -2824,13 +2905,13 @@ bool LLParser::ParseStructDefinition(SMLoc TypeLoc, StringRef Name,
   return false;
 }
 
-/// ParseStructType: Handles packed and unpacked types.  </> parsed elsewhere.
+/// parseStructType: Handles packed and unpacked types.  </> parsed elsewhere.
 ///   StructType
 ///     ::= '{' '}'
 ///     ::= '{' Type (',' Type)* '}'
 ///     ::= '<' '{' '}' '>'
 ///     ::= '<' '{' Type (',' Type)* '}' '>'
-bool LLParser::ParseStructBody(SmallVectorImpl<Type*> &Body) {
+bool LLParser::parseStructBody(SmallVectorImpl<Type *> &Body) {
   assert(Lex.getKind() == lltok::lbrace);
   Lex.Lex(); // Consume the '{'
 
@@ -2840,37 +2921,39 @@ bool LLParser::ParseStructBody(SmallVectorImpl<Type*> &Body) {
 
   LocTy EltTyLoc = Lex.getLoc();
   Type *Ty = nullptr;
-  if (ParseType(Ty)) return true;
+  if (parseType(Ty))
+    return true;
   Body.push_back(Ty);
 
   if (!StructType::isValidElementType(Ty))
-    return Error(EltTyLoc, "invalid element type for struct");
+    return error(EltTyLoc, "invalid element type for struct");
 
   while (EatIfPresent(lltok::comma)) {
     EltTyLoc = Lex.getLoc();
-    if (ParseType(Ty)) return true;
+    if (parseType(Ty))
+      return true;
 
     if (!StructType::isValidElementType(Ty))
-      return Error(EltTyLoc, "invalid element type for struct");
+      return error(EltTyLoc, "invalid element type for struct");
 
     Body.push_back(Ty);
   }
 
-  return ParseToken(lltok::rbrace, "expected '}' at end of struct");
+  return parseToken(lltok::rbrace, "expected '}' at end of struct");
 }
 
-/// ParseArrayVectorType - Parse an array or vector type, assuming the first
+/// parseArrayVectorType - parse an array or vector type, assuming the first
 /// token has already been consumed.
 ///   Type
 ///     ::= '[' APSINTVAL 'x' Types ']'
 ///     ::= '<' APSINTVAL 'x' Types '>'
 ///     ::= '<' 'vscale' 'x' APSINTVAL 'x' Types '>'
-bool LLParser::ParseArrayVectorType(Type *&Result, bool isVector) {
+bool LLParser::parseArrayVectorType(Type *&Result, bool IsVector) {
   bool Scalable = false;
 
-  if (isVector && Lex.getKind() == lltok::kw_vscale) {
+  if (IsVector && Lex.getKind() == lltok::kw_vscale) {
     Lex.Lex(); // consume the 'vscale'
-    if (ParseToken(lltok::kw_x, "expected 'x' after vscale"))
+    if (parseToken(lltok::kw_x, "expected 'x' after vscale"))
       return true;
 
     Scalable = true;
@@ -2878,34 +2961,35 @@ bool LLParser::ParseArrayVectorType(Type *&Result, bool isVector) {
 
   if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned() ||
       Lex.getAPSIntVal().getBitWidth() > 64)
-    return TokError("expected number in address space");
+    return tokError("expected number in address space");
 
   LocTy SizeLoc = Lex.getLoc();
   uint64_t Size = Lex.getAPSIntVal().getZExtValue();
   Lex.Lex();
 
-  if (ParseToken(lltok::kw_x, "expected 'x' after element count"))
-      return true;
+  if (parseToken(lltok::kw_x, "expected 'x' after element count"))
+    return true;
 
   LocTy TypeLoc = Lex.getLoc();
   Type *EltTy = nullptr;
-  if (ParseType(EltTy)) return true;
+  if (parseType(EltTy))
+    return true;
 
-  if (ParseToken(isVector ? lltok::greater : lltok::rsquare,
+  if (parseToken(IsVector ? lltok::greater : lltok::rsquare,
                  "expected end of sequential type"))
     return true;
 
-  if (isVector) {
+  if (IsVector) {
     if (Size == 0)
-      return Error(SizeLoc, "zero element vector is illegal");
+      return error(SizeLoc, "zero element vector is illegal");
     if ((unsigned)Size != Size)
-      return Error(SizeLoc, "size too large for vector");
+      return error(SizeLoc, "size too large for vector");
     if (!VectorType::isValidElementType(EltTy))
-      return Error(TypeLoc, "invalid vector element type");
+      return error(TypeLoc, "invalid vector element type");
     Result = VectorType::get(EltTy, unsigned(Size), Scalable);
   } else {
     if (!ArrayType::isValidElementType(EltTy))
-      return Error(TypeLoc, "invalid array element type");
+      return error(TypeLoc, "invalid array element type");
     Result = ArrayType::get(EltTy, Size);
   }
   return false;
@@ -2945,22 +3029,22 @@ LLParser::PerFunctionState::~PerFunctionState() {
   }
 }
 
-bool LLParser::PerFunctionState::FinishFunction() {
+bool LLParser::PerFunctionState::finishFunction() {
   if (!ForwardRefVals.empty())
-    return P.Error(ForwardRefVals.begin()->second.second,
+    return P.error(ForwardRefVals.begin()->second.second,
                    "use of undefined value '%" + ForwardRefVals.begin()->first +
-                   "'");
+                       "'");
   if (!ForwardRefValIDs.empty())
-    return P.Error(ForwardRefValIDs.begin()->second.second,
+    return P.error(ForwardRefValIDs.begin()->second.second,
                    "use of undefined value '%" +
-                   Twine(ForwardRefValIDs.begin()->first) + "'");
+                       Twine(ForwardRefValIDs.begin()->first) + "'");
   return false;
 }
 
-/// GetVal - Get a value with the specified name or ID, creating a
+/// getVal - Get a value with the specified name or ID, creating a
 /// forward reference record if needed.  This can return null if the value
 /// exists but does not have the right type.
-Value *LLParser::PerFunctionState::GetVal(const std::string &Name, Type *Ty,
+Value *LLParser::PerFunctionState::getVal(const std::string &Name, Type *Ty,
                                           LocTy Loc, bool IsCall) {
   // Look this name up in the normal function symbol table.
   Value *Val = F.getValueSymbolTable()->lookup(Name);
@@ -2979,7 +3063,7 @@ Value *LLParser::PerFunctionState::GetVal(const std::string &Name, Type *Ty,
 
   // Don't make placeholders with invalid type.
   if (!Ty->isFirstClassType()) {
-    P.Error(Loc, "invalid use of a non-first-class type");
+    P.error(Loc, "invalid use of a non-first-class type");
     return nullptr;
   }
 
@@ -2995,7 +3079,7 @@ Value *LLParser::PerFunctionState::GetVal(const std::string &Name, Type *Ty,
   return FwdVal;
 }
 
-Value *LLParser::PerFunctionState::GetVal(unsigned ID, Type *Ty, LocTy Loc,
+Value *LLParser::PerFunctionState::getVal(unsigned ID, Type *Ty, LocTy Loc,
                                           bool IsCall) {
   // Look this name up in the normal function symbol table.
   Value *Val = ID < NumberedVals.size() ? NumberedVals[ID] : nullptr;
@@ -3013,7 +3097,7 @@ Value *LLParser::PerFunctionState::GetVal(unsigned ID, Type *Ty, LocTy Loc,
     return P.checkValidVariableType(Loc, "%" + Twine(ID), Ty, Val, IsCall);
 
   if (!Ty->isFirstClassType()) {
-    P.Error(Loc, "invalid use of a non-first-class type");
+    P.error(Loc, "invalid use of a non-first-class type");
     return nullptr;
   }
 
@@ -3029,15 +3113,15 @@ Value *LLParser::PerFunctionState::GetVal(unsigned ID, Type *Ty, LocTy Loc,
   return FwdVal;
 }
 
-/// SetInstName - After an instruction is parsed and inserted into its
+/// setInstName - After an instruction is parsed and inserted into its
 /// basic block, this installs its name.
-bool LLParser::PerFunctionState::SetInstName(int NameID,
+bool LLParser::PerFunctionState::setInstName(int NameID,
                                              const std::string &NameStr,
                                              LocTy NameLoc, Instruction *Inst) {
   // If this instruction has void type, it cannot have a name or ID specified.
   if (Inst->getType()->isVoidTy()) {
     if (NameID != -1 || !NameStr.empty())
-      return P.Error(NameLoc, "instructions returning void cannot have a name");
+      return P.error(NameLoc, "instructions returning void cannot have a name");
     return false;
   }
 
@@ -3049,15 +3133,16 @@ bool LLParser::PerFunctionState::SetInstName(int NameID,
       NameID = NumberedVals.size();
 
     if (unsigned(NameID) != NumberedVals.size())
-      return P.Error(NameLoc, "instruction expected to be numbered '%" +
-                     Twine(NumberedVals.size()) + "'");
+      return P.error(NameLoc, "instruction expected to be numbered '%" +
+                                  Twine(NumberedVals.size()) + "'");
 
     auto FI = ForwardRefValIDs.find(NameID);
     if (FI != ForwardRefValIDs.end()) {
       Value *Sentinel = FI->second.first;
       if (Sentinel->getType() != Inst->getType())
-        return P.Error(NameLoc, "instruction forward referenced with type '" +
-                       getTypeString(FI->second.first->getType()) + "'");
+        return P.error(NameLoc, "instruction forward referenced with type '" +
+                                    getTypeString(FI->second.first->getType()) +
+                                    "'");
 
       Sentinel->replaceAllUsesWith(Inst);
       Sentinel->deleteValue();
@@ -3073,8 +3158,9 @@ bool LLParser::PerFunctionState::SetInstName(int NameID,
   if (FI != ForwardRefVals.end()) {
     Value *Sentinel = FI->second.first;
     if (Sentinel->getType() != Inst->getType())
-      return P.Error(NameLoc, "instruction forward referenced with type '" +
-                     getTypeString(FI->second.first->getType()) + "'");
+      return P.error(NameLoc, "instruction forward referenced with type '" +
+                                  getTypeString(FI->second.first->getType()) +
+                                  "'");
 
     Sentinel->replaceAllUsesWith(Inst);
     Sentinel->deleteValue();
@@ -3085,46 +3171,46 @@ bool LLParser::PerFunctionState::SetInstName(int NameID,
   Inst->setName(NameStr);
 
   if (Inst->getName() != NameStr)
-    return P.Error(NameLoc, "multiple definition of local value named '" +
-                   NameStr + "'");
+    return P.error(NameLoc, "multiple definition of local value named '" +
+                                NameStr + "'");
   return false;
 }
 
-/// GetBB - Get a basic block with the specified name or ID, creating a
+/// getBB - Get a basic block with the specified name or ID, creating a
 /// forward reference record if needed.
-BasicBlock *LLParser::PerFunctionState::GetBB(const std::string &Name,
+BasicBlock *LLParser::PerFunctionState::getBB(const std::string &Name,
                                               LocTy Loc) {
   return dyn_cast_or_null<BasicBlock>(
-      GetVal(Name, Type::getLabelTy(F.getContext()), Loc, /*IsCall=*/false));
+      getVal(Name, Type::getLabelTy(F.getContext()), Loc, /*IsCall=*/false));
 }
 
-BasicBlock *LLParser::PerFunctionState::GetBB(unsigned ID, LocTy Loc) {
+BasicBlock *LLParser::PerFunctionState::getBB(unsigned ID, LocTy Loc) {
   return dyn_cast_or_null<BasicBlock>(
-      GetVal(ID, Type::getLabelTy(F.getContext()), Loc, /*IsCall=*/false));
+      getVal(ID, Type::getLabelTy(F.getContext()), Loc, /*IsCall=*/false));
 }
 
-/// DefineBB - Define the specified basic block, which is either named or
+/// defineBB - Define the specified basic block, which is either named or
 /// unnamed.  If there is an error, this returns null otherwise it returns
 /// the block being defined.
-BasicBlock *LLParser::PerFunctionState::DefineBB(const std::string &Name,
+BasicBlock *LLParser::PerFunctionState::defineBB(const std::string &Name,
                                                  int NameID, LocTy Loc) {
   BasicBlock *BB;
   if (Name.empty()) {
     if (NameID != -1 && unsigned(NameID) != NumberedVals.size()) {
-      P.Error(Loc, "label expected to be numbered '" +
+      P.error(Loc, "label expected to be numbered '" +
                        Twine(NumberedVals.size()) + "'");
       return nullptr;
     }
-    BB = GetBB(NumberedVals.size(), Loc);
+    BB = getBB(NumberedVals.size(), Loc);
     if (!BB) {
-      P.Error(Loc, "unable to create block numbered '" +
+      P.error(Loc, "unable to create block numbered '" +
                        Twine(NumberedVals.size()) + "'");
       return nullptr;
     }
   } else {
-    BB = GetBB(Name, Loc);
+    BB = getBB(Name, Loc);
     if (!BB) {
-      P.Error(Loc, "unable to create block named '" + Name + "'");
+      P.error(Loc, "unable to create block named '" + Name + "'");
       return nullptr;
     }
   }
@@ -3149,16 +3235,17 @@ BasicBlock *LLParser::PerFunctionState::DefineBB(const std::string &Name,
 // Constants.
 //===----------------------------------------------------------------------===//
 
-/// ParseValID - Parse an abstract value that doesn't necessarily have a
+/// parseValID - parse an abstract value that doesn't necessarily have a
 /// type implied.  For example, if we parse "4" we don't know what integer type
 /// it has.  The value will later be combined with its type and checked for
 /// sanity.  PFS is used to convert function-local operands of metadata (since
 /// metadata operands are not just parsed here but also converted to values).
 /// PFS can be null when we are not parsing metadata values inside a function.
-bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
+bool LLParser::parseValID(ValID &ID, PerFunctionState *PFS) {
   ID.Loc = Lex.getLoc();
   switch (Lex.getKind()) {
-  default: return TokError("expected value token");
+  default:
+    return tokError("expected value token");
   case lltok::GlobalID:  // @42
     ID.UIntVal = Lex.getUIntVal();
     ID.Kind = ValID::t_GlobalID;
@@ -3193,6 +3280,7 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     break;
   case lltok::kw_null: ID.Kind = ValID::t_Null; break;
   case lltok::kw_undef: ID.Kind = ValID::t_Undef; break;
+  case lltok::kw_poison: ID.Kind = ValID::t_Poison; break;
   case lltok::kw_zeroinitializer: ID.Kind = ValID::t_Zero; break;
   case lltok::kw_none: ID.Kind = ValID::t_None; break;
 
@@ -3200,8 +3288,8 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     // ValID ::= '{' ConstVector '}'
     Lex.Lex();
     SmallVector<Constant*, 16> Elts;
-    if (ParseGlobalValueVector(Elts) ||
-        ParseToken(lltok::rbrace, "expected end of struct constant"))
+    if (parseGlobalValueVector(Elts) ||
+        parseToken(lltok::rbrace, "expected end of struct constant"))
       return true;
 
     ID.ConstantStructElts = std::make_unique<Constant *[]>(Elts.size());
@@ -3219,10 +3307,10 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
 
     SmallVector<Constant*, 16> Elts;
     LocTy FirstEltLoc = Lex.getLoc();
-    if (ParseGlobalValueVector(Elts) ||
+    if (parseGlobalValueVector(Elts) ||
         (isPackedStruct &&
-         ParseToken(lltok::rbrace, "expected end of packed struct")) ||
-        ParseToken(lltok::greater, "expected end of constant"))
+         parseToken(lltok::rbrace, "expected end of packed struct")) ||
+        parseToken(lltok::greater, "expected end of constant"))
       return true;
 
     if (isPackedStruct) {
@@ -3235,20 +3323,21 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     }
 
     if (Elts.empty())
-      return Error(ID.Loc, "constant vector must not be empty");
+      return error(ID.Loc, "constant vector must not be empty");
 
     if (!Elts[0]->getType()->isIntegerTy() &&
         !Elts[0]->getType()->isFloatingPointTy() &&
         !Elts[0]->getType()->isPointerTy())
-      return Error(FirstEltLoc,
-            "vector elements must have integer, pointer or floating point type");
+      return error(
+          FirstEltLoc,
+          "vector elements must have integer, pointer or floating point type");
 
     // Verify that all the vector elements have the same type.
     for (unsigned i = 1, e = Elts.size(); i != e; ++i)
       if (Elts[i]->getType() != Elts[0]->getType())
-        return Error(FirstEltLoc,
-                     "vector element #" + Twine(i) +
-                    " is not of type '" + getTypeString(Elts[0]->getType()));
+        return error(FirstEltLoc, "vector element #" + Twine(i) +
+                                      " is not of type '" +
+                                      getTypeString(Elts[0]->getType()));
 
     ID.ConstantVal = ConstantVector::get(Elts);
     ID.Kind = ValID::t_Constant;
@@ -3258,8 +3347,8 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     Lex.Lex();
     SmallVector<Constant*, 16> Elts;
     LocTy FirstEltLoc = Lex.getLoc();
-    if (ParseGlobalValueVector(Elts) ||
-        ParseToken(lltok::rsquare, "expected end of array constant"))
+    if (parseGlobalValueVector(Elts) ||
+        parseToken(lltok::rsquare, "expected end of array constant"))
       return true;
 
     // Handle empty element.
@@ -3321,17 +3411,18 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
 
     ValID Fn, Label;
 
-    if (ParseToken(lltok::lparen, "expected '(' in block address expression") ||
-        ParseValID(Fn) ||
-        ParseToken(lltok::comma, "expected comma in block address expression")||
-        ParseValID(Label) ||
-        ParseToken(lltok::rparen, "expected ')' in block address expression"))
+    if (parseToken(lltok::lparen, "expected '(' in block address expression") ||
+        parseValID(Fn) ||
+        parseToken(lltok::comma,
+                   "expected comma in block address expression") ||
+        parseValID(Label) ||
+        parseToken(lltok::rparen, "expected ')' in block address expression"))
       return true;
 
     if (Fn.Kind != ValID::t_GlobalID && Fn.Kind != ValID::t_GlobalName)
-      return Error(Fn.Loc, "expected function name in blockaddress");
+      return error(Fn.Loc, "expected function name in blockaddress");
     if (Label.Kind != ValID::t_LocalID && Label.Kind != ValID::t_LocalName)
-      return Error(Label.Loc, "expected basic block name in blockaddress");
+      return error(Label.Loc, "expected basic block name in blockaddress");
 
     // Try to find the function (but skip it if it's forward-referenced).
     GlobalValue *GV = nullptr;
@@ -3392,6 +3483,39 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     return false;
   }
 
+  case lltok::kw_dso_local_equivalent: {
+    // ValID ::= 'dso_local_equivalent' @foo
+    Lex.Lex();
+
+    ValID Fn;
+
+    if (parseValID(Fn))
+      return true;
+
+    if (Fn.Kind != ValID::t_GlobalID && Fn.Kind != ValID::t_GlobalName)
+      return error(Fn.Loc,
+                   "expected global value name in dso_local_equivalent");
+
+    // Try to find the function (but skip it if it's forward-referenced).
+    GlobalValue *GV = nullptr;
+    if (Fn.Kind == ValID::t_GlobalID) {
+      if (Fn.UIntVal < NumberedVals.size())
+        GV = NumberedVals[Fn.UIntVal];
+    } else if (!ForwardRefVals.count(Fn.StrVal)) {
+      GV = M->getNamedValue(Fn.StrVal);
+    }
+
+    assert(GV && "Could not find a corresponding global variable");
+
+    if (!GV->getValueType()->isFunctionTy())
+      return error(Fn.Loc, "expected a function, alias to function, or ifunc "
+                           "in dso_local_equivalent");
+
+    ID.ConstantVal = DSOLocalEquivalent::get(GV);
+    ID.Kind = ValID::t_Constant;
+    return false;
+  }
+
   case lltok::kw_trunc:
   case lltok::kw_zext:
   case lltok::kw_sext:
@@ -3409,16 +3533,16 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     Type *DestTy = nullptr;
     Constant *SrcVal;
     Lex.Lex();
-    if (ParseToken(lltok::lparen, "expected '(' after constantexpr cast") ||
-        ParseGlobalTypeAndValue(SrcVal) ||
-        ParseToken(lltok::kw_to, "expected 'to' in constantexpr cast") ||
-        ParseType(DestTy) ||
-        ParseToken(lltok::rparen, "expected ')' at end of constantexpr cast"))
+    if (parseToken(lltok::lparen, "expected '(' after constantexpr cast") ||
+        parseGlobalTypeAndValue(SrcVal) ||
+        parseToken(lltok::kw_to, "expected 'to' in constantexpr cast") ||
+        parseType(DestTy) ||
+        parseToken(lltok::rparen, "expected ')' at end of constantexpr cast"))
       return true;
     if (!CastInst::castIsValid((Instruction::CastOps)Opc, SrcVal, DestTy))
-      return Error(ID.Loc, "invalid cast opcode for cast from '" +
-                   getTypeString(SrcVal->getType()) + "' to '" +
-                   getTypeString(DestTy) + "'");
+      return error(ID.Loc, "invalid cast opcode for cast from '" +
+                               getTypeString(SrcVal->getType()) + "' to '" +
+                               getTypeString(DestTy) + "'");
     ID.ConstantVal = ConstantExpr::getCast((Instruction::CastOps)Opc,
                                                  SrcVal, DestTy);
     ID.Kind = ValID::t_Constant;
@@ -3428,16 +3552,16 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     Lex.Lex();
     Constant *Val;
     SmallVector<unsigned, 4> Indices;
-    if (ParseToken(lltok::lparen, "expected '(' in extractvalue constantexpr")||
-        ParseGlobalTypeAndValue(Val) ||
-        ParseIndexList(Indices) ||
-        ParseToken(lltok::rparen, "expected ')' in extractvalue constantexpr"))
+    if (parseToken(lltok::lparen,
+                   "expected '(' in extractvalue constantexpr") ||
+        parseGlobalTypeAndValue(Val) || parseIndexList(Indices) ||
+        parseToken(lltok::rparen, "expected ')' in extractvalue constantexpr"))
       return true;
 
     if (!Val->getType()->isAggregateType())
-      return Error(ID.Loc, "extractvalue operand must be aggregate type");
+      return error(ID.Loc, "extractvalue operand must be aggregate type");
     if (!ExtractValueInst::getIndexedType(Val->getType(), Indices))
-      return Error(ID.Loc, "invalid indices for extractvalue");
+      return error(ID.Loc, "invalid indices for extractvalue");
     ID.ConstantVal = ConstantExpr::getExtractValue(Val, Indices);
     ID.Kind = ValID::t_Constant;
     return false;
@@ -3446,21 +3570,21 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     Lex.Lex();
     Constant *Val0, *Val1;
     SmallVector<unsigned, 4> Indices;
-    if (ParseToken(lltok::lparen, "expected '(' in insertvalue constantexpr")||
-        ParseGlobalTypeAndValue(Val0) ||
-        ParseToken(lltok::comma, "expected comma in insertvalue constantexpr")||
-        ParseGlobalTypeAndValue(Val1) ||
-        ParseIndexList(Indices) ||
-        ParseToken(lltok::rparen, "expected ')' in insertvalue constantexpr"))
+    if (parseToken(lltok::lparen, "expected '(' in insertvalue constantexpr") ||
+        parseGlobalTypeAndValue(Val0) ||
+        parseToken(lltok::comma,
+                   "expected comma in insertvalue constantexpr") ||
+        parseGlobalTypeAndValue(Val1) || parseIndexList(Indices) ||
+        parseToken(lltok::rparen, "expected ')' in insertvalue constantexpr"))
       return true;
     if (!Val0->getType()->isAggregateType())
-      return Error(ID.Loc, "insertvalue operand must be aggregate type");
+      return error(ID.Loc, "insertvalue operand must be aggregate type");
     Type *IndexedType =
         ExtractValueInst::getIndexedType(Val0->getType(), Indices);
     if (!IndexedType)
-      return Error(ID.Loc, "invalid indices for insertvalue");
+      return error(ID.Loc, "invalid indices for insertvalue");
     if (IndexedType != Val1->getType())
-      return Error(ID.Loc, "insertvalue operand and field disagree in type: '" +
+      return error(ID.Loc, "insertvalue operand and field disagree in type: '" +
                                getTypeString(Val1->getType()) +
                                "' instead of '" + getTypeString(IndexedType) +
                                "'");
@@ -3473,28 +3597,28 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     unsigned PredVal, Opc = Lex.getUIntVal();
     Constant *Val0, *Val1;
     Lex.Lex();
-    if (ParseCmpPredicate(PredVal, Opc) ||
-        ParseToken(lltok::lparen, "expected '(' in compare constantexpr") ||
-        ParseGlobalTypeAndValue(Val0) ||
-        ParseToken(lltok::comma, "expected comma in compare constantexpr") ||
-        ParseGlobalTypeAndValue(Val1) ||
-        ParseToken(lltok::rparen, "expected ')' in compare constantexpr"))
+    if (parseCmpPredicate(PredVal, Opc) ||
+        parseToken(lltok::lparen, "expected '(' in compare constantexpr") ||
+        parseGlobalTypeAndValue(Val0) ||
+        parseToken(lltok::comma, "expected comma in compare constantexpr") ||
+        parseGlobalTypeAndValue(Val1) ||
+        parseToken(lltok::rparen, "expected ')' in compare constantexpr"))
       return true;
 
     if (Val0->getType() != Val1->getType())
-      return Error(ID.Loc, "compare operands must have the same type");
+      return error(ID.Loc, "compare operands must have the same type");
 
     CmpInst::Predicate Pred = (CmpInst::Predicate)PredVal;
 
     if (Opc == Instruction::FCmp) {
       if (!Val0->getType()->isFPOrFPVectorTy())
-        return Error(ID.Loc, "fcmp requires floating point operands");
+        return error(ID.Loc, "fcmp requires floating point operands");
       ID.ConstantVal = ConstantExpr::getFCmp(Pred, Val0, Val1);
     } else {
       assert(Opc == Instruction::ICmp && "Unexpected opcode for CmpInst!");
       if (!Val0->getType()->isIntOrIntVectorTy() &&
           !Val0->getType()->isPtrOrPtrVectorTy())
-        return Error(ID.Loc, "icmp requires pointer or integer operands");
+        return error(ID.Loc, "icmp requires pointer or integer operands");
       ID.ConstantVal = ConstantExpr::getICmp(Pred, Val0, Val1);
     }
     ID.Kind = ValID::t_Constant;
@@ -3506,16 +3630,16 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     unsigned Opc = Lex.getUIntVal();
     Constant *Val;
     Lex.Lex();
-    if (ParseToken(lltok::lparen, "expected '(' in unary constantexpr") ||
-        ParseGlobalTypeAndValue(Val) ||
-        ParseToken(lltok::rparen, "expected ')' in unary constantexpr"))
+    if (parseToken(lltok::lparen, "expected '(' in unary constantexpr") ||
+        parseGlobalTypeAndValue(Val) ||
+        parseToken(lltok::rparen, "expected ')' in unary constantexpr"))
       return true;
 
     // Check that the type is valid for the operator.
     switch (Opc) {
     case Instruction::FNeg:
       if (!Val->getType()->isFPOrFPVectorTy())
-        return Error(ID.Loc, "constexpr requires fp operands");
+        return error(ID.Loc, "constexpr requires fp operands");
       break;
     default: llvm_unreachable("Unknown unary operator!");
     }
@@ -3561,14 +3685,14 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
       if (EatIfPresent(lltok::kw_exact))
         Exact = true;
     }
-    if (ParseToken(lltok::lparen, "expected '(' in binary constantexpr") ||
-        ParseGlobalTypeAndValue(Val0) ||
-        ParseToken(lltok::comma, "expected comma in binary constantexpr") ||
-        ParseGlobalTypeAndValue(Val1) ||
-        ParseToken(lltok::rparen, "expected ')' in binary constantexpr"))
+    if (parseToken(lltok::lparen, "expected '(' in binary constantexpr") ||
+        parseGlobalTypeAndValue(Val0) ||
+        parseToken(lltok::comma, "expected comma in binary constantexpr") ||
+        parseGlobalTypeAndValue(Val1) ||
+        parseToken(lltok::rparen, "expected ')' in binary constantexpr"))
       return true;
     if (Val0->getType() != Val1->getType())
-      return Error(ID.Loc, "operands of constexpr must have same type");
+      return error(ID.Loc, "operands of constexpr must have same type");
     // Check that the type is valid for the operator.
     switch (Opc) {
     case Instruction::Add:
@@ -3582,7 +3706,7 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     case Instruction::AShr:
     case Instruction::LShr:
       if (!Val0->getType()->isIntOrIntVectorTy())
-        return Error(ID.Loc, "constexpr requires integer operands");
+        return error(ID.Loc, "constexpr requires integer operands");
       break;
     case Instruction::FAdd:
     case Instruction::FSub:
@@ -3590,7 +3714,7 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     case Instruction::FDiv:
     case Instruction::FRem:
       if (!Val0->getType()->isFPOrFPVectorTy())
-        return Error(ID.Loc, "constexpr requires fp operands");
+        return error(ID.Loc, "constexpr requires fp operands");
       break;
     default: llvm_unreachable("Unknown binary operator!");
     }
@@ -3611,16 +3735,16 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     unsigned Opc = Lex.getUIntVal();
     Constant *Val0, *Val1;
     Lex.Lex();
-    if (ParseToken(lltok::lparen, "expected '(' in logical constantexpr") ||
-        ParseGlobalTypeAndValue(Val0) ||
-        ParseToken(lltok::comma, "expected comma in logical constantexpr") ||
-        ParseGlobalTypeAndValue(Val1) ||
-        ParseToken(lltok::rparen, "expected ')' in logical constantexpr"))
+    if (parseToken(lltok::lparen, "expected '(' in logical constantexpr") ||
+        parseGlobalTypeAndValue(Val0) ||
+        parseToken(lltok::comma, "expected comma in logical constantexpr") ||
+        parseGlobalTypeAndValue(Val1) ||
+        parseToken(lltok::rparen, "expected ')' in logical constantexpr"))
       return true;
     if (Val0->getType() != Val1->getType())
-      return Error(ID.Loc, "operands of constexpr must have same type");
+      return error(ID.Loc, "operands of constexpr must have same type");
     if (!Val0->getType()->isIntOrIntVectorTy())
-      return Error(ID.Loc,
+      return error(ID.Loc,
                    "constexpr requires integer or integer vector operands");
     ID.ConstantVal = ConstantExpr::get(Opc, Val0, Val1);
     ID.Kind = ValID::t_Constant;
@@ -3641,31 +3765,31 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     if (Opc == Instruction::GetElementPtr)
       InBounds = EatIfPresent(lltok::kw_inbounds);
 
-    if (ParseToken(lltok::lparen, "expected '(' in constantexpr"))
+    if (parseToken(lltok::lparen, "expected '(' in constantexpr"))
       return true;
 
     LocTy ExplicitTypeLoc = Lex.getLoc();
     if (Opc == Instruction::GetElementPtr) {
-      if (ParseType(Ty) ||
-          ParseToken(lltok::comma, "expected comma after getelementptr's type"))
+      if (parseType(Ty) ||
+          parseToken(lltok::comma, "expected comma after getelementptr's type"))
         return true;
     }
 
     Optional<unsigned> InRangeOp;
-    if (ParseGlobalValueVector(
+    if (parseGlobalValueVector(
             Elts, Opc == Instruction::GetElementPtr ? &InRangeOp : nullptr) ||
-        ParseToken(lltok::rparen, "expected ')' in constantexpr"))
+        parseToken(lltok::rparen, "expected ')' in constantexpr"))
       return true;
 
     if (Opc == Instruction::GetElementPtr) {
       if (Elts.size() == 0 ||
           !Elts[0]->getType()->isPtrOrPtrVectorTy())
-        return Error(ID.Loc, "base of getelementptr must be a pointer");
+        return error(ID.Loc, "base of getelementptr must be a pointer");
 
       Type *BaseType = Elts[0]->getType();
       auto *BasePointerType = cast<PointerType>(BaseType->getScalarType());
       if (Ty != BasePointerType->getElementType())
-        return Error(
+        return error(
             ExplicitTypeLoc,
             "explicit pointee type doesn't match operand's pointee type");
@@ -4063,25 +4186,25 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, LineField &Result) {
-  return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, LineField &Result) {
+  return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 }
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, ColumnField &Result) {
-  return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, ColumnField &Result) {
+  return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DwarfTagField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, DwarfTagField &Result) {
   if (Lex.getKind() == lltok::APSInt)
-    return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 
   if (Lex.getKind() != lltok::DwarfTag)
-    return TokError("expected DWARF tag");
+    return tokError("expected DWARF tag");
 
   unsigned Tag = dwarf::getTag(Lex.getStrVal());
   if (Tag == dwarf::DW_TAG_invalid)
-    return TokError("invalid DWARF tag" + Twine(" '") + Lex.getStrVal() + "'");
+    return tokError("invalid DWARF tag" + Twine(" '") + Lex.getStrVal() + "'");
   assert(Tag <= Result.Max && "Expected valid DWARF tag");
 
   Result.assign(Tag);
@@ -4183,17 +4307,17 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name, EmissionKindField &Result
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
+bool LLParser::parseMDField(LocTy Loc, StringRef Name,
                             NameTableKindField &Result) {
   if (Lex.getKind() == lltok::APSInt)
-    return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 
   if (Lex.getKind() != lltok::NameTableKind)
-    return TokError("expected nameTable kind");
+    return tokError("expected nameTable kind");
 
   auto Kind = DICompileUnit::getNameTableKind(Lex.getStrVal());
   if (!Kind)
-    return TokError("invalid nameTable kind" + Twine(" '") + Lex.getStrVal() +
+    return tokError("invalid nameTable kind" + Twine(" '") + Lex.getStrVal() +
                     "'");
   assert(((unsigned)*Kind) <= Result.Max && "Expected valid nameTable kind");
   Result.assign((unsigned)*Kind);
@@ -4202,17 +4326,17 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
+bool LLParser::parseMDField(LocTy Loc, StringRef Name,
                             DwarfAttEncodingField &Result) {
   if (Lex.getKind() == lltok::APSInt)
-    return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 
   if (Lex.getKind() != lltok::DwarfAttEncoding)
-    return TokError("expected DWARF type attribute encoding");
+    return tokError("expected DWARF type attribute encoding");
 
   unsigned Encoding = dwarf::getAttributeEncoding(Lex.getStrVal());
   if (!Encoding)
-    return TokError("invalid DWARF type attribute encoding" + Twine(" '") +
+    return tokError("invalid DWARF type attribute encoding" + Twine(" '") +
                     Lex.getStrVal() + "'");
   assert(Encoding <= Result.Max && "Expected valid DWARF language");
   Result.assign(Encoding);
@@ -4225,29 +4349,29 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 ///  ::= DIFlagVector
 ///  ::= DIFlagVector '|' DIFlagFwdDecl '|' uint32 '|' DIFlagPublic
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DIFlagField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, DIFlagField &Result) {
 
-  // Parser for a single flag.
+  // parser for a single flag.
   auto parseFlag = [&](DINode::DIFlags &Val) {
     if (Lex.getKind() == lltok::APSInt && !Lex.getAPSIntVal().isSigned()) {
       uint32_t TempVal = static_cast<uint32_t>(Val);
-      bool Res = ParseUInt32(TempVal);
+      bool Res = parseUInt32(TempVal);
       Val = static_cast<DINode::DIFlags>(TempVal);
       return Res;
     }
 
     if (Lex.getKind() != lltok::DIFlag)
-      return TokError("expected debug info flag");
+      return tokError("expected debug info flag");
 
     Val = DINode::getFlag(Lex.getStrVal());
     if (!Val)
-      return TokError(Twine("invalid debug info flag flag '") +
+      return tokError(Twine("invalid debug info flag flag '") +
                       Lex.getStrVal() + "'");
     Lex.Lex();
     return false;
   };
 
-  // Parse the flags and combine them together.
+  // parse the flags and combine them together.
   DINode::DIFlags Combined = DINode::FlagZero;
   do {
     DINode::DIFlags Val;
@@ -4432,67 +4555,70 @@ bool LLParser::ParseMDFieldsImplBody(ParserTy parseField) {
 }
 
 template <class ParserTy>
-bool LLParser::ParseMDFieldsImpl(ParserTy parseField, LocTy &ClosingLoc) {
+bool LLParser::parseMDFieldsImpl(ParserTy ParseField, LocTy &ClosingLoc) {
   assert(Lex.getKind() == lltok::MetadataVar && "Expected metadata type name");
   Lex.Lex();
 
-  if (ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::lparen, "expected '(' here"))
     return true;
   if (Lex.getKind() != lltok::rparen)
-    if (ParseMDFieldsImplBody(parseField))
+    if (parseMDFieldsImplBody(ParseField))
       return true;
 
   ClosingLoc = Lex.getLoc();
-  return ParseToken(lltok::rparen, "expected ')' here");
+  return parseToken(lltok::rparen, "expected ')' here");
 }
 
 template <class FieldTy>
-bool LLParser::ParseMDField(StringRef Name, FieldTy &Result) {
+bool LLParser::parseMDField(StringRef Name, FieldTy &Result) {
   if (Result.Seen)
-    return TokError("field '" + Name + "' cannot be specified more than once");
+    return tokError("field '" + Name + "' cannot be specified more than once");
 
   LocTy Loc = Lex.getLoc();
   Lex.Lex();
-  return ParseMDField(Loc, Name, Result);
+  return parseMDField(Loc, Name, Result);
 }
 
-bool LLParser::ParseSpecializedMDNode(MDNode *&N, bool IsDistinct) {
+bool LLParser::parseSpecializedMDNode(MDNode *&N, bool IsDistinct) {
   assert(Lex.getKind() == lltok::MetadataVar && "Expected metadata type name");
 
 #define HANDLE_SPECIALIZED_MDNODE_LEAF(CLASS)                                  \
   if (Lex.getStrVal() == #CLASS)                                               \
-    return Parse##CLASS(N, IsDistinct);
+    return parse##CLASS(N, IsDistinct);
 #include "llvm/IR/Metadata.def"
 
-  return TokError("expected metadata type");
+  return tokError("expected metadata type");
 }
 
 #define DECLARE_FIELD(NAME, TYPE, INIT) TYPE NAME INIT
 #define NOP_FIELD(NAME, TYPE, INIT)
 #define REQUIRE_FIELD(NAME, TYPE, INIT)                                        \
   if (!NAME.Seen)                                                              \
-    return Error(ClosingLoc, "missing required field '" #NAME "'");
+    return error(ClosingLoc, "missing required field '" #NAME "'");
 #define PARSE_MD_FIELD(NAME, TYPE, DEFAULT)                                    \
   if (Lex.getStrVal() == #NAME)                                                \
-    return ParseMDField(#NAME, NAME);
+    return parseMDField(#NAME, NAME);
 #define PARSE_MD_FIELDS()                                                      \
   VISIT_MD_FIELDS(DECLARE_FIELD, DECLARE_FIELD)                                \
   do {                                                                         \
     LocTy ClosingLoc;                                                          \
-    if (ParseMDFieldsImpl([&]() -> bool {                                      \
-      VISIT_MD_FIELDS(PARSE_MD_FIELD, PARSE_MD_FIELD)                          \
-      return TokError(Twine("invalid field '") + Lex.getStrVal() + "'");       \
-    }, ClosingLoc))                                                            \
+    if (parseMDFieldsImpl(                                                     \
+            [&]() -> bool {                                                    \
+              VISIT_MD_FIELDS(PARSE_MD_FIELD, PARSE_MD_FIELD)                  \
+              return tokError(Twine("invalid field '") + Lex.getStrVal() +     \
+                              "'");                                            \
+            },                                                                 \
+            ClosingLoc))                                                       \
       return true;                                                             \
     VISIT_MD_FIELDS(NOP_FIELD, REQUIRE_FIELD)                                  \
   } while (false)
 #define GET_OR_DISTINCT(CLASS, ARGS)                                           \
   (IsDistinct ? CLASS::getDistinct ARGS : CLASS::get ARGS)
@@ -4565,9 +4691,42 @@ bool LLParser::ParseDISubrange(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIEnumerator:
+/// parseDIGenericSubrange:
+///   ::= !DIGenericSubrange(lowerBound: !node1, upperBound: !node2, stride:
+///   !node3)
+bool LLParser::parseDIGenericSubrange(MDNode *&Result, bool IsDistinct) {
+#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
+  OPTIONAL(count, MDSignedOrMDField, );                                        \
+  OPTIONAL(lowerBound, MDSignedOrMDField, );                                   \
+  OPTIONAL(upperBound, MDSignedOrMDField, );                                   \
+  OPTIONAL(stride, MDSignedOrMDField, );
+  PARSE_MD_FIELDS();
+#undef VISIT_MD_FIELDS
+
+  auto ConvToMetadata = [&](MDSignedOrMDField Bound) -> Metadata * {
+    if (Bound.isMDSignedField())
+      return DIExpression::get(
+          Context, {dwarf::DW_OP_consts,
+                    static_cast<uint64_t>(Bound.getMDSignedValue())});
+    if (Bound.isMDField())
+      return Bound.getMDFieldValue();
+    return nullptr;
+  };
+
+  Metadata *Count = ConvToMetadata(count);
+  Metadata *LowerBound = ConvToMetadata(lowerBound);
+  Metadata *UpperBound = ConvToMetadata(upperBound);
+  Metadata *Stride = ConvToMetadata(stride);
+
+  Result = GET_OR_DISTINCT(DIGenericSubrange,
+                           (Context, Count, LowerBound, UpperBound, Stride));
+
+  return false;
+}
@@ -4609,12 +4768,33 @@ bool LLParser::ParseDIBasicType(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIDerivedType:
+/// parseDIStringType:
+///   ::= !DIStringType(name: "character(4)", size: 32, align: 32)
+bool LLParser::parseDIStringType(MDNode *&Result, bool IsDistinct) {
+#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
+  OPTIONAL(tag, DwarfTagField, (dwarf::DW_TAG_string_type));                   \
+  OPTIONAL(name, MDStringField, );                                             \
+  OPTIONAL(stringLength, MDField, );                                           \
+  OPTIONAL(stringLengthExpression, MDField, );                                 \
+  OPTIONAL(size, MDUnsignedField, (0, UINT64_MAX));                            \
+  OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));                           \
+  OPTIONAL(encoding, DwarfAttEncodingField, );
+  PARSE_MD_FIELDS();
+#undef VISIT_MD_FIELDS
+
+  Result = GET_OR_DISTINCT(DIStringType,
+                           (Context, tag.Val, name.Val, stringLength.Val,
+                            stringLengthExpression.Val, size.Val, align.Val,
+                            encoding.Val));
+  return false;
+}
+
+/// parseDIDerivedType:
 ///   ::= !DIDerivedType(tag: DW_TAG_pointer_type, name: "int", file: !0,
 ///                      line: 7, scope: !1, baseType: !2, size: 32,
 ///                      align: 32, offset: 0, flags: 0, extraData: !3,
 ///                      dwarfAddressSpace: 3)
-bool LLParser::ParseDIDerivedType(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDIDerivedType(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(tag, DwarfTagField, );                                              \
   OPTIONAL(name, MDStringField, );                                             \
@@ -4661,17 +4841,28 @@ bool LLParser::ParseDICompositeType(MDNode *&Result, bool IsDistinct) {
   OPTIONAL(templateParams, MDField, );                                         \
   OPTIONAL(identifier, MDStringField, );                                       \
   OPTIONAL(discriminator, MDField, );                                          \
-  OPTIONAL(dataLocation, MDField, );
+  OPTIONAL(dataLocation, MDField, );                                           \
+  OPTIONAL(associated, MDField, );                                             \
+  OPTIONAL(allocated, MDField, );                                              \
+  OPTIONAL(rank, MDSignedOrMDField, );
   PARSE_MD_FIELDS();
 #undef VISIT_MD_FIELDS
 
+  Metadata *Rank = nullptr;
+  if (rank.isMDSignedField())
+    Rank = ConstantAsMetadata::get(ConstantInt::getSigned(
+        Type::getInt64Ty(Context), rank.getMDSignedValue()));
+  else if (rank.isMDField())
+    Rank = rank.getMDFieldValue();
+
   // If this has an identifier try to build an ODR type.
   if (identifier.Val)
     if (auto *CT = DICompositeType::buildODRType(
             Context, *identifier.Val, tag.Val, name.Val, file.Val, line.Val,
             scope.Val, baseType.Val, size.Val, align.Val, offset.Val, flags.Val,
             elements.Val, runtimeLang.Val, vtableHolder.Val, templateParams.Val,
-            discriminator.Val, dataLocation.Val)) {
+            discriminator.Val, dataLocation.Val, associated.Val, allocated.Val,
+            Rank)) {
       Result = CT;
       return false;
     }
@@ -4683,11 +4874,12 @@ bool LLParser::ParseDICompositeType(MDNode *&Result, bool IsDistinct) {
       (Context, tag.Val, name.Val, file.Val, line.Val, scope.Val, baseType.Val,
        size.Val, align.Val, offset.Val, flags.Val, elements.Val,
        runtimeLang.Val, vtableHolder.Val, templateParams.Val, identifier.Val,
-       discriminator.Val, dataLocation.Val));
+       discriminator.Val, dataLocation.Val, associated.Val, allocated.Val,
+       Rank));
   return false;
 }
 
-bool LLParser::ParseDISubroutineType(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDISubroutineType(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   OPTIONAL(flags, DIFlagField, );                                              \
   OPTIONAL(cc, DwarfCCField, );                                                \
@@ -4926,11 +5119,11 @@ bool LLParser::ParseDIMacroFile(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIModule:
+/// parseDIModule:
 ///   ::= !DIModule(scope: !0, name: "SomeModule", configMacros:
 ///   "-DNDEBUG", includePath: "/usr/include", apinotes: "module.apinotes",
-///   file: !1, line: 4)
-bool LLParser::ParseDIModule(MDNode *&Result, bool IsDistinct) {
+///   file: !1, line: 4, isDecl: false)
+bool LLParser::parseDIModule(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(scope, MDField, );                                                  \
   REQUIRED(name, MDStringField, );                                             \
@@ -4938,19 +5131,20 @@ bool LLParser::ParseDIModule(MDNode *&Result, bool IsDistinct) {
   OPTIONAL(includePath, MDStringField, );                                      \
   OPTIONAL(apinotes, MDStringField, );                                         \
   OPTIONAL(file, MDField, );                                                   \
-  OPTIONAL(line, LineField, );
+  OPTIONAL(line, LineField, );                                                 \
+  OPTIONAL(isDecl, MDBoolField, );
   PARSE_MD_FIELDS();
 #undef VISIT_MD_FIELDS
 
   Result = GET_OR_DISTINCT(DIModule, (Context, file.Val, scope.Val, name.Val,
                                       configMacros.Val, includePath.Val,
-                                      apinotes.Val, line.Val));
+                                      apinotes.Val, line.Val, isDecl.Val));
   return false;
 }
@@ -5303,66 +5502,81 @@ bool LLParser::ConvertValIDToValue(Type *Ty, ValID &ID, Value *&V,
       else if (Ty->isFloatTy())
         ID.APFloatVal.convert(APFloat::IEEEsingle(), APFloat::rmNearestTiesToEven,
                               &Ignored);
+      if (IsSNAN) {
+        // The convert call above may quiet an SNaN, so manufacture another
+        // SNaN. The bitcast works because the payload (significand) parameter
+        // is truncated to fit.
+        APInt Payload = ID.APFloatVal.bitcastToAPInt();
+        ID.APFloatVal = APFloat::getSNaN(ID.APFloatVal.getSemantics(),
+                                         ID.APFloatVal.isNegative(), &Payload);
+      }
     }
     V = ConstantFP::get(Context, ID.APFloatVal);
+  case ValID::t_Poison:
+    // FIXME: LabelTy should not be a first-class type.
+    if (!Ty->isFirstClassType() || Ty->isLabelTy())
+      return error(ID.Loc, "invalid type for poison constant");
+    V = PoisonValue::get(Ty);
+    return false;
   case ValID::t_Constant:
@@ -6890,7 +7148,7 @@ bool LLParser::ParseFreeze(Instruction *&Inst, PerFunctionState &PFS) {
 ///           OptionalAttrs Type Value ParameterList OptionalAttrs
 ///   ::= 'notail' 'call'  OptionalFastMathFlags OptionalCallingConv
 ///           OptionalAttrs Type Value ParameterList OptionalAttrs
-bool LLParser::ParseCall(Instruction *&Inst, PerFunctionState &PFS,
+bool LLParser::parseCall(Instruction *&Inst, PerFunctionState &PFS,
                          CallInst::TailCallKind TCK) {
   AttrBuilder RetAttrs, FnAttrs;
   std::vector<unsigned> FwdRefAttrGrps;
@@ -6905,20 +7163,20 @@ bool LLParser::ParseCall(Instruction *&Inst, PerFunctionState &PFS,
   LocTy CallLoc = Lex.getLoc();
 
   if (TCK != CallInst::TCK_None &&
-      ParseToken(lltok::kw_call,
+      parseToken(lltok::kw_call,
                  "expected 'tail call', 'musttail call', or 'notail call'"))
     return true;
 
   FastMathFlags FMF = EatFastMathFlagsIfPresent();
 
-  if (ParseOptionalCallingConv(CC) || ParseOptionalReturnAttrs(RetAttrs) ||
-      ParseOptionalProgramAddrSpace(CallAddrSpace) ||
-      ParseType(RetType, RetTypeLoc, true /*void allowed*/) ||
-      ParseValID(CalleeID) ||
-      ParseParameterList(ArgList, PFS, TCK == CallInst::TCK_MustTail,
+  if (parseOptionalCallingConv(CC) || parseOptionalReturnAttrs(RetAttrs) ||
+      parseOptionalProgramAddrSpace(CallAddrSpace) ||
+      parseType(RetType, RetTypeLoc, true /*void allowed*/) ||
+      parseValID(CalleeID) ||
+      parseParameterList(ArgList, PFS, TCK == CallInst::TCK_MustTail,
                          PFS.getFunction().isVarArg()) ||
-      ParseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false, BuiltinLoc) ||
-      ParseOptionalOperandBundles(BundleList, PFS))
+      parseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false, BuiltinLoc) ||
+      parseOptionalOperandBundles(BundleList, PFS))
     return true;
 
   // If RetType is a non-function pointer type, then this is the short syntax
@@ -7364,22 +7624,24 @@ int LLParser::ParseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS) {
   // All vector parameters should have the same vector width.
   ElementCount GEPWidth = BaseType->isVectorTy()
                               ? cast<VectorType>(BaseType)->getElementCount()
-                              : ElementCount(0, false);
+                              : ElementCount::getFixed(0);
 
   while (EatIfPresent(lltok::comma)) {
     if (Lex.getKind() == lltok::MetadataVar) {
       AteExtraComma = true;
       break;
     }
-    if (ParseTypeAndValue(Val, EltLoc, PFS)) return true;
+    if (parseTypeAndValue(Val, EltLoc, PFS))
+      return true;
     if (!Val->getType()->isIntOrIntVectorTy())
-      return Error(EltLoc, "getelementptr index must be an integer");
+      return error(EltLoc, "getelementptr index must be an integer");
 
     if (auto *ValVTy = dyn_cast<VectorType>(Val->getType())) {
       ElementCount ValNumEl = ValVTy->getElementCount();
-      if (GEPWidth != ElementCount(0, false) && GEPWidth != ValNumEl)
-        return Error(EltLoc,
-          "getelementptr vector index has a wrong number of elements");
+      if (GEPWidth != ElementCount::getFixed(0) && GEPWidth != ValNumEl)
+        return error(
+            EltLoc,
+            "getelementptr vector index has a wrong number of elements");
       GEPWidth = ValNumEl;
     }
     Indices.push_back(Val);
@@ -7387,55 +7649,55 @@ int LLParser::ParseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS) {
-/// ParseExtractValue
+/// parseExtractValue
 ///   ::= 'extractvalue' TypeAndValue (',' uint32)+
-int LLParser::ParseExtractValue(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parseExtractValue(Instruction *&Inst, PerFunctionState &PFS) {
   Value *Val; LocTy Loc;
   SmallVector<unsigned, 4> Indices;
   bool AteExtraComma;
-  if (ParseTypeAndValue(Val, Loc, PFS) ||
-      ParseIndexList(Indices, AteExtraComma))
+  if (parseTypeAndValue(Val, Loc, PFS) ||
+      parseIndexList(Indices, AteExtraComma))
     return true;
 
   if (!Val->getType()->isAggregateType())
-    return Error(Loc, "extractvalue operand must be aggregate type");
+    return error(Loc, "extractvalue operand must be aggregate type");
 
   if (!ExtractValueInst::getIndexedType(Val->getType(), Indices))
-    return Error(Loc, "invalid indices for extractvalue");
+    return error(Loc, "invalid indices for extractvalue");
   Inst = ExtractValueInst::Create(Val, Indices);
   return AteExtraComma ? InstExtraComma : InstNormal;
 }
 
-/// ParseInsertValue
+/// parseInsertValue
 ///   ::= 'insertvalue' TypeAndValue ',' TypeAndValue (',' uint32)+
-int LLParser::ParseInsertValue(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parseInsertValue(Instruction *&Inst, PerFunctionState &PFS) {
   Value *Val0, *Val1; LocTy Loc0, Loc1;
   SmallVector<unsigned, 4> Indices;
   bool AteExtraComma;
-  if (ParseTypeAndValue(Val0, Loc0, PFS) ||
-      ParseToken(lltok::comma, "expected comma after insertvalue operand") ||
-      ParseTypeAndValue(Val1, Loc1, PFS) ||
-      ParseIndexList(Indices, AteExtraComma))
+  if (parseTypeAndValue(Val0, Loc0, PFS) ||
+      parseToken(lltok::comma, "expected comma after insertvalue operand") ||
+      parseTypeAndValue(Val1, Loc1, PFS) ||
+      parseIndexList(Indices, AteExtraComma))
     return true;
 
   if (!Val0->getType()->isAggregateType())
-    return Error(Loc0, "insertvalue operand must be aggregate type");
+    return error(Loc0, "insertvalue operand must be aggregate type");
 
   Type *IndexedType = ExtractValueInst::getIndexedType(Val0->getType(), Indices);
   if (!IndexedType)
-    return Error(Loc0, "invalid indices for insertvalue");
+    return error(Loc0, "invalid indices for insertvalue");
   if (IndexedType != Val1->getType())
-    return Error(Loc1, "insertvalue operand and field disagree in type: '" +
+    return error(Loc1, "insertvalue operand and field disagree in type: '" +
                            getTypeString(Val1->getType()) + "' instead of '" +
                            getTypeString(IndexedType) + "'");
   Inst = InsertValueInst::Create(Val0, Val1, Indices);
@@ -7501,11 +7763,11 @@ bool LLParser::sortUseListOrder(Value *V, ArrayRef<unsigned> Indexes,
   return false;
 }
 
-/// ParseUseListOrderIndexes
+/// parseUseListOrderIndexes
 ///   ::= '{' uint32 (',' uint32)+ '}'
-bool LLParser::ParseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes) {
+bool LLParser::parseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes) {
   SMLoc Loc = Lex.getLoc();
-  if (ParseToken(lltok::lbrace, "expected '{' here"))
+  if (parseToken(lltok::lbrace, "expected '{' here"))
     return true;
   if (Lex.getKind() == lltok::rbrace)
     return Lex.Error("expected non-empty list of uselistorder indexes");
@@ -7519,7 +7781,7 @@ bool LLParser::ParseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes) {
   assert(Indexes.empty() && "Expected empty order vector");
   do {
     unsigned Index;
-    if (ParseUInt32(Index))
+    if (parseUInt32(Index))
       return true;
 
     // Update consistency checks.
@@ -7530,50 +7792,51 @@ bool LLParser::ParseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes) {
     Indexes.push_back(Index);
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rbrace, "expected '}' here"))
+  if (parseToken(lltok::rbrace, "expected '}' here"))
     return true;
 
   if (Indexes.size() < 2)
-    return Error(Loc, "expected >= 2 uselistorder indexes");
+    return error(Loc, "expected >= 2 uselistorder indexes");
   if (Offset != 0 || Max >= Indexes.size())
-    return Error(Loc, "expected distinct uselistorder indexes in range [0, size)");
+    return error(Loc,
+                 "expected distinct uselistorder indexes in range [0, size)");
   if (IsOrdered)
-    return Error(Loc, "expected uselistorder indexes to change the order");
+    return error(Loc, "expected uselistorder indexes to change the order");
 
   return false;
 }
 
-/// ParseUseListOrder
+/// parseUseListOrder
 ///   ::= 'uselistorder' Type Value ',' UseListOrderIndexes
-bool LLParser::ParseUseListOrder(PerFunctionState *PFS) {
+bool LLParser::parseUseListOrder(PerFunctionState *PFS) {
   SMLoc Loc = Lex.getLoc();
-  if (ParseToken(lltok::kw_uselistorder, "expected uselistorder directive"))
+  if (parseToken(lltok::kw_uselistorder, "expected uselistorder directive"))
     return true;
 
   Value *V;
   SmallVector<unsigned, 16> Indexes;
-  if (ParseTypeAndValue(V, PFS) ||
-      ParseToken(lltok::comma, "expected comma in uselistorder directive") ||
-      ParseUseListOrderIndexes(Indexes))
+  if (parseTypeAndValue(V, PFS) ||
+      parseToken(lltok::comma, "expected comma in uselistorder directive") ||
+      parseUseListOrderIndexes(Indexes))
     return true;
 
   return sortUseListOrder(V, Indexes, Loc);
 }
 
-/// ParseUseListOrderBB
+/// parseUseListOrderBB
 ///   ::= 'uselistorder_bb' @foo ',' %bar ',' UseListOrderIndexes
-bool LLParser::ParseUseListOrderBB() {
+bool LLParser::parseUseListOrderBB() {
   assert(Lex.getKind() == lltok::kw_uselistorder_bb);
   SMLoc Loc = Lex.getLoc();
   Lex.Lex();
 
   ValID Fn, Label;
   SmallVector<unsigned, 16> Indexes;
-  if (ParseValID(Fn) ||
-      ParseToken(lltok::comma, "expected comma in uselistorder_bb directive") ||
-      ParseValID(Label) ||
-      ParseToken(lltok::comma, "expected comma in uselistorder_bb directive") ||
-      ParseUseListOrderIndexes(Indexes))
+  if (parseValID(Fn) ||
+      parseToken(lltok::comma, "expected comma in uselistorder_bb directive") ||
+      parseValID(Label) ||
+      parseToken(lltok::comma, "expected comma in uselistorder_bb directive") ||
+      parseUseListOrderIndexes(Indexes))
     return true;
 
   // Check the function.
@@ -7583,25 +7846,26 @@ bool LLParser::ParseUseListOrderBB() {
   else if (Fn.Kind == ValID::t_GlobalID)
     GV = Fn.UIntVal < NumberedVals.size() ? NumberedVals[Fn.UIntVal] : nullptr;
   else
-    return Error(Fn.Loc, "expected function name in uselistorder_bb");
+    return error(Fn.Loc, "expected function name in uselistorder_bb");
   if (!GV)
-    return Error(Fn.Loc, "invalid function forward reference in uselistorder_bb");
+    return error(Fn.Loc,
+                 "invalid function forward reference in uselistorder_bb");
   auto *F = dyn_cast<Function>(GV);
   if (!F)
-    return Error(Fn.Loc, "expected function name in uselistorder_bb");
+    return error(Fn.Loc, "expected function name in uselistorder_bb");
   if (F->isDeclaration())
-    return Error(Fn.Loc, "invalid declaration in uselistorder_bb");
+    return error(Fn.Loc, "invalid declaration in uselistorder_bb");
 
   // Check the basic block.
   if (Label.Kind == ValID::t_LocalID)
-    return Error(Label.Loc, "invalid numeric label in uselistorder_bb");
+    return error(Label.Loc, "invalid numeric label in uselistorder_bb");
   if (Label.Kind != ValID::t_LocalName)
-    return Error(Label.Loc, "expected basic block name in uselistorder_bb");
+    return error(Label.Loc, "expected basic block name in uselistorder_bb");
   Value *V = F->getValueSymbolTable()->lookup(Label.StrVal);
   if (!V)
-    return Error(Label.Loc, "invalid basic block in uselistorder_bb");
+    return error(Label.Loc, "invalid basic block in uselistorder_bb");
   if (!isa<BasicBlock>(V))
-    return Error(Label.Loc, "expected basic block in uselistorder_bb");
+    return error(Label.Loc, "expected basic block in uselistorder_bb");
 
   return sortUseListOrder(V, Indexes, Loc);
 }
@@ -7609,32 +7873,32 @@ bool LLParser::ParseUseListOrderBB() {
 /// ModuleEntry
 ///   ::= 'module' ':' '(' 'path' ':' STRINGCONSTANT ',' 'hash' ':' Hash ')'
 /// Hash ::= '(' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ')'
-bool LLParser::ParseModuleEntry(unsigned ID) {
+bool LLParser::parseModuleEntry(unsigned ID) {
   assert(Lex.getKind() == lltok::kw_module);
   Lex.Lex();
 
   std::string Path;
-  if (ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseToken(lltok::kw_path, "expected 'path' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseStringConstant(Path) ||
-      ParseToken(lltok::comma, "expected ',' here") ||
-      ParseToken(lltok::kw_hash, "expected 'hash' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here") ||
+      parseToken(lltok::kw_path, "expected 'path' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseStringConstant(Path) ||
+      parseToken(lltok::comma, "expected ',' here") ||
+      parseToken(lltok::kw_hash, "expected 'hash' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   ModuleHash Hash;
-  if (ParseUInt32(Hash[0]) || ParseToken(lltok::comma, "expected ',' here") ||
-      ParseUInt32(Hash[1]) || ParseToken(lltok::comma, "expected ',' here") ||
-      ParseUInt32(Hash[2]) || ParseToken(lltok::comma, "expected ',' here") ||
-      ParseUInt32(Hash[3]) || ParseToken(lltok::comma, "expected ',' here") ||
-      ParseUInt32(Hash[4]))
+  if (parseUInt32(Hash[0]) || parseToken(lltok::comma, "expected ',' here") ||
+      parseUInt32(Hash[1]) || parseToken(lltok::comma, "expected ',' here") ||
+      parseUInt32(Hash[2]) || parseToken(lltok::comma, "expected ',' here") ||
+      parseUInt32(Hash[3]) || parseToken(lltok::comma, "expected ',' here") ||
+      parseUInt32(Hash[4]))
     return true;
 
-  if (ParseToken(lltok::rparen, "expected ')' here") ||
-      ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here") ||
+      parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   auto ModuleEntry = Index->addModule(Path, ID, Hash);
@@ -7645,21 +7909,21 @@ bool LLParser::ParseModuleEntry(unsigned ID) {
 
 /// TypeIdEntry
 ///   ::= 'typeid' ':' '(' 'name' ':' STRINGCONSTANT ',' TypeIdSummary ')'
-bool LLParser::ParseTypeIdEntry(unsigned ID) {
+bool LLParser::parseTypeIdEntry(unsigned ID) {
   assert(Lex.getKind() == lltok::kw_typeid);
   Lex.Lex();
 
   std::string Name;
-  if (ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseToken(lltok::kw_name, "expected 'name' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseStringConstant(Name))
+  if (parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here") ||
+      parseToken(lltok::kw_name, "expected 'name' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseStringConstant(Name))
     return true;
 
   TypeIdSummary &TIS = Index->getOrInsertTypeIdSummary(Name);
-  if (ParseToken(lltok::comma, "expected ',' here") ||
-      ParseTypeIdSummary(TIS) || ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::comma, "expected ',' here") ||
+      parseTypeIdSummary(TIS) || parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   // Check if this ID was forward referenced, and if so, update the
@@ -7679,20 +7943,20 @@ bool LLParser::ParseTypeIdEntry(unsigned ID) {
 
 /// TypeIdSummary
 ///   ::= 'summary' ':' '(' TypeTestResolution [',' OptionalWpdResolutions]? ')'
-bool LLParser::ParseTypeIdSummary(TypeIdSummary &TIS) {
-  if (ParseToken(lltok::kw_summary, "expected 'summary' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseTypeTestResolution(TIS.TTRes))
+bool LLParser::parseTypeIdSummary(TypeIdSummary &TIS) {
+  if (parseToken(lltok::kw_summary, "expected 'summary' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here") ||
+      parseTypeTestResolution(TIS.TTRes))
     return true;
 
   if (EatIfPresent(lltok::comma)) {
     // Expect optional wpdResolutions field
-    if (ParseOptionalWpdResolutions(TIS.WPDRes))
+    if (parseOptionalWpdResolutions(TIS.WPDRes))
       return true;
   }
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -7705,40 +7969,40 @@ static ValueInfo EmptyVI =
 ///   ::= 'typeidCompatibleVTable' ':' '(' 'name' ':' STRINGCONSTANT ','
 ///   TypeIdCompatibleVtableInfo
 ///   ')'
-bool LLParser::ParseTypeIdCompatibleVtableEntry(unsigned ID) {
+bool LLParser::parseTypeIdCompatibleVtableEntry(unsigned ID) {
   assert(Lex.getKind() == lltok::kw_typeidCompatibleVTable);
   Lex.Lex();
 
   std::string Name;
-  if (ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseToken(lltok::kw_name, "expected 'name' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseStringConstant(Name))
+  if (parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here") ||
+      parseToken(lltok::kw_name, "expected 'name' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseStringConstant(Name))
     return true;
 
   TypeIdCompatibleVtableInfo &TI =
       Index->getOrInsertTypeIdCompatibleVtableSummary(Name);
-  if (ParseToken(lltok::comma, "expected ',' here") ||
-      ParseToken(lltok::kw_summary, "expected 'summary' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::comma, "expected ',' here") ||
+      parseToken(lltok::kw_summary, "expected 'summary' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   IdToIndexMapType IdToIndexMap;
-  // Parse each call edge
+  // parse each call edge
   do {
     uint64_t Offset;
-    if (ParseToken(lltok::lparen, "expected '(' here") ||
-        ParseToken(lltok::kw_offset, "expected 'offset' here") ||
-        ParseToken(lltok::colon, "expected ':' here") || ParseUInt64(Offset) ||
-        ParseToken(lltok::comma, "expected ',' here"))
+    if (parseToken(lltok::lparen, "expected '(' here") ||
+        parseToken(lltok::kw_offset, "expected 'offset' here") ||
+        parseToken(lltok::colon, "expected ':' here") || parseUInt64(Offset) ||
+        parseToken(lltok::comma, "expected ',' here"))
       return true;
 
     LocTy Loc = Lex.getLoc();
     unsigned GVId;
     ValueInfo VI;
-    if (ParseGVReference(VI, GVId))
+    if (parseGVReference(VI, GVId))
       return true;
 
     // Keep track of the TypeIdCompatibleVtableInfo array index needing a
@@ -7748,25 +8012,23 @@ bool LLParser::ParseTypeIdCompatibleVtableEntry(unsigned ID) {
       IdToIndexMap[GVId].push_back(std::make_pair(TI.size(), Loc));
     TI.push_back({Offset, VI});
 
-    if (ParseToken(lltok::rparen, "expected ')' in call"))
+    if (parseToken(lltok::rparen, "expected ')' in call"))
       return true;
   } while (EatIfPresent(lltok::comma));
 
   // Now that the TI vector is finalized, it is safe to save the locations
   // of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Infos = ForwardRefValueInfos[I.first];
     for (auto P : I.second) {
       assert(TI[P.first].VTableVI == EmptyVI &&
              "Forward referenced ValueInfo expected to be empty");
-      auto FwdRef = ForwardRefValueInfos.insert(std::make_pair(
-          I.first, std::vector<std::pair<ValueInfo *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&TI[P.first].VTableVI, P.second));
+      Infos.emplace_back(&TI[P.first].VTableVI, P.second);
     }
   }
@@ -7818,34 +8080,34 @@ bool LLParser::ParseTypeTestResolution(TypeTestResolution &TTRes) {
     TTRes.TheKind = TypeTestResolution::AllOnes;
     break;
   default:
-    return Error(Lex.getLoc(), "unexpected TypeTestResolution kind");
+    return error(Lex.getLoc(), "unexpected TypeTestResolution kind");
   }
   Lex.Lex();
 
-  if (ParseToken(lltok::comma, "expected ',' here") ||
-      ParseToken(lltok::kw_sizeM1BitWidth, "expected 'sizeM1BitWidth' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseUInt32(TTRes.SizeM1BitWidth))
+  if (parseToken(lltok::comma, "expected ',' here") ||
+      parseToken(lltok::kw_sizeM1BitWidth, "expected 'sizeM1BitWidth' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseUInt32(TTRes.SizeM1BitWidth))
     return true;
 
-  // Parse optional fields
+  // parse optional fields
   while (EatIfPresent(lltok::comma)) {
     switch (Lex.getKind()) {
     case lltok::kw_alignLog2:
       Lex.Lex();
-      if (ParseToken(lltok::colon, "expected ':'") ||
-          ParseUInt64(TTRes.AlignLog2))
+      if (parseToken(lltok::colon, "expected ':'") ||
+          parseUInt64(TTRes.AlignLog2))
         return true;
       break;
     case lltok::kw_sizeM1:
       Lex.Lex();
-      if (ParseToken(lltok::colon, "expected ':'") || ParseUInt64(TTRes.SizeM1))
+      if (parseToken(lltok::colon, "expected ':'") || parseUInt64(TTRes.SizeM1))
         return true;
       break;
     case lltok::kw_bitMask: {
       unsigned Val;
       Lex.Lex();
-      if (ParseToken(lltok::colon, "expected ':'") || ParseUInt32(Val))
+      if (parseToken(lltok::colon, "expected ':'") || parseUInt32(Val))
         return true;
       assert(Val <= 0xff);
       TTRes.BitMask = (uint8_t)Val;
@@ -7853,16 +8115,16 @@ bool LLParser::ParseTypeTestResolution(TypeTestResolution &TTRes) {
     }
     case lltok::kw_inlineBits:
       Lex.Lex();
-      if (ParseToken(lltok::colon, "expected ':'") ||
-          ParseUInt64(TTRes.InlineBits))
+      if (parseToken(lltok::colon, "expected ':'") ||
+          parseUInt64(TTRes.InlineBits))
         return true;
       break;
     default:
-      return Error(Lex.getLoc(), "expected optional TypeTestResolution field");
+      return error(Lex.getLoc(), "expected optional TypeTestResolution field");
     }
   }
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -7871,26 +8133,26 @@ bool LLParser::ParseTypeTestResolution(TypeTestResolution &TTRes) {
 /// OptionalWpdResolutions
 ///   ::= 'wpsResolutions' ':' '(' WpdResolution [',' WpdResolution]* ')'
 /// WpdResolution ::= '(' 'offset' ':' UInt64 ',' WpdRes ')'
-bool LLParser::ParseOptionalWpdResolutions(
+bool LLParser::parseOptionalWpdResolutions(
     std::map<uint64_t, WholeProgramDevirtResolution> &WPDResMap) {
-  if (ParseToken(lltok::kw_wpdResolutions, "expected 'wpdResolutions' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::kw_wpdResolutions, "expected 'wpdResolutions' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   do {
     uint64_t Offset;
     WholeProgramDevirtResolution WPDRes;
-    if (ParseToken(lltok::lparen, "expected '(' here") ||
-        ParseToken(lltok::kw_offset, "expected 'offset' here") ||
-        ParseToken(lltok::colon, "expected ':' here") || ParseUInt64(Offset) ||
-        ParseToken(lltok::comma, "expected ',' here") || ParseWpdRes(WPDRes) ||
-        ParseToken(lltok::rparen, "expected ')' here"))
+    if (parseToken(lltok::lparen, "expected '(' here") ||
+        parseToken(lltok::kw_offset, "expected 'offset' here") ||
+        parseToken(lltok::colon, "expected ':' here") || parseUInt64(Offset) ||
+        parseToken(lltok::comma, "expected ',' here") || parseWpdRes(WPDRes) ||
+        parseToken(lltok::rparen, "expected ')' here"))
       return true;
     WPDResMap[Offset] = WPDRes;
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -7923,30 +8185,30 @@ bool LLParser::ParseWpdRes(WholeProgramDevirtResolution &WPDRes) {
     WPDRes.TheKind = WholeProgramDevirtResolution::BranchFunnel;
     break;
   default:
-    return Error(Lex.getLoc(), "unexpected WholeProgramDevirtResolution kind");
+    return error(Lex.getLoc(), "unexpected WholeProgramDevirtResolution kind");
   }
   Lex.Lex();
 
-  // Parse optional fields
+  // parse optional fields
   while (EatIfPresent(lltok::comma)) {
     switch (Lex.getKind()) {
     case lltok::kw_singleImplName:
       Lex.Lex();
-      if (ParseToken(lltok::colon, "expected ':' here") ||
-          ParseStringConstant(WPDRes.SingleImplName))
+      if (parseToken(lltok::colon, "expected ':' here") ||
+          parseStringConstant(WPDRes.SingleImplName))
         return true;
       break;
     case lltok::kw_resByArg:
-      if (ParseOptionalResByArg(WPDRes.ResByArg))
+      if (parseOptionalResByArg(WPDRes.ResByArg))
         return true;
       break;
     default:
-      return Error(Lex.getLoc(),
+      return error(Lex.getLoc(),
                    "expected optional WholeProgramDevirtResolution field");
     }
   }
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -7959,22 +8221,22 @@ bool LLParser::ParseWpdRes(WholeProgramDevirtResolution &WPDRes) {
 ///                  'virtualConstProp' )
 ///                [',' 'info' ':' UInt64]? [',' 'byte' ':' UInt32]?
 ///                [',' 'bit' ':' UInt32]? ')'
-bool LLParser::ParseOptionalResByArg(
+bool LLParser::parseOptionalResByArg(
     std::map<std::vector<uint64_t>, WholeProgramDevirtResolution::ByArg>
         &ResByArg) {
-  if (ParseToken(lltok::kw_resByArg, "expected 'resByArg' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::kw_resByArg, "expected 'resByArg' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   do {
     std::vector<uint64_t> Args;
-    if (ParseArgs(Args) || ParseToken(lltok::comma, "expected ',' here") ||
-        ParseToken(lltok::kw_byArg, "expected 'byArg here") ||
-        ParseToken(lltok::colon, "expected ':' here") ||
-        ParseToken(lltok::lparen, "expected '(' here") ||
-        ParseToken(lltok::kw_kind, "expected 'kind' here") ||
-        ParseToken(lltok::colon, "expected ':' here"))
+    if (parseArgs(Args) || parseToken(lltok::comma, "expected ',' here") ||
+        parseToken(lltok::kw_byArg, "expected 'byArg here") ||
+        parseToken(lltok::colon, "expected ':' here") ||
+        parseToken(lltok::lparen, "expected '(' here") ||
+        parseToken(lltok::kw_kind, "expected 'kind' here") ||
+        parseToken(lltok::colon, "expected ':' here"))
       return true;
 
     WholeProgramDevirtResolution::ByArg ByArg;
@@ -7992,45 +8254,45 @@ bool LLParser::ParseOptionalResByArg(
       ByArg.TheKind = WholeProgramDevirtResolution::ByArg::VirtualConstProp;
       break;
     default:
-      return Error(Lex.getLoc(),
+      return error(Lex.getLoc(),
                    "unexpected WholeProgramDevirtResolution::ByArg kind");
     }
     Lex.Lex();
 
-    // Parse optional fields
+    // parse optional fields
     while (EatIfPresent(lltok::comma)) {
       switch (Lex.getKind()) {
       case lltok::kw_info:
         Lex.Lex();
-        if (ParseToken(lltok::colon, "expected ':' here") ||
-            ParseUInt64(ByArg.Info))
+        if (parseToken(lltok::colon, "expected ':' here") ||
+            parseUInt64(ByArg.Info))
           return true;
         break;
       case lltok::kw_byte:
         Lex.Lex();
-        if (ParseToken(lltok::colon, "expected ':' here") ||
-            ParseUInt32(ByArg.Byte))
+        if (parseToken(lltok::colon, "expected ':' here") ||
+            parseUInt32(ByArg.Byte))
           return true;
         break;
       case lltok::kw_bit:
         Lex.Lex();
-        if (ParseToken(lltok::colon, "expected ':' here") ||
-            ParseUInt32(ByArg.Bit))
+        if (parseToken(lltok::colon, "expected ':' here") ||
+            parseUInt32(ByArg.Bit))
           return true;
         break;
       default:
-        return Error(Lex.getLoc(),
+        return error(Lex.getLoc(),
                      "expected optional whole program devirt field");
       }
     }
 
-    if (ParseToken(lltok::rparen, "expected ')' here"))
+    if (parseToken(lltok::rparen, "expected ')' here"))
       return true;
 
     ResByArg[Args] = ByArg;
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -8038,20 +8300,20 @@ bool LLParser::ParseOptionalResByArg(
 
 /// OptionalResByArg
 ///   ::= 'args' ':' '(' UInt64[, UInt64]* ')'
-bool LLParser::ParseArgs(std::vector<uint64_t> &Args) {
-  if (ParseToken(lltok::kw_args, "expected 'args' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+bool LLParser::parseArgs(std::vector<uint64_t> &Args) {
+  if (parseToken(lltok::kw_args, "expected 'args' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   do {
     uint64_t Val;
-    if (ParseUInt64(Val))
+    if (parseUInt64(Val))
       return true;
     Args.push_back(Val);
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -8412,16 +8676,14 @@ bool LLParser::ParseAliasSummary(std::string Name, GlobalValue::GUID GUID,
 
   // Record forward reference if the aliasee is not parsed yet.
   if (AliaseeVI.getRef() == FwdVIRef) {
-    auto FwdRef = ForwardRefAliasees.insert(
-        std::make_pair(GVId, std::vector<std::pair<AliasSummary *, LocTy>>()));
-    FwdRef.first->second.push_back(std::make_pair(AS.get(), Loc));
+    ForwardRefAliasees[GVId].emplace_back(AS.get(), Loc);
   } else {
     auto Summary = Index->findSummaryInModule(AliaseeVI, ModulePath);
     assert(Summary && "Aliasee must be a definition");
     AS->setAliasee(AliaseeVI, Summary);
   }
 
-  AddGlobalValueToIndex(Name, GUID, (GlobalValue::LinkageTypes)GVFlags.Linkage,
+  addGlobalValueToIndex(Name, GUID, (GlobalValue::LinkageTypes)GVFlags.Linkage,
                         ID, std::move(AS));
 
   return false;
@@ -8548,24 +8810,22 @@ bool LLParser::ParseOptionalCalls(std::vector<FunctionSummary::EdgeTy> &Calls) {
   // Now that the Calls vector is finalized, it is safe to save the locations
   // of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Infos = ForwardRefValueInfos[I.first];
     for (auto P : I.second) {
       assert(Calls[P.first].first.getRef() == FwdVIRef &&
              "Forward referenced ValueInfo expected to be empty");
-      auto FwdRef = ForwardRefValueInfos.insert(std::make_pair(
-          I.first, std::vector<std::pair<ValueInfo *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&Calls[P.first].first, P.second));
+      Infos.emplace_back(&Calls[P.first].first, P.second);
     }
   }
@@ -8635,55 +8895,53 @@ bool LLParser::ParseOptionalVTableFuncs(VTableFuncList &VTableFuncs) {
   // Now that the VTableFuncs vector is finalized, it is safe to save the
   // locations of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Infos = ForwardRefValueInfos[I.first];
     for (auto P : I.second) {
       assert(VTableFuncs[P.first].FuncVI == EmptyVI &&
              "Forward referenced ValueInfo expected to be empty");
-      auto FwdRef = ForwardRefValueInfos.insert(std::make_pair(
-          I.first, std::vector<std::pair<ValueInfo *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&VTableFuncs[P.first].FuncVI, P.second));
+      Infos.emplace_back(&VTableFuncs[P.first].FuncVI, P.second);
     }
   }
@@ -8697,26 +8955,29 @@ bool LLParser::ParseParamAccessOffset(ConstantRange &Range) {
 
 /// ParamAccessCall
 ///   := '(' 'callee' ':' GVReference ',' ParamNo ',' ParamAccessOffset ')'
-bool LLParser::ParseParamAccessCall(FunctionSummary::ParamAccess::Call &Call) {
-  if (ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseToken(lltok::kw_callee, "expected 'callee' here") ||
-      ParseToken(lltok::colon, "expected ':' here"))
+bool LLParser::parseParamAccessCall(FunctionSummary::ParamAccess::Call &Call,
+                                    IdLocListType &IdLocList) {
+  if (parseToken(lltok::lparen, "expected '(' here") ||
+      parseToken(lltok::kw_callee, "expected 'callee' here") ||
+      parseToken(lltok::colon, "expected ':' here"))
     return true;
 
   unsigned GVId;
   ValueInfo VI;
-  if (ParseGVReference(VI, GVId))
+  LocTy Loc = Lex.getLoc();
+  if (parseGVReference(VI, GVId))
     return true;
 
-  Call.Callee = VI.getGUID();
+  Call.Callee = VI;
+  IdLocList.emplace_back(GVId, Loc);
@@ -8756,36 +9018,53 @@ bool LLParser::ParseParamAccess(FunctionSummary::ParamAccess &Param) {
 
 /// OptionalParamAccesses
 ///   := 'params' ':' '(' ParamAccess [',' ParamAccess]* ')'
-bool LLParser::ParseOptionalParamAccesses(
+bool LLParser::parseOptionalParamAccesses(
     std::vector<FunctionSummary::ParamAccess> &Params) {
   assert(Lex.getKind() == lltok::kw_params);
   Lex.Lex();
 
-  if (ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
+  IdLocListType VContexts;
+  size_t CallsNum = 0;
   do {
     FunctionSummary::ParamAccess ParamAccess;
-    if (ParseParamAccess(ParamAccess))
+    if (parseParamAccess(ParamAccess, VContexts))
       return true;
-    Params.push_back(ParamAccess);
+    CallsNum += ParamAccess.Calls.size();
+    assert(VContexts.size() == CallsNum);
+    Params.emplace_back(std::move(ParamAccess));
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
+  // Now that the Params is finalized, it is safe to save the locations
+  // of any forward GV references that need updating later.
+  IdLocListType::const_iterator ItContext = VContexts.begin();
+  for (auto &PA : Params) {
+    for (auto &C : PA.Calls) {
+      if (C.Callee.getRef() == FwdVIRef)
+        ForwardRefValueInfos[ItContext->first].emplace_back(&C.Callee,
+                                                            ItContext->second);
+      ++ItContext;
+    }
+  }
+  assert(ItContext == VContexts.end());
+
   return false;
 }
@@ -8823,16 +9102,15 @@ bool LLParser::ParseOptionalRefs(std::vector<ValueInfo> &Refs) {
   // Now that the Refs vector is finalized, it is safe to save the locations
   // of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Infos = ForwardRefValueInfos[I.first];
     for (auto P : I.second) {
       assert(Refs[P.first].getRef() == FwdVIRef &&
              "Forward referenced ValueInfo expected to be empty");
-      auto FwdRef = ForwardRefValueInfos.insert(std::make_pair(
-          I.first, std::vector<std::pair<ValueInfo *, LocTy>>()));
-      FwdRef.first->second.push_back(std::make_pair(&Refs[P.first], P.second));
+      Infos.emplace_back(&Refs[P.first], P.second);
     }
   }
@@ -8918,17 +9196,15 @@ bool LLParser::ParseTypeTests(std::vector<GlobalValue::GUID> &TypeTests) {
   // Now that the TypeTests vector is finalized, it is safe to save the
   // locations of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Ids = ForwardRefTypeIds[I.first];
     for (auto P : I.second) {
       assert(TypeTests[P.first] == 0 &&
              "Forward referenced type id GUID expected to be 0");
-      auto FwdRef = ForwardRefTypeIds.insert(std::make_pair(
-          I.first, std::vector<std::pair<GlobalValue::GUID *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&TypeTests[P.first], P.second));
+      Ids.emplace_back(&TypeTests[P.first], P.second);
     }
   }
@@ -8936,36 +9212,34 @@ bool LLParser::ParseTypeTests(std::vector<GlobalValue::GUID> &TypeTests) {
   // Now that the VFuncIdList vector is finalized, it is safe to save the
   // locations of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Ids = ForwardRefTypeIds[I.first];
     for (auto P : I.second) {
       assert(VFuncIdList[P.first].GUID == 0 &&
              "Forward referenced type id GUID expected to be 0");
-      auto FwdRef = ForwardRefTypeIds.insert(std::make_pair(
-          I.first, std::vector<std::pair<GlobalValue::GUID *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&VFuncIdList[P.first].GUID, P.second));
+      Ids.emplace_back(&VFuncIdList[P.first].GUID, P.second);
     }
   }
 
@@ -8974,37 +9248,35 @@ bool LLParser::ParseVFuncIdList(
 
 /// ConstVCallList
 ///   ::= Kind ':' '(' ConstVCall [',' ConstVCall]* ')'
-bool LLParser::ParseConstVCallList(
+bool LLParser::parseConstVCallList(
     lltok::Kind Kind,
     std::vector<FunctionSummary::ConstVCall> &ConstVCallList) {
   assert(Lex.getKind() == Kind);
   Lex.Lex();
 
-  if (ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   IdToIndexMapType IdToIndexMap;
   do {
     FunctionSummary::ConstVCall ConstVCall;
-    if (ParseConstVCall(ConstVCall, IdToIndexMap, ConstVCallList.size()))
+    if (parseConstVCall(ConstVCall, IdToIndexMap, ConstVCallList.size()))
       return true;
     ConstVCallList.push_back(ConstVCall);
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   // Now that the ConstVCallList vector is finalized, it is safe to save the
   // locations of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Ids = ForwardRefTypeIds[I.first];
     for (auto P : I.second) {
       assert(ConstVCallList[P.first].VFunc.GUID == 0 &&
              "Forward referenced type id GUID expected to be 0");
-      auto FwdRef = ForwardRefTypeIds.insert(std::make_pair(
-          I.first, std::vector<std::pair<GlobalValue::GUID *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&ConstVCallList[P.first].VFunc.GUID, P.second));
+      Ids.emplace_back(&ConstVCallList[P.first].VFunc.GUID, P.second);
     }
   }
@@ -9167,19 +9439,19 @@ bool LLParser::ParseGVarFlags(GlobalVarSummary::GVarFlags &GVarFlags) {
 /// ModuleReference
 ///   ::= 'module' ':' UInt
-bool LLParser::ParseModuleReference(StringRef &ModulePath) {
-  // Parse module id.
-  if (ParseToken(lltok::kw_module, "expected 'module' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::SummaryID, "expected module ID"))
+bool LLParser::parseModuleReference(StringRef &ModulePath) {
+  // parse module id.
+  if (parseToken(lltok::kw_module, "expected 'module' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::SummaryID, "expected module ID"))
     return true;
 
   unsigned ModuleID = Lex.getUIntVal();
diff --git a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLParser.h b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLParser.h
index ebd8655..aa79823 100644
--- a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLParser.h
+++ b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLParser.h
@@ -46,7 +46,7 @@ namespace llvm {
       t_LocalID, t_GlobalID,           // ID in UIntVal.
       t_LocalName, t_GlobalName,       // Name in StrVal.
       t_APSInt, t_APFloat,             // Value in APSIntVal/APFloatVal.
-      t_Null, t_Undef, t_Zero, t_None, // No value.
+      t_Null, t_Undef, t_Zero, t_None, t_Poison, // No value.
       t_EmptyArray,                    // No value:  []
       t_Constant,                      // Value in ConstantVal.
       t_InlineAsm,                     // Value in FTy/StrVal/StrVal2/UIntVal.
@@ -166,8 +166,8 @@ namespace llvm {
         : Context(Context), Lex(F, SM, Err, Context), M(M), Index(Index),
           Slots(Slots), BlockAddressPFS(nullptr) {}
     bool Run(
-        bool UpgradeDebugInfo,
-        DataLayoutCallbackTy DataLayoutCallback = [](Module *) {});
+        bool UpgradeDebugInfo, DataLayoutCallbackTy DataLayoutCallback =
+                                   [](StringRef) { return None; });
 
     bool parseStandaloneConstantValue(Constant *&C, const SlotMapping *Slots);
@@ -240,80 +235,81 @@ namespace llvm {
       }
       return false;
     }
-    bool ParseStringConstant(std::string &Result);
-    bool ParseUInt32(unsigned &Val);
-    bool ParseUInt32(unsigned &Val, LocTy &Loc) {
+    bool parseStringConstant(std::string &Result);
+    bool parseUInt32(unsigned &Val);
+    bool parseUInt32(unsigned &Val, LocTy &Loc) {
       Loc = Lex.getLoc();
-      return ParseUInt32(Val);
+      return parseUInt32(Val);
     }
-    bool ParseUInt64(uint64_t &Val);
-    bool ParseUInt64(uint64_t &Val, LocTy &Loc) {
+    bool parseUInt64(uint64_t &Val);
+    bool parseUInt64(uint64_t &Val, LocTy &Loc) {
       Loc = Lex.getLoc();
-      return ParseUInt64(Val);
+      return parseUInt64(Val);
     }
-    bool ParseFlag(unsigned &Val);
+    bool parseFlag(unsigned &Val);
 
-    bool ParseStringAttribute(AttrBuilder &B);
+    bool parseStringAttribute(AttrBuilder &B);
 
-    bool ParseTLSModel(GlobalVariable::ThreadLocalMode &TLM);
-    bool ParseOptionalThreadLocal(GlobalVariable::ThreadLocalMode &TLM);
-    bool ParseOptionalUnnamedAddr(GlobalVariable::UnnamedAddr &UnnamedAddr);
-    bool ParseOptionalAddrSpace(unsigned &AddrSpace, unsigned DefaultAS = 0);
-    bool ParseOptionalProgramAddrSpace(unsigned &AddrSpace) {
-      return ParseOptionalAddrSpace(
+    bool parseTLSModel(GlobalVariable::ThreadLocalMode &TLM);
+    bool parseOptionalThreadLocal(GlobalVariable::ThreadLocalMode &TLM);
+    bool parseOptionalUnnamedAddr(GlobalVariable::UnnamedAddr &UnnamedAddr);
+    bool parseOptionalAddrSpace(unsigned &AddrSpace, unsigned DefaultAS = 0);
+    bool parseOptionalProgramAddrSpace(unsigned &AddrSpace) {
+      return parseOptionalAddrSpace(
           AddrSpace, M->getDataLayout().getProgramAddressSpace());
     };
-    bool ParseOptionalParamAttrs(AttrBuilder &B);
-    bool ParseOptionalReturnAttrs(AttrBuilder &B);
-    bool ParseOptionalLinkage(unsigned &Res, bool &HasLinkage,
+    bool parseOptionalParamAttrs(AttrBuilder &B);
+    bool parseOptionalReturnAttrs(AttrBuilder &B);
+    bool parseOptionalLinkage(unsigned &Res, bool &HasLinkage,
                               unsigned &Visibility, unsigned &DLLStorageClass,
                               bool &DSOLocal);
-    void ParseOptionalDSOLocal(bool &DSOLocal);
-    void ParseOptionalVisibility(unsigned &Res);
-    void ParseOptionalDLLStorageClass(unsigned &Res);
-    bool ParseOptionalCallingConv(unsigned &CC);
-    bool ParseOptionalAlignment(MaybeAlign &Alignment,
+    void parseOptionalDSOLocal(bool &DSOLocal);
+    void parseOptionalVisibility(unsigned &Res);
+    void parseOptionalDLLStorageClass(unsigned &Res);
+    bool parseOptionalCallingConv(unsigned &CC);
+    bool parseOptionalAlignment(MaybeAlign &Alignment,
                                 bool AllowParens = false);
-    bool ParseOptionalDerefAttrBytes(lltok::Kind AttrKind, uint64_t &Bytes);
-    bool ParseScopeAndOrdering(bool isAtomic, SyncScope::ID &SSID,
+    bool parseOptionalDerefAttrBytes(lltok::Kind AttrKind, uint64_t &Bytes);
+    bool parseScopeAndOrdering(bool IsAtomic, SyncScope::ID &SSID,
                                AtomicOrdering &Ordering);
-    bool ParseScope(SyncScope::ID &SSID);
-    bool ParseOrdering(AtomicOrdering &Ordering);
-    bool ParseOptionalStackAlignment(unsigned &Alignment);
-    bool ParseOptionalCommaAlign(MaybeAlign &Alignment, bool &AteExtraComma);
-    bool ParseOptionalCommaAddrSpace(unsigned &AddrSpace, LocTy &Loc,
+    bool parseScope(SyncScope::ID &SSID);
+    bool parseOrdering(AtomicOrdering &Ordering);
+    bool parseOptionalStackAlignment(unsigned &Alignment);
+    bool parseOptionalCommaAlign(MaybeAlign &Alignment, bool &AteExtraComma);
+    bool parseOptionalCommaAddrSpace(unsigned &AddrSpace, LocTy &Loc,
                                      bool &AteExtraComma);
-    bool ParseOptionalCommaInAlloca(bool &IsInAlloca);
+    bool parseOptionalCommaInAlloca(bool &IsInAlloca);
     bool parseAllocSizeArguments(unsigned &BaseSizeArg,
                                  Optional<unsigned> &HowManyArg);
-    bool ParseIndexList(SmallVectorImpl<unsigned> &Indices,
+    bool parseIndexList(SmallVectorImpl<unsigned> &Indices,
                         bool &AteExtraComma);
-    bool ParseIndexList(SmallVectorImpl<unsigned> &Indices) {
+    bool parseIndexList(SmallVectorImpl<unsigned> &Indices) {
       bool AteExtraComma;
-      if (ParseIndexList(Indices, AteExtraComma)) return true;
+      if (parseIndexList(Indices, AteExtraComma))
+        return true;
       if (AteExtraComma)
-        return TokError("expected index");
+        return tokError("expected index");
       return false;
     }
 
     // Top-Level Entities
-    bool ParseTopLevelEntities();
-    bool ValidateEndOfModule(bool UpgradeDebugInfo);
-    bool ValidateEndOfIndex();
-    bool ParseTargetDefinitions();
-    bool ParseTargetDefinition();
-    bool ParseModuleAsm();
-    bool ParseSourceFileName();
-    bool ParseDepLibs();        // FIXME: Remove in 4.0.
-    bool ParseUnnamedType();
-    bool ParseNamedType();
-    bool ParseDeclare();
-    bool ParseDefine();
-
-    bool ParseGlobalType(bool &IsConstant);
-    bool ParseUnnamedGlobal();
-    bool ParseNamedGlobal();
-    bool ParseGlobal(const std::string &Name, LocTy NameLoc, unsigned Linkage,
+    bool parseTopLevelEntities();
+    bool validateEndOfModule(bool UpgradeDebugInfo);
+    bool validateEndOfIndex();
+    bool parseTargetDefinitions();
+    bool parseTargetDefinition();
+    bool parseModuleAsm();
+    bool parseSourceFileName();
+    bool parseDepLibs(); // FIXME: Remove in 4.0.
+    bool parseUnnamedType();
+    bool parseNamedType();
+    bool parseDeclare();
+    bool parseDefine();
+
+    bool parseGlobalType(bool &IsConstant);
+    bool parseUnnamedGlobal();
+    bool parseNamedGlobal();
+    bool parseGlobal(const std::string &Name, LocTy NameLoc, unsigned Linkage,
                      bool HasLinkage, unsigned Visibility,
                      unsigned DLLStorageClass, bool DSOLocal,
                      GlobalVariable::ThreadLocalMode TLM,
@@ -324,92 +320,96 @@ namespace llvm {
-    bool ParseByValWithOptionalType(Type *&Result);
-    bool ParsePreallocated(Type *&Result);
+    bool parseRequiredTypeAttr(Type *&Result, lltok::Kind AttrName);
+    bool parsePreallocated(Type *&Result);
+    bool parseByRef(Type *&Result);
 
     // Module Summary Index Parsing.
-    bool SkipModuleSummaryEntry();
-    bool ParseSummaryEntry();
-    bool ParseModuleEntry(unsigned ID);
-    bool ParseModuleReference(StringRef &ModulePath);
-    bool ParseGVReference(ValueInfo &VI, unsigned &GVId);
-    bool ParseSummaryIndexFlags();
-    bool ParseBlockCount();
-    bool ParseGVEntry(unsigned ID);
-    bool ParseFunctionSummary(std::string Name, GlobalValue::GUID, unsigned ID);
-    bool ParseVariableSummary(std::string Name, GlobalValue::GUID, unsigned ID);
-    bool ParseAliasSummary(std::string Name, GlobalValue::GUID, unsigned ID);
-    bool ParseGVFlags(GlobalValueSummary::GVFlags &GVFlags);
-    bool ParseGVarFlags(GlobalVarSummary::GVarFlags &GVarFlags);
-    bool ParseOptionalFFlags(FunctionSummary::FFlags &FFlags);
-    bool ParseOptionalCalls(std::vector<FunctionSummary::EdgeTy> &Calls);
-    bool ParseHotness(CalleeInfo::HotnessType &Hotness);
-    bool ParseOptionalTypeIdInfo(FunctionSummary::TypeIdInfo &TypeIdInfo);
-    bool ParseTypeTests(std::vector<GlobalValue::GUID> &TypeTests);
-    bool ParseVFuncIdList(lltok::Kind Kind,
+    bool skipModuleSummaryEntry();
+    bool parseSummaryEntry();
+    bool parseModuleEntry(unsigned ID);
+    bool parseModuleReference(StringRef &ModulePath);
+    bool parseGVReference(ValueInfo &VI, unsigned &GVId);
+    bool parseSummaryIndexFlags();
+    bool parseBlockCount();
+    bool parseGVEntry(unsigned ID);
+    bool parseFunctionSummary(std::string Name, GlobalValue::GUID, unsigned ID);
+    bool parseVariableSummary(std::string Name, GlobalValue::GUID, unsigned ID);
+    bool parseAliasSummary(std::string Name, GlobalValue::GUID, unsigned ID);
+    bool parseGVFlags(GlobalValueSummary::GVFlags &GVFlags);
+    bool parseGVarFlags(GlobalVarSummary::GVarFlags &GVarFlags);
+    bool parseOptionalFFlags(FunctionSummary::FFlags &FFlags);
+    bool parseOptionalCalls(std::vector<FunctionSummary::EdgeTy> &Calls);
+    bool parseHotness(CalleeInfo::HotnessType &Hotness);
+    bool parseOptionalTypeIdInfo(FunctionSummary::TypeIdInfo &TypeIdInfo);
+    bool parseTypeTests(std::vector<GlobalValue::GUID> &TypeTests);
+    bool parseVFuncIdList(lltok::Kind Kind,
                           std::vector<FunctionSummary::VFuncId> &VFuncIdList);
-    bool ParseConstVCallList(
+    bool parseConstVCallList(
         lltok::Kind Kind,
         std::vector<FunctionSummary::ConstVCall> &ConstVCallList);
     using IdToIndexMapType =
         std::map<unsigned, std::vector<std::pair<unsigned, LocTy>>>;
-    bool ParseConstVCall(FunctionSummary::ConstVCall &ConstVCall,
+    bool parseConstVCall(FunctionSummary::ConstVCall &ConstVCall,
                          IdToIndexMapType &IdToIndexMap, unsigned Index);
-    bool ParseVFuncId(FunctionSummary::VFuncId &VFuncId,
+    bool parseVFuncId(FunctionSummary::VFuncId &VFuncId,
                       IdToIndexMapType &IdToIndexMap, unsigned Index);
-    bool ParseOptionalVTableFuncs(VTableFuncList &VTableFuncs);
-    bool ParseOptionalParamAccesses(
+    bool parseOptionalVTableFuncs(VTableFuncList &VTableFuncs);
+    bool parseOptionalParamAccesses(
         std::vector<FunctionSummary::ParamAccess> &Params);
-    bool ParseParamNo(uint64_t &ParamNo);
-    bool ParseParamAccess(FunctionSummary::ParamAccess &Param);
-    bool ParseParamAccessCall(FunctionSummary::ParamAccess::Call &Call);
-    bool ParseParamAccessOffset(ConstantRange &range);
-    bool ParseOptionalRefs(std::vector<ValueInfo> &Refs);
-    bool ParseTypeIdEntry(unsigned ID);
-    bool ParseTypeIdSummary(TypeIdSummary &TIS);
-    bool ParseTypeIdCompatibleVtableEntry(unsigned ID);
-    bool ParseTypeTestResolution(TypeTestResolution &TTRes);
-    bool ParseOptionalWpdResolutions(
+    bool parseParamNo(uint64_t &ParamNo);
+    using IdLocListType = std::vector<std::pair<unsigned, LocTy>>;
+    bool parseParamAccess(FunctionSummary::ParamAccess &Param,
+                          IdLocListType &IdLocList);
+    bool parseParamAccessCall(FunctionSummary::ParamAccess::Call &Call,
+                              IdLocListType &IdLocList);
+    bool parseParamAccessOffset(ConstantRange &Range);
+    bool parseOptionalRefs(std::vector<ValueInfo> &Refs);
+    bool parseTypeIdEntry(unsigned ID);
+    bool parseTypeIdSummary(TypeIdSummary &TIS);
+    bool parseTypeIdCompatibleVtableEntry(unsigned ID);
+    bool parseTypeTestResolution(TypeTestResolution &TTRes);
+    bool parseOptionalWpdResolutions(
         std::map<uint64_t, WholeProgramDevirtResolution> &WPDResMap);
-    bool ParseWpdRes(WholeProgramDevirtResolution &WPDRes);
-    bool ParseOptionalResByArg(
+    bool parseWpdRes(WholeProgramDevirtResolution &WPDRes);
+    bool parseOptionalResByArg(
         std::map<std::vector<uint64_t>, WholeProgramDevirtResolution::ByArg>
             &ResByArg);
-    bool ParseArgs(std::vector<uint64_t> &Args);
-    void AddGlobalValueToIndex(std::string Name, GlobalValue::GUID,
+    bool parseArgs(std::vector<uint64_t> &Args);
+    void addGlobalValueToIndex(std::string Name, GlobalValue::GUID,
                                GlobalValue::LinkageTypes Linkage, unsigned ID,
                                std::unique_ptr<GlobalValueSummary> Summary);
 
     // Type Parsing.
-    bool ParseType(Type *&Result, const Twine &Msg, bool AllowVoid = false);
-    bool ParseType(Type *&Result, bool AllowVoid = false) {
-      return ParseType(Result, "expected type", AllowVoid);
+    bool parseType(Type *&Result, const Twine &Msg, bool AllowVoid = false);
+    bool parseType(Type *&Result, bool AllowVoid = false) {
+      return parseType(Result, "expected type", AllowVoid);
     }
-    bool ParseType(Type *&Result, const Twine &Msg, LocTy &Loc,
+    bool parseType(Type *&Result, const Twine &Msg, LocTy &Loc,
                    bool AllowVoid = false) {
       Loc = Lex.getLoc();
-      return ParseType(Result, Msg, AllowVoid);
+      return parseType(Result, Msg, AllowVoid);
     }
-    bool ParseType(Type *&Result, LocTy &Loc, bool AllowVoid = false) {
+    bool parseType(Type *&Result, LocTy &Loc, bool AllowVoid = false) {
       Loc = Lex.getLoc();
-      return ParseType(Result, AllowVoid);
+      return parseType(Result, AllowVoid);
     }
-    bool ParseAnonStructType(Type *&Result, bool Packed);
-    bool ParseStructBody(SmallVectorImpl<Type*> &Body);
-    bool ParseStructDefinition(SMLoc TypeLoc, StringRef Name,
-                               std::pair<Type*, LocTy> &Entry,
+    bool parseAnonStructType(Type *&Result, bool Packed);
+    bool parseStructBody(SmallVectorImpl<Type *> &Body);
+    bool parseStructDefinition(SMLoc TypeLoc, StringRef Name,
+                               std::pair<Type *, LocTy> &Entry,
                                Type *&ResultTy);
 
-    bool ParseArrayVectorType(Type *&Result, bool isVector);
-    bool ParseFunctionType(Type *&Result);
+    bool parseArrayVectorType(Type *&Result, bool IsVector);
+    bool parseFunctionType(Type *&Result);
 
     // Function Semantic Analysis.
     class PerFunctionState {
@@ -428,67 +428,65 @@ namespace llvm {
-    bool ParseTypeAndValue(Value *&V, PerFunctionState *PFS);
-    bool ParseTypeAndValue(Value *&V, PerFunctionState &PFS) {
-      return ParseTypeAndValue(V, &PFS);
+    bool parseTypeAndValue(Value *&V, PerFunctionState *PFS);
+    bool parseTypeAndValue(Value *&V, PerFunctionState &PFS) {
+      return parseTypeAndValue(V, &PFS);
     }
-    bool ParseTypeAndValue(Value *&V, LocTy &Loc, PerFunctionState &PFS) {
+    bool parseTypeAndValue(Value *&V, LocTy &Loc, PerFunctionState &PFS) {
       Loc = Lex.getLoc();
-      return ParseTypeAndValue(V, PFS);
+      return parseTypeAndValue(V, PFS);
     }
-    bool ParseTypeAndBasicBlock(BasicBlock *&BB, LocTy &Loc,
+    bool parseTypeAndBasicBlock(BasicBlock *&BB, LocTy &Loc,
                                 PerFunctionState &PFS);
-    bool ParseTypeAndBasicBlock(BasicBlock *&BB, PerFunctionState &PFS) {
+    bool parseTypeAndBasicBlock(BasicBlock *&BB, PerFunctionState &PFS) {
       LocTy Loc;
-      return ParseTypeAndBasicBlock(BB, Loc, PFS);
+      return parseTypeAndBasicBlock(BB, Loc, PFS);
     }
 
-
     struct ParamInfo {
       LocTy Loc;
       Value *V;
@@ -550,64 +546,64 @@ namespace llvm {
       ArgInfo(LocTy L, Type *ty, AttributeSet Attr, const std::string &N)
           : Loc(L), Ty(ty), Attrs(Attr), Name(N) {}
     };
     enum TailCallType { TCT_None, TCT_Tail, TCT_MustTail };
 
     // Instruction Parsing.  Each instruction parsing routine can return with a
     // normal result, an error result, or return having eaten an extra comma.
     enum InstResult { InstNormal = 0, InstError = 1, InstExtraComma = 2 };
-    bool ParseCmpPredicate(unsigned &P, unsigned Opc);
-
-    bool ParseRet(Instruction *&Inst, BasicBlock *BB, PerFunctionState &PFS);
-    bool ParseBr(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseSwitch(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseIndirectBr(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseInvoke(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseResume(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCleanupRet(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCatchRet(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCatchSwitch(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCatchPad(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCleanupPad(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCallBr(Instruction *&Inst, PerFunctionState &PFS);
-
-    bool ParseUnaryOp(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc,
+    bool parseCmpPredicate(unsigned &P, unsigned Opc);
+
+    bool parseRet(Instruction *&Inst, BasicBlock *BB, PerFunctionState &PFS);
+    bool parseBr(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseSwitch(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseIndirectBr(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseInvoke(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseResume(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCleanupRet(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCatchRet(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCatchSwitch(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCatchPad(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCleanupPad(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCallBr(Instruction *&Inst, PerFunctionState &PFS);
+
+    bool parseUnaryOp(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc,
                       bool IsFP);
-    bool ParseArithmetic(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc,
-                         bool IsFP);
-    bool ParseLogical(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
-    bool ParseCompare(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
-    bool ParseCast(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
-    bool ParseSelect(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseVA_Arg(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseExtractElement(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseInsertElement(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseShuffleVector(Instruction *&Inst, PerFunctionState &PFS);
-    int ParsePHI(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseLandingPad(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCall(Instruction *&Inst, PerFunctionState &PFS,
+    bool parseArithmetic(Instruction *&Inst, PerFunctionState &PFS,
+                         unsigned Opc, bool IsFP);
+    bool parseLogical(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
+    bool parseCompare(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
+    bool parseCast(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
+    bool parseSelect(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseVAArg(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseExtractElement(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseInsertElement(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseShuffleVector(Instruction *&Inst, PerFunctionState &PFS);
+    int parsePHI(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseLandingPad(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCall(Instruction *&Inst, PerFunctionState &PFS,
                    CallInst::TailCallKind TCK);
-    int ParseAlloc(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseLoad(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseStore(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseCmpXchg(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseAtomicRMW(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseFence(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseExtractValue(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseInsertValue(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseFreeze(Instruction *&I, PerFunctionState &PFS);
+    int parseAlloc(Instruction *&Inst, PerFunctionState &PFS);
+    int parseLoad(Instruction *&Inst, PerFunctionState &PFS);
+    int parseStore(Instruction *&Inst, PerFunctionState &PFS);
+    int parseCmpXchg(Instruction *&Inst, PerFunctionState &PFS);
+    int parseAtomicRMW(Instruction *&Inst, PerFunctionState &PFS);
+    int parseFence(Instruction *&Inst, PerFunctionState &PFS);
+    int parseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS);
+    int parseExtractValue(Instruction *&Inst, PerFunctionState &PFS);
+    int parseInsertValue(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseFreeze(Instruction *&I, PerFunctionState &PFS);
 
     // Use-list order directives.
-    bool ParseUseListOrder(PerFunctionState *PFS = nullptr);
-    bool ParseUseListOrderBB();
-    bool ParseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes);
+    bool parseUseListOrder(PerFunctionState *PFS = nullptr);
+    bool parseUseListOrderBB();
+    bool parseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes);
     bool sortUseListOrder(Value *V, ArrayRef<unsigned> Indexes, SMLoc Loc);
   };
 } // End llvm namespace
diff --git a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLToken.h b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLToken.h
index 0fb3bae..5149f86 100644
--- a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLToken.h
+++ b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLToken.h
@@ -74,6 +74,7 @@ enum Kind {
   kw_localexec,
   kw_zeroinitializer,
   kw_undef,
+  kw_poison,
   kw_null,
   kw_none,
   kw_to,
@@ -170,6 +171,7 @@ enum Kind {
   kw_amdgpu_ps,
   kw_amdgpu_cs,
   kw_amdgpu_kernel,
+  kw_amdgpu_gfx,
   kw_tailcc,
 
   // Attributes:
@@ -198,6 +200,7 @@ enum Kind {
   kw_noalias,
   kw_noundef,
   kw_nobuiltin,
+  kw_nocallback,
   kw_nocapture,
   kw_noduplicate,
   kw_nofree,
@@ -207,6 +210,7 @@ enum Kind {
   kw_nonlazybind,
   kw_nomerge,
   kw_nonnull,
+  kw_noprofile,
   kw_noredzone,
   kw_noreturn,
   kw_nosync,
@@ -240,6 +244,8 @@ enum Kind {
   kw_writeonly,
   kw_zeroext,
   kw_immarg,
+  kw_byref,
+  kw_mustprogress,
 
   kw_type,
   kw_opaque,
@@ -357,6 +363,7 @@ enum Kind {
   kw_extractvalue,
   kw_insertvalue,
   kw_blockaddress,
+  kw_dso_local_equivalent,
 
   kw_freeze,
