diff --git a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLLexer.cpp b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLLexer.cpp
index 777ce3a..427de74 100644
--- a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLLexer.cpp
+++ b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLLexer.cpp
@@ -531,6 +531,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(undef);
   KEYWORD(null);
   KEYWORD(none);
+  KEYWORD(poison);
   KEYWORD(to);
   KEYWORD(caller);
   KEYWORD(within);
@@ -624,6 +625,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(amdgpu_ps);
   KEYWORD(amdgpu_cs);
   KEYWORD(amdgpu_kernel);
+  KEYWORD(amdgpu_gfx);
   KEYWORD(tailcc);
 
   KEYWORD(cc);
@@ -651,6 +653,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(nest);
   KEYWORD(noalias);
   KEYWORD(nobuiltin);
+  KEYWORD(nocallback);
   KEYWORD(nocapture);
   KEYWORD(noduplicate);
   KEYWORD(nofree);
@@ -660,6 +663,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(nonlazybind);
   KEYWORD(nomerge);
   KEYWORD(nonnull);
+  KEYWORD(noprofile);
   KEYWORD(noredzone);
   KEYWORD(noreturn);
   KEYWORD(nosync);
@@ -697,6 +701,8 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(writeonly);
   KEYWORD(zeroext);
   KEYWORD(immarg);
+  KEYWORD(byref);
+  KEYWORD(mustprogress);
 
   KEYWORD(type);
   KEYWORD(opaque);
@@ -721,6 +727,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(vscale);
   KEYWORD(x);
   KEYWORD(blockaddress);
+  KEYWORD(dso_local_equivalent);
 
   // Metadata types.
   KEYWORD(distinct);
@@ -834,6 +841,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   TYPEKEYWORD("label",     Type::getLabelTy(Context));
   TYPEKEYWORD("metadata",  Type::getMetadataTy(Context));
   TYPEKEYWORD("x86_mmx",   Type::getX86_MMXTy(Context));
+  TYPEKEYWORD("x86_amx",   Type::getX86_AMXTy(Context));
   TYPEKEYWORD("token",     Type::getTokenTy(Context));
 
 #undef TYPEKEYWORD
diff --git a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLParser.cpp b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLParser.cpp
index c9f21ee..2a3fb8f 100644
--- a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLParser.cpp
+++ b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLParser.cpp
@@ -65,20 +65,20 @@ bool LLParser::Run(bool UpgradeDebugInfo,
   Lex.Lex();
 
   if (Context.shouldDiscardValueNames())
-    return Error(
+    return error(
         Lex.getLoc(),
         "Can't read textual IR with a Context that discards named Values");
 
   if (M) {
-    if (ParseTargetDefinitions())
+    if (parseTargetDefinitions())
       return true;
 
     if (auto LayoutOverride = DataLayoutCallback(M->getTargetTriple()))
       M->setDataLayout(*LayoutOverride);
   }
 
-  return ParseTopLevelEntities() || ValidateEndOfModule(UpgradeDebugInfo) ||
-         ValidateEndOfIndex();
+  return parseTopLevelEntities() || validateEndOfModule(UpgradeDebugInfo) ||
+         validateEndOfIndex();
 }
 
 bool LLParser::parseStandaloneConstantValue(Constant *&C,
@@ -87,10 +87,10 @@ bool LLParser::parseStandaloneConstantValue(Constant *&C,
   Lex.Lex();
 
   Type *Ty = nullptr;
-  if (ParseType(Ty) || parseConstantValue(Ty, C))
+  if (parseType(Ty) || parseConstantValue(Ty, C))
     return true;
   if (Lex.getKind() != lltok::Eof)
-    return Error(Lex.getLoc(), "expected end of string");
+    return error(Lex.getLoc(), "expected end of string");
   return false;
 }
 
@@ -102,7 +102,7 @@ bool LLParser::parseTypeAtBeginning(Type *&Ty, unsigned &Read,
   Read = 0;
   SMLoc Start = Lex.getLoc();
   Ty = nullptr;
-  if (ParseType(Ty))
+  if (parseType(Ty))
     return true;
   SMLoc End = Lex.getLoc();
   Read = End.getPointer() - Start.getPointer();
@@ -123,9 +123,9 @@ void LLParser::restoreParsingState(const SlotMapping *Slots) {
         std::make_pair(I.first, std::make_pair(I.second, LocTy())));
 }
 
-/// ValidateEndOfModule - Do final validity and sanity checks at the end of the
+/// validateEndOfModule - Do final validity and sanity checks at the end of the
 /// module.
-bool LLParser::ValidateEndOfModule(bool UpgradeDebugInfo) {
+bool LLParser::validateEndOfModule(bool UpgradeDebugInfo) {
   if (!M)
     return false;
   // Handle any function attribute group forward references.
@@ -190,39 +190,39 @@ bool LLParser::ValidateEndOfModule(bool UpgradeDebugInfo) {
   // If there are entries in ForwardRefBlockAddresses at this point, the
   // function was never defined.
   if (!ForwardRefBlockAddresses.empty())
-    return Error(ForwardRefBlockAddresses.begin()->first.Loc,
+    return error(ForwardRefBlockAddresses.begin()->first.Loc,
                  "expected function name in blockaddress");
 
   for (const auto &NT : NumberedTypes)
     if (NT.second.second.isValid())
-      return Error(NT.second.second,
+      return error(NT.second.second,
                    "use of undefined type '%" + Twine(NT.first) + "'");
 
   for (StringMap<std::pair<Type*, LocTy> >::iterator I =
        NamedTypes.begin(), E = NamedTypes.end(); I != E; ++I)
     if (I->second.second.isValid())
-      return Error(I->second.second,
+      return error(I->second.second,
                    "use of undefined type named '" + I->getKey() + "'");
 
   if (!ForwardRefComdats.empty())
-    return Error(ForwardRefComdats.begin()->second,
+    return error(ForwardRefComdats.begin()->second,
                  "use of undefined comdat '$" +
                      ForwardRefComdats.begin()->first + "'");
 
   if (!ForwardRefVals.empty())
-    return Error(ForwardRefVals.begin()->second.second,
+    return error(ForwardRefVals.begin()->second.second,
                  "use of undefined value '@" + ForwardRefVals.begin()->first +
-                 "'");
+                     "'");
 
   if (!ForwardRefValIDs.empty())
-    return Error(ForwardRefValIDs.begin()->second.second,
+    return error(ForwardRefValIDs.begin()->second.second,
                  "use of undefined value '@" +
-                 Twine(ForwardRefValIDs.begin()->first) + "'");
+                     Twine(ForwardRefValIDs.begin()->first) + "'");
 
   if (!ForwardRefMDNodes.empty())
-    return Error(ForwardRefMDNodes.begin()->second.second,
+    return error(ForwardRefMDNodes.begin()->second.second,
                  "use of undefined metadata '!" +
-                 Twine(ForwardRefMDNodes.begin()->first) + "'");
+                     Twine(ForwardRefMDNodes.begin()->first) + "'");
 
   // Resolve metadata cycles.
   for (auto &N : NumberedMetadata) {
@@ -275,22 +275,22 @@ bool LLParser::ValidateEndOfModule(bool UpgradeDebugInfo) {
 }
 
 /// Do final validity and sanity checks at the end of the index.
-bool LLParser::ValidateEndOfIndex() {
+bool LLParser::validateEndOfIndex() {
   if (!Index)
     return false;
 
   if (!ForwardRefValueInfos.empty())
-    return Error(ForwardRefValueInfos.begin()->second.front().second,
+    return error(ForwardRefValueInfos.begin()->second.front().second,
                  "use of undefined summary '^" +
                      Twine(ForwardRefValueInfos.begin()->first) + "'");
 
   if (!ForwardRefAliasees.empty())
-    return Error(ForwardRefAliasees.begin()->second.front().second,
+    return error(ForwardRefAliasees.begin()->second.front().second,
                  "use of undefined summary '^" +
                      Twine(ForwardRefAliasees.begin()->first) + "'");
 
   if (!ForwardRefTypeIds.empty())
-    return Error(ForwardRefTypeIds.begin()->second.front().second,
+    return error(ForwardRefTypeIds.begin()->second.front().second,
                  "use of undefined type id summary '^" +
                      Twine(ForwardRefTypeIds.begin()->first) + "'");
 
@@ -301,15 +301,15 @@ bool LLParser::ValidateEndOfIndex() {
 // Top-Level Entities
 //===----------------------------------------------------------------------===//
 
-bool LLParser::ParseTargetDefinitions() {
+bool LLParser::parseTargetDefinitions() {
   while (true) {
     switch (Lex.getKind()) {
     case lltok::kw_target:
-      if (ParseTargetDefinition())
+      if (parseTargetDefinition())
         return true;
       break;
     case lltok::kw_source_filename:
-      if (ParseSourceFileName())
+      if (parseSourceFileName())
         return true;
       break;
     default:
@@ -318,7 +318,7 @@ bool LLParser::ParseTargetDefinitions() {
   }
 }
 
-bool LLParser::ParseTopLevelEntities() {
+bool LLParser::parseTopLevelEntities() {
   // If there is no Module, then parse just the summary index entries.
   if (!M) {
     while (true) {
@@ -341,27 +341,64 @@ bool LLParser::ParseTopLevelEntities() {
   }
   while (true) {
     switch (Lex.getKind()) {
-    default:         return TokError("expected top-level entity");
+    default:
+      return tokError("expected top-level entity");
     case lltok::Eof: return false;
-    case lltok::kw_declare: if (ParseDeclare()) return true; break;
-    case lltok::kw_define:  if (ParseDefine()) return true; break;
-    case lltok::kw_module:  if (ParseModuleAsm()) return true; break;
-    case lltok::kw_deplibs: if (ParseDepLibs()) return true; break;
-    case lltok::LocalVarID: if (ParseUnnamedType()) return true; break;
-    case lltok::LocalVar:   if (ParseNamedType()) return true; break;
-    case lltok::GlobalID:   if (ParseUnnamedGlobal()) return true; break;
-    case lltok::GlobalVar:  if (ParseNamedGlobal()) return true; break;
+    case lltok::kw_declare:
+      if (parseDeclare())
+        return true;
+      break;
+    case lltok::kw_define:
+      if (parseDefine())
+        return true;
+      break;
+    case lltok::kw_module:
+      if (parseModuleAsm())
+        return true;
+      break;
+    case lltok::kw_deplibs:
+      if (parseDepLibs())
+        return true;
+      break;
+    case lltok::LocalVarID:
+      if (parseUnnamedType())
+        return true;
+      break;
+    case lltok::LocalVar:
+      if (parseNamedType())
+        return true;
+      break;
+    case lltok::GlobalID:
+      if (parseUnnamedGlobal())
+        return true;
+      break;
+    case lltok::GlobalVar:
+      if (parseNamedGlobal())
+        return true;
+      break;
     case lltok::ComdatVar:  if (parseComdat()) return true; break;
-    case lltok::exclaim:    if (ParseStandaloneMetadata()) return true; break;
+    case lltok::exclaim:
+      if (parseStandaloneMetadata())
+        return true;
+      break;
     case lltok::SummaryID:
-      if (ParseSummaryEntry())
+      if (parseSummaryEntry())
+        return true;
+      break;
+    case lltok::MetadataVar:
+      if (parseNamedMetadata())
+        return true;
+      break;
+    case lltok::kw_attributes:
+      if (parseUnnamedAttrGrp())
+        return true;
+      break;
+    case lltok::kw_uselistorder:
+      if (parseUseListOrder())
         return true;
       break;
-    case lltok::MetadataVar:if (ParseNamedMetadata()) return true; break;
-    case lltok::kw_attributes: if (ParseUnnamedAttrGrp()) return true; break;
-    case lltok::kw_uselistorder: if (ParseUseListOrder()) return true; break;
     case lltok::kw_uselistorder_bb:
-      if (ParseUseListOrderBB())
+      if (parseUseListOrderBB())
         return true;
       break;
     }
@@ -370,13 +407,14 @@ bool LLParser::ParseTopLevelEntities() {
 
 /// toplevelentity
 ///   ::= 'module' 'asm' STRINGCONSTANT
-bool LLParser::ParseModuleAsm() {
+bool LLParser::parseModuleAsm() {
   assert(Lex.getKind() == lltok::kw_module);
   Lex.Lex();
 
   std::string AsmStr;
-  if (ParseToken(lltok::kw_asm, "expected 'module asm'") ||
-      ParseStringConstant(AsmStr)) return true;
+  if (parseToken(lltok::kw_asm, "expected 'module asm'") ||
+      parseStringConstant(AsmStr))
+    return true;
 
   M->appendModuleInlineAsm(AsmStr);
   return false;
@@ -385,22 +423,23 @@ bool LLParser::ParseModuleAsm() {
 /// toplevelentity
 ///   ::= 'target' 'triple' '=' STRINGCONSTANT
 ///   ::= 'target' 'datalayout' '=' STRINGCONSTANT
-bool LLParser::ParseTargetDefinition() {
+bool LLParser::parseTargetDefinition() {
   assert(Lex.getKind() == lltok::kw_target);
   std::string Str;
   switch (Lex.Lex()) {
-  default: return TokError("unknown target property");
+  default:
+    return tokError("unknown target property");
   case lltok::kw_triple:
     Lex.Lex();
-    if (ParseToken(lltok::equal, "expected '=' after target triple") ||
-        ParseStringConstant(Str))
+    if (parseToken(lltok::equal, "expected '=' after target triple") ||
+        parseStringConstant(Str))
       return true;
     M->setTargetTriple(Str);
     return false;
   case lltok::kw_datalayout:
     Lex.Lex();
-    if (ParseToken(lltok::equal, "expected '=' after target datalayout") ||
-        ParseStringConstant(Str))
+    if (parseToken(lltok::equal, "expected '=' after target datalayout") ||
+        parseStringConstant(Str))
       return true;
     M->setDataLayout(Str);
     return false;
@@ -409,11 +448,11 @@ bool LLParser::ParseTargetDefinition() {
 
 /// toplevelentity
 ///   ::= 'source_filename' '=' STRINGCONSTANT
-bool LLParser::ParseSourceFileName() {
+bool LLParser::parseSourceFileName() {
   assert(Lex.getKind() == lltok::kw_source_filename);
   Lex.Lex();
-  if (ParseToken(lltok::equal, "expected '=' after source_filename") ||
-      ParseStringConstant(SourceFileName))
+  if (parseToken(lltok::equal, "expected '=' after source_filename") ||
+      parseStringConstant(SourceFileName))
     return true;
   if (M)
     M->setSourceFileName(SourceFileName);
@@ -436,31 +475,32 @@ bool LLParser::ParseDepLibs() {
 
   do {
     std::string Str;
-    if (ParseStringConstant(Str)) return true;
+    if (parseStringConstant(Str))
+      return true;
   } while (EatIfPresent(lltok::comma));
 
-  return ParseToken(lltok::rsquare, "expected ']' at end of list");
+  return parseToken(lltok::rsquare, "expected ']' at end of list");
 }
 
-/// ParseUnnamedType:
+/// parseUnnamedType:
 ///   ::= LocalVarID '=' 'type' type
-bool LLParser::ParseUnnamedType() {
+bool LLParser::parseUnnamedType() {
   LocTy TypeLoc = Lex.getLoc();
   unsigned TypeID = Lex.getUIntVal();
   Lex.Lex(); // eat LocalVarID;
 
-  if (ParseToken(lltok::equal, "expected '=' after name") ||
-      ParseToken(lltok::kw_type, "expected 'type' after '='"))
+  if (parseToken(lltok::equal, "expected '=' after name") ||
+      parseToken(lltok::kw_type, "expected 'type' after '='"))
     return true;
 
   Type *Result = nullptr;
-  if (ParseStructDefinition(TypeLoc, "",
-                            NumberedTypes[TypeID], Result)) return true;
+  if (parseStructDefinition(TypeLoc, "", NumberedTypes[TypeID], Result))
+    return true;
 
   if (!isa<StructType>(Result)) {
     std::pair<Type*, LocTy> &Entry = NumberedTypes[TypeID];
     if (Entry.first)
-      return Error(TypeLoc, "non-struct types may not be recursive");
+      return error(TypeLoc, "non-struct types may not be recursive");
     Entry.first = Result;
     Entry.second = SMLoc();
   }
@@ -470,23 +510,23 @@ bool LLParser::ParseUnnamedType() {
 
 /// toplevelentity
 ///   ::= LocalVar '=' 'type' type
-bool LLParser::ParseNamedType() {
+bool LLParser::parseNamedType() {
   std::string Name = Lex.getStrVal();
   LocTy NameLoc = Lex.getLoc();
   Lex.Lex();  // eat LocalVar.
 
-  if (ParseToken(lltok::equal, "expected '=' after name") ||
-      ParseToken(lltok::kw_type, "expected 'type' after name"))
+  if (parseToken(lltok::equal, "expected '=' after name") ||
+      parseToken(lltok::kw_type, "expected 'type' after name"))
     return true;
 
   Type *Result = nullptr;
-  if (ParseStructDefinition(NameLoc, Name,
-                            NamedTypes[Name], Result)) return true;
+  if (parseStructDefinition(NameLoc, Name, NamedTypes[Name], Result))
+    return true;
 
   if (!isa<StructType>(Result)) {
     std::pair<Type*, LocTy> &Entry = NamedTypes[Name];
     if (Entry.first)
-      return Error(NameLoc, "non-struct types may not be recursive");
+      return error(NameLoc, "non-struct types may not be recursive");
     Entry.first = Result;
     Entry.second = SMLoc();
   }
@@ -519,33 +559,32 @@ bool LLParser::ParseDeclare() {
 
 /// toplevelentity
 ///   ::= 'define' FunctionHeader (!dbg !56)* '{' ...
-bool LLParser::ParseDefine() {
+bool LLParser::parseDefine() {
   assert(Lex.getKind() == lltok::kw_define);
   Lex.Lex();
 
   Function *F;
-  return ParseFunctionHeader(F, true) ||
-         ParseOptionalFunctionMetadata(*F) ||
-         ParseFunctionBody(*F);
+  return parseFunctionHeader(F, true) || parseOptionalFunctionMetadata(*F) ||
+         parseFunctionBody(*F);
 }
 
-/// ParseGlobalType
+/// parseGlobalType
 ///   ::= 'constant'
 ///   ::= 'global'
-bool LLParser::ParseGlobalType(bool &IsConstant) {
+bool LLParser::parseGlobalType(bool &IsConstant) {
   if (Lex.getKind() == lltok::kw_constant)
     IsConstant = true;
   else if (Lex.getKind() == lltok::kw_global)
     IsConstant = false;
   else {
     IsConstant = false;
-    return TokError("expected 'global' or 'constant'");
+    return tokError("expected 'global' or 'constant'");
   }
   Lex.Lex();
   return false;
 }
 
-bool LLParser::ParseOptionalUnnamedAddr(
+bool LLParser::parseOptionalUnnamedAddr(
     GlobalVariable::UnnamedAddr &UnnamedAddr) {
   if (EatIfPresent(lltok::kw_unnamed_addr))
     UnnamedAddr = GlobalValue::UnnamedAddr::Global;
@@ -556,16 +595,17 @@ bool LLParser::ParseOptionalUnnamedAddr(
   return false;
 }
 
-/// ParseUnnamedGlobal:
+/// parseUnnamedGlobal:
 ///   OptionalVisibility (ALIAS | IFUNC) ...
 ///   OptionalLinkage OptionalPreemptionSpecifier OptionalVisibility
 ///   OptionalDLLStorageClass
 ///                                                     ...   -> global variable
 ///   GlobalID '=' OptionalVisibility (ALIAS | IFUNC) ...
-///   GlobalID '=' OptionalLinkage OptionalPreemptionSpecifier OptionalVisibility
+///   GlobalID '=' OptionalLinkage OptionalPreemptionSpecifier
+///   OptionalVisibility
 ///                OptionalDLLStorageClass
 ///                                                     ...   -> global variable
-bool LLParser::ParseUnnamedGlobal() {
+bool LLParser::parseUnnamedGlobal() {
   unsigned VarID = NumberedVals.size();
   std::string Name;
   LocTy NameLoc = Lex.getLoc();
@@ -586,25 +626,25 @@ bool LLParser::ParseUnnamedGlobal() {
   bool DSOLocal;
   GlobalVariable::ThreadLocalMode TLM;
   GlobalVariable::UnnamedAddr UnnamedAddr;
-  if (ParseOptionalLinkage(Linkage, HasLinkage, Visibility, DLLStorageClass,
+  if (parseOptionalLinkage(Linkage, HasLinkage, Visibility, DLLStorageClass,
                            DSOLocal) ||
-      ParseOptionalThreadLocal(TLM) || ParseOptionalUnnamedAddr(UnnamedAddr))
+      parseOptionalThreadLocal(TLM) || parseOptionalUnnamedAddr(UnnamedAddr))
     return true;
 
   if (Lex.getKind() != lltok::kw_alias && Lex.getKind() != lltok::kw_ifunc)
-    return ParseGlobal(Name, NameLoc, Linkage, HasLinkage, Visibility,
+    return parseGlobal(Name, NameLoc, Linkage, HasLinkage, Visibility,
                        DLLStorageClass, DSOLocal, TLM, UnnamedAddr);
 
   return parseIndirectSymbol(Name, NameLoc, Linkage, Visibility,
                              DLLStorageClass, DSOLocal, TLM, UnnamedAddr);
 }
 
-/// ParseNamedGlobal:
+/// parseNamedGlobal:
 ///   GlobalVar '=' OptionalVisibility (ALIAS | IFUNC) ...
 ///   GlobalVar '=' OptionalLinkage OptionalPreemptionSpecifier
 ///                 OptionalVisibility OptionalDLLStorageClass
 ///                                                     ...   -> global variable
-bool LLParser::ParseNamedGlobal() {
+bool LLParser::parseNamedGlobal() {
   assert(Lex.getKind() == lltok::GlobalVar);
   LocTy NameLoc = Lex.getLoc();
   std::string Name = Lex.getStrVal();
@@ -615,14 +655,14 @@ bool LLParser::ParseNamedGlobal() {
   bool DSOLocal;
   GlobalVariable::ThreadLocalMode TLM;
   GlobalVariable::UnnamedAddr UnnamedAddr;
-  if (ParseToken(lltok::equal, "expected '=' in global variable") ||
-      ParseOptionalLinkage(Linkage, HasLinkage, Visibility, DLLStorageClass,
+  if (parseToken(lltok::equal, "expected '=' in global variable") ||
+      parseOptionalLinkage(Linkage, HasLinkage, Visibility, DLLStorageClass,
                            DSOLocal) ||
-      ParseOptionalThreadLocal(TLM) || ParseOptionalUnnamedAddr(UnnamedAddr))
+      parseOptionalThreadLocal(TLM) || parseOptionalUnnamedAddr(UnnamedAddr))
     return true;
 
   if (Lex.getKind() != lltok::kw_alias && Lex.getKind() != lltok::kw_ifunc)
-    return ParseGlobal(Name, NameLoc, Linkage, HasLinkage, Visibility,
+    return parseGlobal(Name, NameLoc, Linkage, HasLinkage, Visibility,
                        DLLStorageClass, DSOLocal, TLM, UnnamedAddr);
 
   return parseIndirectSymbol(Name, NameLoc, Linkage, Visibility,
@@ -681,20 +721,21 @@ bool LLParser::parseComdat() {
 
 // MDString:
 //   ::= '!' STRINGCONSTANT
-bool LLParser::ParseMDString(MDString *&Result) {
+bool LLParser::parseMDString(MDString *&Result) {
   std::string Str;
-  if (ParseStringConstant(Str)) return true;
+  if (parseStringConstant(Str))
+    return true;
   Result = MDString::get(Context, Str);
   return false;
 }
 
 // MDNode:
 //   ::= '!' MDNodeNumber
-bool LLParser::ParseMDNodeID(MDNode *&Result) {
+bool LLParser::parseMDNodeID(MDNode *&Result) {
   // !{ ..., !42, ... }
   LocTy IDLoc = Lex.getLoc();
   unsigned MID = 0;
-  if (ParseUInt32(MID))
+  if (parseUInt32(MID))
     return true;
 
   // If not a forward reference, just return it now.
@@ -712,61 +753,60 @@ bool LLParser::ParseMDNodeID(MDNode *&Result) {
   return false;
 }
 
-/// ParseNamedMetadata:
+/// parseNamedMetadata:
 ///   !foo = !{ !1, !2 }
-bool LLParser::ParseNamedMetadata() {
+bool LLParser::parseNamedMetadata() {
   assert(Lex.getKind() == lltok::MetadataVar);
   std::string Name = Lex.getStrVal();
   Lex.Lex();
 
-  if (ParseToken(lltok::equal, "expected '=' here") ||
-      ParseToken(lltok::exclaim, "Expected '!' here") ||
-      ParseToken(lltok::lbrace, "Expected '{' here"))
+  if (parseToken(lltok::equal, "expected '=' here") ||
+      parseToken(lltok::exclaim, "Expected '!' here") ||
+      parseToken(lltok::lbrace, "Expected '{' here"))
     return true;
 
   NamedMDNode *NMD = M->getOrInsertNamedMetadata(Name);
   if (Lex.getKind() != lltok::rbrace)
     do {
       MDNode *N = nullptr;
-      // Parse DIExpressions inline as a special case. They are still MDNodes,
+      // parse DIExpressions inline as a special case. They are still MDNodes,
       // so they can still appear in named metadata. Remove this logic if they
       // become plain Metadata.
       if (Lex.getKind() == lltok::MetadataVar &&
           Lex.getStrVal() == "DIExpression") {
-        if (ParseDIExpression(N, /*IsDistinct=*/false))
+        if (parseDIExpression(N, /*IsDistinct=*/false))
           return true;
-      } else if (ParseToken(lltok::exclaim, "Expected '!' here") ||
-                 ParseMDNodeID(N)) {
+      } else if (parseToken(lltok::exclaim, "Expected '!' here") ||
+                 parseMDNodeID(N)) {
         return true;
       }
       NMD->addOperand(N);
     } while (EatIfPresent(lltok::comma));
 
-  return ParseToken(lltok::rbrace, "expected end of metadata node");
+  return parseToken(lltok::rbrace, "expected end of metadata node");
 }
 
-/// ParseStandaloneMetadata:
+/// parseStandaloneMetadata:
 ///   !42 = !{...}
-bool LLParser::ParseStandaloneMetadata() {
+bool LLParser::parseStandaloneMetadata() {
   assert(Lex.getKind() == lltok::exclaim);
   Lex.Lex();
   unsigned MetadataID = 0;
 
   MDNode *Init;
-  if (ParseUInt32(MetadataID) ||
-      ParseToken(lltok::equal, "expected '=' here"))
+  if (parseUInt32(MetadataID) || parseToken(lltok::equal, "expected '=' here"))
     return true;
 
   // Detect common error, from old metadata syntax.
   if (Lex.getKind() == lltok::Type)
-    return TokError("unexpected type in metadata definition");
+    return tokError("unexpected type in metadata definition");
 
   bool IsDistinct = EatIfPresent(lltok::kw_distinct);
   if (Lex.getKind() == lltok::MetadataVar) {
-    if (ParseSpecializedMDNode(Init, IsDistinct))
+    if (parseSpecializedMDNode(Init, IsDistinct))
       return true;
-  } else if (ParseToken(lltok::exclaim, "Expected '!' here") ||
-             ParseMDTuple(Init, IsDistinct))
+  } else if (parseToken(lltok::exclaim, "Expected '!' here") ||
+             parseMDTuple(Init, IsDistinct))
     return true;
 
   // See if this was forward referenced, if so, handle it.
@@ -786,18 +826,25 @@ bool LLParser::ParseStandaloneMetadata() {
 }
 
 // Skips a single module summary entry.
-bool LLParser::SkipModuleSummaryEntry() {
+bool LLParser::skipModuleSummaryEntry() {
   // Each module summary entry consists of a tag for the entry
-  // type, followed by a colon, then the fields surrounded by nested sets of
-  // parentheses. The "tag:" looks like a Label. Once parsing support is
-  // in place we will look for the tokens corresponding to the expected tags.
+  // type, followed by a colon, then the fields which may be surrounded by
+  // nested sets of parentheses. The "tag:" looks like a Label. Once parsing
+  // support is in place we will look for the tokens corresponding to the
+  // expected tags.
   if (Lex.getKind() != lltok::kw_gv && Lex.getKind() != lltok::kw_module &&
-      Lex.getKind() != lltok::kw_typeid)
-    return TokError(
-        "Expected 'gv', 'module', or 'typeid' at the start of summary entry");
+      Lex.getKind() != lltok::kw_typeid && Lex.getKind() != lltok::kw_flags &&
+      Lex.getKind() != lltok::kw_blockcount)
+    return tokError(
+        "Expected 'gv', 'module', 'typeid', 'flags' or 'blockcount' at the "
+        "start of summary entry");
+  if (Lex.getKind() == lltok::kw_flags)
+    return parseSummaryIndexFlags();
+  if (Lex.getKind() == lltok::kw_blockcount)
+    return parseBlockCount();
   Lex.Lex();
-  if (ParseToken(lltok::colon, "expected ':' at start of summary entry") ||
-      ParseToken(lltok::lparen, "expected '(' at start of summary entry"))
+  if (parseToken(lltok::colon, "expected ':' at start of summary entry") ||
+      parseToken(lltok::lparen, "expected '(' at start of summary entry"))
     return true;
   // Now walk through the parenthesized entry, until the number of open
   // parentheses goes back down to 0 (the first '(' was parsed above).
@@ -928,33 +975,31 @@ bool LLParser::parseIndirectSymbol(const std::string &Name, LocTy NameLoc,
       Lex.getKind() != lltok::kw_getelementptr &&
       Lex.getKind() != lltok::kw_addrspacecast &&
       Lex.getKind() != lltok::kw_inttoptr) {
-    if (ParseGlobalTypeAndValue(Aliasee))
+    if (parseGlobalTypeAndValue(Aliasee))
       return true;
   } else {
     // The bitcast dest type is not present, it is implied by the dest type.
     ValID ID;
-    if (ParseValID(ID))
+    if (parseValID(ID))
       return true;
     if (ID.Kind != ValID::t_Constant)
-      return Error(AliaseeLoc, "invalid aliasee");
+      return error(AliaseeLoc, "invalid aliasee");
     Aliasee = ID.ConstantVal;
   }
 
   Type *AliaseeType = Aliasee->getType();
   auto *PTy = dyn_cast<PointerType>(AliaseeType);
   if (!PTy)
-    return Error(AliaseeLoc, "An alias or ifunc must have pointer type");
+    return error(AliaseeLoc, "An alias or ifunc must have pointer type");
   unsigned AddrSpace = PTy->getAddressSpace();
 
   if (IsAlias && Ty != PTy->getElementType())
-    return Error(
-        ExplicitTypeLoc,
-        "explicit pointee type doesn't match operand's pointee type");
+    return error(ExplicitTypeLoc,
+                 "explicit pointee type doesn't match operand's pointee type");
 
   if (!IsAlias && !PTy->getElementType()->isFunctionTy())
-    return Error(
-        ExplicitTypeLoc,
-        "explicit pointee type should be a function type");
+    return error(ExplicitTypeLoc,
+                 "explicit pointee type should be a function type");
 
   GlobalValue *GVal = nullptr;
 
@@ -1131,26 +1176,27 @@ bool LLParser::ParseGlobal(const std::string &Name, LocTy NameLoc,
   GV->setThreadLocalMode(TLM);
   GV->setUnnamedAddr(UnnamedAddr);
 
-  // Parse attributes on the global.
+  // parse attributes on the global.
   while (Lex.getKind() == lltok::comma) {
     Lex.Lex();
 
     if (Lex.getKind() == lltok::kw_section) {
       Lex.Lex();
       GV->setSection(Lex.getStrVal());
-      if (ParseToken(lltok::StringConstant, "expected global section string"))
+      if (parseToken(lltok::StringConstant, "expected global section string"))
         return true;
     } else if (Lex.getKind() == lltok::kw_partition) {
       Lex.Lex();
       GV->setPartition(Lex.getStrVal());
-      if (ParseToken(lltok::StringConstant, "expected partition string"))
+      if (parseToken(lltok::StringConstant, "expected partition string"))
         return true;
     } else if (Lex.getKind() == lltok::kw_align) {
       MaybeAlign Alignment;
-      if (ParseOptionalAlignment(Alignment)) return true;
+      if (parseOptionalAlignment(Alignment))
+        return true;
       GV->setAlignment(Alignment);
     } else if (Lex.getKind() == lltok::MetadataVar) {
-      if (ParseGlobalObjectMetadataAttachment(*GV))
+      if (parseGlobalObjectMetadataAttachment(*GV))
         return true;
     } else {
       Comdat *C;
@@ -1176,37 +1222,37 @@ bool LLParser::ParseGlobal(const std::string &Name, LocTy NameLoc,
   return false;
 }
 
-/// ParseUnnamedAttrGrp
+/// parseUnnamedAttrGrp
 ///   ::= 'attributes' AttrGrpID '=' '{' AttrValPair+ '}'
-bool LLParser::ParseUnnamedAttrGrp() {
+bool LLParser::parseUnnamedAttrGrp() {
   assert(Lex.getKind() == lltok::kw_attributes);
   LocTy AttrGrpLoc = Lex.getLoc();
   Lex.Lex();
 
   if (Lex.getKind() != lltok::AttrGrpID)
-    return TokError("expected attribute group id");
+    return tokError("expected attribute group id");
 
   unsigned VarID = Lex.getUIntVal();
   std::vector<unsigned> unused;
   LocTy BuiltinLoc;
   Lex.Lex();
 
-  if (ParseToken(lltok::equal, "expected '=' here") ||
-      ParseToken(lltok::lbrace, "expected '{' here") ||
-      ParseFnAttributeValuePairs(NumberedAttrBuilders[VarID], unused, true,
+  if (parseToken(lltok::equal, "expected '=' here") ||
+      parseToken(lltok::lbrace, "expected '{' here") ||
+      parseFnAttributeValuePairs(NumberedAttrBuilders[VarID], unused, true,
                                  BuiltinLoc) ||
-      ParseToken(lltok::rbrace, "expected end of attribute group"))
+      parseToken(lltok::rbrace, "expected end of attribute group"))
     return true;
 
   if (!NumberedAttrBuilders[VarID].hasAttributes())
-    return Error(AttrGrpLoc, "attribute group has no attributes");
+    return error(AttrGrpLoc, "attribute group has no attributes");
 
   return false;
 }
 
-/// ParseFnAttributeValuePairs
+/// parseFnAttributeValuePairs
 ///   ::= <attr> | <attr> '=' <value>
-bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
+bool LLParser::parseFnAttributeValuePairs(AttrBuilder &B,
                                           std::vector<unsigned> &FwdRefAttrGrps,
                                           bool inAttrGrp, LocTy &BuiltinLoc) {
   bool HaveError = false;
@@ -1294,6 +1340,7 @@ bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
     case lltok::kw_argmemonly: B.addAttribute(Attribute::ArgMemOnly); break;
     case lltok::kw_builtin: B.addAttribute(Attribute::Builtin); break;
     case lltok::kw_cold: B.addAttribute(Attribute::Cold); break;
+    case lltok::kw_hot: B.addAttribute(Attribute::Hot); break;
     case lltok::kw_convergent: B.addAttribute(Attribute::Convergent); break;
     case lltok::kw_inaccessiblememonly:
       B.addAttribute(Attribute::InaccessibleMemOnly); break;
@@ -1302,8 +1349,14 @@ bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
     case lltok::kw_inlinehint: B.addAttribute(Attribute::InlineHint); break;
     case lltok::kw_jumptable: B.addAttribute(Attribute::JumpTable); break;
     case lltok::kw_minsize: B.addAttribute(Attribute::MinSize); break;
+    case lltok::kw_mustprogress:
+      B.addAttribute(Attribute::MustProgress);
+      break;
     case lltok::kw_naked: B.addAttribute(Attribute::Naked); break;
     case lltok::kw_nobuiltin: B.addAttribute(Attribute::NoBuiltin); break;
+    case lltok::kw_nocallback:
+      B.addAttribute(Attribute::NoCallback);
+      break;
     case lltok::kw_noduplicate: B.addAttribute(Attribute::NoDuplicate); break;
     case lltok::kw_nofree: B.addAttribute(Attribute::NoFree); break;
     case lltok::kw_noimplicitfloat:
@@ -1315,6 +1368,7 @@ bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
     case lltok::kw_noreturn: B.addAttribute(Attribute::NoReturn); break;
     case lltok::kw_nosync: B.addAttribute(Attribute::NoSync); break;
     case lltok::kw_nocf_check: B.addAttribute(Attribute::NoCfCheck); break;
+    case lltok::kw_noprofile: B.addAttribute(Attribute::NoProfile); break;
     case lltok::kw_norecurse: B.addAttribute(Attribute::NoRecurse); break;
     case lltok::kw_nounwind: B.addAttribute(Attribute::NoUnwind); break;
     case lltok::kw_null_pointer_is_valid:
@@ -1382,13 +1435,14 @@ bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
     case lltok::kw_swifterror:
     case lltok::kw_swiftself:
     case lltok::kw_immarg:
+    case lltok::kw_byref:
       HaveError |=
-        Error(Lex.getLoc(),
-              "invalid use of parameter-only attribute on a function");
+          error(Lex.getLoc(),
+                "invalid use of parameter-only attribute on a function");
       break;
     }
 
-    // ParsePreallocated() consumes token
+    // parsePreallocated() consumes token
     if (Token != lltok::kw_preallocated)
       Lex.Lex();
   }
@@ -1424,22 +1478,22 @@ Value *LLParser::checkValidVariableType(LocTy Loc, const Twine &Name, Type *Ty,
       return Val;
   }
   if (Ty->isLabelTy())
-    Error(Loc, "'" + Name + "' is not a basic block");
+    error(Loc, "'" + Name + "' is not a basic block");
   else
-    Error(Loc, "'" + Name + "' defined with type '" +
+    error(Loc, "'" + Name + "' defined with type '" +
                    getTypeString(Val->getType()) + "' but expected '" +
                    getTypeString(SuggestedTy) + "'");
   return nullptr;
 }
 
-/// GetGlobalVal - Get a value with the specified name or ID, creating a
+/// getGlobalVal - Get a value with the specified name or ID, creating a
 /// forward reference record if needed.  This can return null if the value
 /// exists but does not have the right type.
-GlobalValue *LLParser::GetGlobalVal(const std::string &Name, Type *Ty,
+GlobalValue *LLParser::getGlobalVal(const std::string &Name, Type *Ty,
                                     LocTy Loc, bool IsCall) {
   PointerType *PTy = dyn_cast<PointerType>(Ty);
   if (!PTy) {
-    Error(Loc, "global variable reference must have pointer type");
+    error(Loc, "global variable reference must have pointer type");
     return nullptr;
   }
 
@@ -1466,11 +1520,11 @@ GlobalValue *LLParser::GetGlobalVal(const std::string &Name, Type *Ty,
   return FwdVal;
 }
 
-GlobalValue *LLParser::GetGlobalVal(unsigned ID, Type *Ty, LocTy Loc,
+GlobalValue *LLParser::getGlobalVal(unsigned ID, Type *Ty, LocTy Loc,
                                     bool IsCall) {
   PointerType *PTy = dyn_cast<PointerType>(Ty);
   if (!PTy) {
-    Error(Loc, "global variable reference must have pointer type");
+    error(Loc, "global variable reference must have pointer type");
     return nullptr;
   }
 
@@ -1516,56 +1570,56 @@ Comdat *LLParser::getComdat(const std::string &Name, LocTy Loc) {
 // Helper Routines.
 //===----------------------------------------------------------------------===//
 
-/// ParseToken - If the current token has the specified kind, eat it and return
+/// parseToken - If the current token has the specified kind, eat it and return
 /// success.  Otherwise, emit the specified error and return failure.
-bool LLParser::ParseToken(lltok::Kind T, const char *ErrMsg) {
+bool LLParser::parseToken(lltok::Kind T, const char *ErrMsg) {
   if (Lex.getKind() != T)
-    return TokError(ErrMsg);
+    return tokError(ErrMsg);
   Lex.Lex();
   return false;
 }
 
-/// ParseStringConstant
+/// parseStringConstant
 ///   ::= StringConstant
-bool LLParser::ParseStringConstant(std::string &Result) {
+bool LLParser::parseStringConstant(std::string &Result) {
   if (Lex.getKind() != lltok::StringConstant)
-    return TokError("expected string constant");
+    return tokError("expected string constant");
   Result = Lex.getStrVal();
   Lex.Lex();
   return false;
 }
 
-/// ParseUInt32
+/// parseUInt32
 ///   ::= uint32
-bool LLParser::ParseUInt32(uint32_t &Val) {
+bool LLParser::parseUInt32(uint32_t &Val) {
   if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned())
-    return TokError("expected integer");
+    return tokError("expected integer");
   uint64_t Val64 = Lex.getAPSIntVal().getLimitedValue(0xFFFFFFFFULL+1);
   if (Val64 != unsigned(Val64))
-    return TokError("expected 32-bit integer (too large)");
+    return tokError("expected 32-bit integer (too large)");
   Val = Val64;
   Lex.Lex();
   return false;
 }
 
-/// ParseUInt64
+/// parseUInt64
 ///   ::= uint64
-bool LLParser::ParseUInt64(uint64_t &Val) {
+bool LLParser::parseUInt64(uint64_t &Val) {
   if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned())
-    return TokError("expected integer");
+    return tokError("expected integer");
   Val = Lex.getAPSIntVal().getLimitedValue();
   Lex.Lex();
   return false;
 }
 
-/// ParseTLSModel
+/// parseTLSModel
 ///   := 'localdynamic'
 ///   := 'initialexec'
 ///   := 'localexec'
-bool LLParser::ParseTLSModel(GlobalVariable::ThreadLocalMode &TLM) {
+bool LLParser::parseTLSModel(GlobalVariable::ThreadLocalMode &TLM) {
   switch (Lex.getKind()) {
     default:
-      return TokError("expected localdynamic, initialexec or localexec");
+      return tokError("expected localdynamic, initialexec or localexec");
     case lltok::kw_localdynamic:
       TLM = GlobalVariable::LocalDynamicTLSModel;
       break;

@@ -1593,39 +1647,40 @@ bool LLParser::ParseOptionalThreadLocal(GlobalVariable::ThreadLocalMode &TLM) {
   TLM = GlobalVariable::GeneralDynamicTLSModel;
   if (Lex.getKind() == lltok::lparen) {
     Lex.Lex();
-    return ParseTLSModel(TLM) ||
-      ParseToken(lltok::rparen, "expected ')' after thread local model");
+    return parseTLSModel(TLM) ||
+           parseToken(lltok::rparen, "expected ')' after thread local model");
   }
   return false;
 }
 
-/// ParseOptionalAddrSpace
+/// parseOptionalAddrSpace
 ///   := /*empty*/
 ///   := 'addrspace' '(' uint32 ')'
-bool LLParser::ParseOptionalAddrSpace(unsigned &AddrSpace, unsigned DefaultAS) {
+bool LLParser::parseOptionalAddrSpace(unsigned &AddrSpace, unsigned DefaultAS) {
   AddrSpace = DefaultAS;
   if (!EatIfPresent(lltok::kw_addrspace))
     return false;
-  return ParseToken(lltok::lparen, "expected '(' in address space") ||
-         ParseUInt32(AddrSpace) ||
-         ParseToken(lltok::rparen, "expected ')' in address space");
+  return parseToken(lltok::lparen, "expected '(' in address space") ||
+         parseUInt32(AddrSpace) ||
+         parseToken(lltok::rparen, "expected ')' in address space");
 }
 
-/// ParseStringAttribute
+/// parseStringAttribute
 ///   := StringConstant
 ///   := StringConstant '=' StringConstant
-bool LLParser::ParseStringAttribute(AttrBuilder &B) {
+bool LLParser::parseStringAttribute(AttrBuilder &B) {
   std::string Attr = Lex.getStrVal();
   Lex.Lex();
   std::string Val;
-  if (EatIfPresent(lltok::equal) && ParseStringConstant(Val))
+  if (EatIfPresent(lltok::equal) && parseStringConstant(Val))
     return true;
   B.addAttribute(Attr, Val);
   return false;
 }
 
-/// ParseOptionalParamAttrs - Parse a potentially empty list of parameter attributes.
-bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
+/// parseOptionalParamAttrs - parse a potentially empty list of parameter
+/// attributes.
+bool LLParser::parseOptionalParamAttrs(AttrBuilder &B) {
   bool HaveError = false;
 
   B.clear();
@@ -1636,45 +1691,59 @@ bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
     default:  // End of attributes.
       return HaveError;
     case lltok::StringConstant: {
-      if (ParseStringAttribute(B))
+      if (parseStringAttribute(B))
         return true;
       continue;
     }
     case lltok::kw_align: {
       MaybeAlign Alignment;
-      if (ParseOptionalAlignment(Alignment, true))
+      if (parseOptionalAlignment(Alignment, true))
         return true;
       B.addAlignmentAttr(Alignment);
       continue;
     }
     case lltok::kw_byval: {
       Type *Ty;
-      if (ParseByValWithOptionalType(Ty))
+      if (parseRequiredTypeAttr(Ty, lltok::kw_byval))
         return true;
       B.addByValAttr(Ty);
       continue;
     }
+    case lltok::kw_sret: {
+      Type *Ty;
+      if (parseRequiredTypeAttr(Ty, lltok::kw_sret))
+        return true;
+      B.addStructRetAttr(Ty);
+      continue;
+    }
     case lltok::kw_preallocated: {
       Type *Ty;
-      if (ParsePreallocated(Ty))
+      if (parsePreallocated(Ty))
         return true;
       B.addPreallocatedAttr(Ty);
       continue;
     }
     case lltok::kw_dereferenceable: {
       uint64_t Bytes;
-      if (ParseOptionalDerefAttrBytes(lltok::kw_dereferenceable, Bytes))
+      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable, Bytes))
         return true;
       B.addDereferenceableAttr(Bytes);
       continue;
     }
     case lltok::kw_dereferenceable_or_null: {
       uint64_t Bytes;
-      if (ParseOptionalDerefAttrBytes(lltok::kw_dereferenceable_or_null, Bytes))
+      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable_or_null, Bytes))
         return true;
       B.addDereferenceableOrNullAttr(Bytes);
       continue;
     }
+    case lltok::kw_byref: {
+      Type *Ty;
+      if (parseByRef(Ty))
+        return true;
+      B.addByRefAttr(Ty);
+      continue;
+    }
     case lltok::kw_inalloca:        B.addAttribute(Attribute::InAlloca); break;
     case lltok::kw_inreg:           B.addAttribute(Attribute::InReg); break;
     case lltok::kw_nest:            B.addAttribute(Attribute::Nest); break;
@@ -1689,7 +1758,6 @@ bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
     case lltok::kw_readonly:        B.addAttribute(Attribute::ReadOnly); break;
     case lltok::kw_returned:        B.addAttribute(Attribute::Returned); break;
     case lltok::kw_signext:         B.addAttribute(Attribute::SExt); break;
-    case lltok::kw_sret:            B.addAttribute(Attribute::StructRet); break;
     case lltok::kw_swifterror:      B.addAttribute(Attribute::SwiftError); break;
     case lltok::kw_swiftself:       B.addAttribute(Attribute::SwiftSelf); break;
     case lltok::kw_writeonly:       B.addAttribute(Attribute::WriteOnly); break;
@@ -1703,6 +1771,7 @@ bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
     case lltok::kw_inlinehint:
     case lltok::kw_jumptable:
     case lltok::kw_minsize:
+    case lltok::kw_mustprogress:
     case lltok::kw_naked:
     case lltok::kw_nobuiltin:
     case lltok::kw_noduplicate:
@@ -1710,6 +1779,7 @@ bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
     case lltok::kw_noinline:
     case lltok::kw_nonlazybind:
     case lltok::kw_nomerge:
+    case lltok::kw_noprofile:
     case lltok::kw_noredzone:
     case lltok::kw_noreturn:
     case lltok::kw_nocf_check:
@@ -1731,7 +1801,8 @@ bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
     case lltok::kw_shadowcallstack:
     case lltok::kw_strictfp:
     case lltok::kw_uwtable:
-      HaveError |= Error(Lex.getLoc(), "invalid use of function-only attribute");
+      HaveError |=
+          error(Lex.getLoc(), "invalid use of function-only attribute");
       break;
     }
 
@@ -1751,27 +1823,27 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     default:  // End of attributes.
       return HaveError;
     case lltok::StringConstant: {
-      if (ParseStringAttribute(B))
+      if (parseStringAttribute(B))
         return true;
       continue;
     }
     case lltok::kw_dereferenceable: {
       uint64_t Bytes;
-      if (ParseOptionalDerefAttrBytes(lltok::kw_dereferenceable, Bytes))
+      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable, Bytes))
         return true;
       B.addDereferenceableAttr(Bytes);
       continue;
     }
     case lltok::kw_dereferenceable_or_null: {
       uint64_t Bytes;
-      if (ParseOptionalDerefAttrBytes(lltok::kw_dereferenceable_or_null, Bytes))
+      if (parseOptionalDerefAttrBytes(lltok::kw_dereferenceable_or_null, Bytes))
         return true;
       B.addDereferenceableOrNullAttr(Bytes);
       continue;
     }
     case lltok::kw_align: {
       MaybeAlign Alignment;
-      if (ParseOptionalAlignment(Alignment))
+      if (parseOptionalAlignment(Alignment))
         return true;
       B.addAlignmentAttr(Alignment);
       continue;
@@ -1785,7 +1857,7 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     case lltok::kw_signext:         B.addAttribute(Attribute::SExt); break;
     case lltok::kw_zeroext:         B.addAttribute(Attribute::ZExt); break;
 
-    // Error handling.
+    // error handling.
     case lltok::kw_byval:
     case lltok::kw_inalloca:
     case lltok::kw_nest:
@@ -1795,7 +1867,9 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     case lltok::kw_swifterror:
     case lltok::kw_swiftself:
     case lltok::kw_immarg:
-      HaveError |= Error(Lex.getLoc(), "invalid use of parameter-only attribute");
+    case lltok::kw_byref:
+      HaveError |=
+          error(Lex.getLoc(), "invalid use of parameter-only attribute");
       break;
 
     case lltok::kw_alignstack:
@@ -1806,6 +1880,7 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     case lltok::kw_inlinehint:
     case lltok::kw_jumptable:
     case lltok::kw_minsize:
+    case lltok::kw_mustprogress:
     case lltok::kw_naked:
     case lltok::kw_nobuiltin:
     case lltok::kw_noduplicate:
@@ -1813,6 +1888,7 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     case lltok::kw_noinline:
     case lltok::kw_nonlazybind:
     case lltok::kw_nomerge:
+    case lltok::kw_noprofile:
     case lltok::kw_noredzone:
     case lltok::kw_noreturn:
     case lltok::kw_nocf_check:
@@ -1834,15 +1910,17 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     case lltok::kw_shadowcallstack:
     case lltok::kw_strictfp:
     case lltok::kw_uwtable:
-      HaveError |= Error(Lex.getLoc(), "invalid use of function-only attribute");
+      HaveError |=
+          error(Lex.getLoc(), "invalid use of function-only attribute");
       break;
     case lltok::kw_readnone:
     case lltok::kw_readonly:
-      HaveError |= Error(Lex.getLoc(), "invalid use of attribute on return type");
+      HaveError |=
+          error(Lex.getLoc(), "invalid use of attribute on return type");
       break;
     case lltok::kw_preallocated:
       HaveError |=
-          Error(Lex.getLoc(),
+          error(Lex.getLoc(),
                 "invalid use of parameter-only/call site-only attribute");
       break;
     }
@@ -1882,7 +1960,7 @@ static unsigned parseOptionalLinkageAux(lltok::Kind Kind, bool &HasLinkage) {
   }
 }
 
-/// ParseOptionalLinkage
+/// parseOptionalLinkage
 ///   ::= /*empty*/
 ///   ::= 'private'
 ///   ::= 'internal'
@@ -1895,25 +1973,24 @@ static unsigned parseOptionalLinkageAux(lltok::Kind Kind, bool &HasLinkage) {
 ///   ::= 'common'
 ///   ::= 'extern_weak'
 ///   ::= 'external'
-bool LLParser::ParseOptionalLinkage(unsigned &Res, bool &HasLinkage,
+bool LLParser::parseOptionalLinkage(unsigned &Res, bool &HasLinkage,
                                     unsigned &Visibility,
-                                    unsigned &DLLStorageClass,
-                                    bool &DSOLocal) {
+                                    unsigned &DLLStorageClass, bool &DSOLocal) {
   Res = parseOptionalLinkageAux(Lex.getKind(), HasLinkage);
   if (HasLinkage)
     Lex.Lex();
-  ParseOptionalDSOLocal(DSOLocal);
-  ParseOptionalVisibility(Visibility);
-  ParseOptionalDLLStorageClass(DLLStorageClass);
+  parseOptionalDSOLocal(DSOLocal);
+  parseOptionalVisibility(Visibility);
+  parseOptionalDLLStorageClass(DLLStorageClass);
 
   if (DSOLocal && DLLStorageClass == GlobalValue::DLLImportStorageClass) {
-    return Error(Lex.getLoc(), "dso_location and DLL-StorageClass mismatch");
+    return error(Lex.getLoc(), "dso_location and DLL-StorageClass mismatch");
   }
 
   return false;
 }
 
-void LLParser::ParseOptionalDSOLocal(bool &DSOLocal) {
+void LLParser::parseOptionalDSOLocal(bool &DSOLocal) {
   switch (Lex.getKind()) {
   default:
     DSOLocal = false;
@@ -2059,6 +2136,7 @@ bool LLParser::ParseOptionalCallingConv(unsigned &CC) {
   case lltok::kw_hhvm_ccc:       CC = CallingConv::HHVM_C; break;
   case lltok::kw_cxx_fast_tlscc: CC = CallingConv::CXX_FAST_TLS; break;
   case lltok::kw_amdgpu_vs:      CC = CallingConv::AMDGPU_VS; break;
+  case lltok::kw_amdgpu_gfx:     CC = CallingConv::AMDGPU_Gfx; break;
   case lltok::kw_amdgpu_ls:      CC = CallingConv::AMDGPU_LS; break;
   case lltok::kw_amdgpu_hs:      CC = CallingConv::AMDGPU_HS; break;
   case lltok::kw_amdgpu_es:      CC = CallingConv::AMDGPU_ES; break;
@@ -2077,28 +2155,28 @@ bool LLParser::ParseOptionalCallingConv(unsigned &CC) {
   return false;
 }
 
-/// ParseMetadataAttachment
+/// parseMetadataAttachment
 ///   ::= !dbg !42
-bool LLParser::ParseMetadataAttachment(unsigned &Kind, MDNode *&MD) {
+bool LLParser::parseMetadataAttachment(unsigned &Kind, MDNode *&MD) {
   assert(Lex.getKind() == lltok::MetadataVar && "Expected metadata attachment");
 
   std::string Name = Lex.getStrVal();
   Kind = M->getMDKindID(Name);
   Lex.Lex();
 
-  return ParseMDNode(MD);
+  return parseMDNode(MD);
 }
 
-/// ParseInstructionMetadata
+/// parseInstructionMetadata
 ///   ::= !dbg !42 (',' !dbg !57)*
-bool LLParser::ParseInstructionMetadata(Instruction &Inst) {
+bool LLParser::parseInstructionMetadata(Instruction &Inst) {
   do {
     if (Lex.getKind() != lltok::MetadataVar)
-      return TokError("expected metadata after comma");
+      return tokError("expected metadata after comma");
 
     unsigned MDK;
     MDNode *N;
-    if (ParseMetadataAttachment(MDK, N))
+    if (parseMetadataAttachment(MDK, N))
       return true;
 
     Inst.setMetadata(MDK, N);
@@ -2110,31 +2188,31 @@ bool LLParser::ParseInstructionMetadata(Instruction &Inst) {
   return false;
 }
 
-/// ParseGlobalObjectMetadataAttachment
+/// parseGlobalObjectMetadataAttachment
 ///   ::= !dbg !57
-bool LLParser::ParseGlobalObjectMetadataAttachment(GlobalObject &GO) {
+bool LLParser::parseGlobalObjectMetadataAttachment(GlobalObject &GO) {
   unsigned MDK;
   MDNode *N;
-  if (ParseMetadataAttachment(MDK, N))
+  if (parseMetadataAttachment(MDK, N))
     return true;
 
   GO.addMetadata(MDK, *N);
   return false;
 }
 
-/// ParseOptionalFunctionMetadata
+/// parseOptionalFunctionMetadata
 ///   ::= (!dbg !57)*
-bool LLParser::ParseOptionalFunctionMetadata(Function &F) {
+bool LLParser::parseOptionalFunctionMetadata(Function &F) {
   while (Lex.getKind() == lltok::MetadataVar)
-    if (ParseGlobalObjectMetadataAttachment(F))
+    if (parseGlobalObjectMetadataAttachment(F))
       return true;
   return false;
 }
 
-/// ParseOptionalAlignment
+/// parseOptionalAlignment
 ///   ::= /* empty */
 ///   ::= 'align' 4
-bool LLParser::ParseOptionalAlignment(MaybeAlign &Alignment, bool AllowParens) {
+bool LLParser::parseOptionalAlignment(MaybeAlign &Alignment, bool AllowParens) {
   Alignment = None;
   if (!EatIfPresent(lltok::kw_align))
     return false;
@@ -2148,26 +2226,26 @@ bool LLParser::ParseOptionalAlignment(MaybeAlign &Alignment, bool AllowParens) {
       HaveParens = true;
   }
 
-  if (ParseUInt32(Value))
+  if (parseUInt32(Value))
     return true;
 
   if (HaveParens && !EatIfPresent(lltok::rparen))
-    return Error(ParenLoc, "expected ')'");
+    return error(ParenLoc, "expected ')'");
 
   if (!isPowerOf2_32(Value))
-    return Error(AlignLoc, "alignment is not a power of two");
+    return error(AlignLoc, "alignment is not a power of two");
   if (Value > Value::MaximumAlignment)
-    return Error(AlignLoc, "huge alignments are not supported yet");
+    return error(AlignLoc, "huge alignments are not supported yet");
   Alignment = Align(Value);
   return false;
 }
 
-/// ParseOptionalDerefAttrBytes
+/// parseOptionalDerefAttrBytes
 ///   ::= /* empty */
 ///   ::= AttrKind '(' 4 ')'
 ///
 /// where AttrKind is either 'dereferenceable' or 'dereferenceable_or_null'.
-bool LLParser::ParseOptionalDerefAttrBytes(lltok::Kind AttrKind,
+bool LLParser::parseOptionalDerefAttrBytes(lltok::Kind AttrKind,
                                            uint64_t &Bytes) {
   assert((AttrKind == lltok::kw_dereferenceable ||
           AttrKind == lltok::kw_dereferenceable_or_null) &&
@@ -2178,24 +2256,25 @@ bool LLParser::ParseOptionalDerefAttrBytes(lltok::Kind AttrKind,
     return false;
   LocTy ParenLoc = Lex.getLoc();
   if (!EatIfPresent(lltok::lparen))
-    return Error(ParenLoc, "expected '('");
+    return error(ParenLoc, "expected '('");
   LocTy DerefLoc = Lex.getLoc();
-  if (ParseUInt64(Bytes)) return true;
+  if (parseUInt64(Bytes))
+    return true;
   ParenLoc = Lex.getLoc();
   if (!EatIfPresent(lltok::rparen))
-    return Error(ParenLoc, "expected ')'");
+    return error(ParenLoc, "expected ')'");
   if (!Bytes)
-    return Error(DerefLoc, "dereferenceable bytes must be non-zero");
+    return error(DerefLoc, "dereferenceable bytes must be non-zero");
   return false;
 }
 
-/// ParseOptionalCommaAlign
+/// parseOptionalCommaAlign
 ///   ::=
 ///   ::= ',' align 4
 ///
 /// This returns with AteExtraComma set to true if it ate an excess comma at the
 /// end.
-bool LLParser::ParseOptionalCommaAlign(MaybeAlign &Alignment,
+bool LLParser::parseOptionalCommaAlign(MaybeAlign &Alignment,
                                        bool &AteExtraComma) {
   AteExtraComma = false;
   while (EatIfPresent(lltok::comma)) {
@@ -2206,22 +2285,22 @@ bool LLParser::ParseOptionalCommaAlign(MaybeAlign &Alignment,
     }
 
     if (Lex.getKind() != lltok::kw_align)
-      return Error(Lex.getLoc(), "expected metadata or 'align'");
+      return error(Lex.getLoc(), "expected metadata or 'align'");
 
-    if (ParseOptionalAlignment(Alignment)) return true;
+    if (parseOptionalAlignment(Alignment))
+      return true;
   }
 
   return false;
 }
 
-/// ParseOptionalCommaAddrSpace
+/// parseOptionalCommaAddrSpace
 ///   ::=
 ///   ::= ',' addrspace(1)
 ///
 /// This returns with AteExtraComma set to true if it ate an excess comma at the
 /// end.
-bool LLParser::ParseOptionalCommaAddrSpace(unsigned &AddrSpace,
-                                           LocTy &Loc,
+bool LLParser::parseOptionalCommaAddrSpace(unsigned &AddrSpace, LocTy &Loc,
                                            bool &AteExtraComma) {
   AteExtraComma = false;
   while (EatIfPresent(lltok::comma)) {
@@ -2233,9 +2312,9 @@ bool LLParser::ParseOptionalCommaAddrSpace(unsigned &AddrSpace,
 
     Loc = Lex.getLoc();
     if (Lex.getKind() != lltok::kw_addrspace)
-      return Error(Lex.getLoc(), "expected metadata or 'addrspace'");
+      return error(Lex.getLoc(), "expected metadata or 'addrspace'");
 
-    if (ParseOptionalAddrSpace(AddrSpace))
+    if (parseOptionalAddrSpace(AddrSpace))
       return true;
   }
 
@@ -2248,18 +2327,18 @@ bool LLParser::parseAllocSizeArguments(unsigned &BaseSizeArg,
 
   auto StartParen = Lex.getLoc();
   if (!EatIfPresent(lltok::lparen))
-    return Error(StartParen, "expected '('");
+    return error(StartParen, "expected '('");
 
-  if (ParseUInt32(BaseSizeArg))
+  if (parseUInt32(BaseSizeArg))
     return true;
 
   if (EatIfPresent(lltok::comma)) {
     auto HowManyAt = Lex.getLoc();
     unsigned HowMany;
-    if (ParseUInt32(HowMany))
+    if (parseUInt32(HowMany))
       return true;
     if (HowMany == BaseSizeArg)
-      return Error(HowManyAt,
+      return error(HowManyAt,
                    "'allocsize' indices can't refer to the same parameter");
     HowManyArg = HowMany;
   } else
@@ -2267,42 +2346,42 @@ bool LLParser::parseAllocSizeArguments(unsigned &BaseSizeArg,
 
   auto EndParen = Lex.getLoc();
   if (!EatIfPresent(lltok::rparen))
-    return Error(EndParen, "expected ')'");
+    return error(EndParen, "expected ')'");
   return false;
 }
 
-/// ParseScopeAndOrdering
+/// parseScopeAndOrdering
 ///   if isAtomic: ::= SyncScope? AtomicOrdering
 ///   else: ::=
 ///
 /// This sets Scope and Ordering to the parsed values.
-bool LLParser::ParseScopeAndOrdering(bool isAtomic, SyncScope::ID &SSID,
+bool LLParser::parseScopeAndOrdering(bool IsAtomic, SyncScope::ID &SSID,
                                      AtomicOrdering &Ordering) {
-  if (!isAtomic)
+  if (!IsAtomic)
     return false;
 
-  return ParseScope(SSID) || ParseOrdering(Ordering);
+  return parseScope(SSID) || parseOrdering(Ordering);
 }
 
-/// ParseScope
+/// parseScope
 ///   ::= syncscope("singlethread" | "<target scope>")?
 ///
 /// This sets synchronization scope ID to the ID of the parsed value.
-bool LLParser::ParseScope(SyncScope::ID &SSID) {
+bool LLParser::parseScope(SyncScope::ID &SSID) {
   SSID = SyncScope::System;
   if (EatIfPresent(lltok::kw_syncscope)) {
     auto StartParenAt = Lex.getLoc();
     if (!EatIfPresent(lltok::lparen))
-      return Error(StartParenAt, "Expected '(' in syncscope");
+      return error(StartParenAt, "Expected '(' in syncscope");
 
     std::string SSN;
     auto SSNAt = Lex.getLoc();
-    if (ParseStringConstant(SSN))
-      return Error(SSNAt, "Expected synchronization scope name");
+    if (parseStringConstant(SSN))
+      return error(SSNAt, "Expected synchronization scope name");
 
     auto EndParenAt = Lex.getLoc();
     if (!EatIfPresent(lltok::rparen))
-      return Error(EndParenAt, "Expected ')' in syncscope");
+      return error(EndParenAt, "Expected ')' in syncscope");
 
     SSID = Context.getOrInsertSyncScopeID(SSN);
   }
@@ -2310,13 +2389,14 @@ bool LLParser::ParseScope(SyncScope::ID &SSID) {
   return false;
 }
 
-/// ParseOrdering
+/// parseOrdering
 ///   ::= AtomicOrdering
 ///
 /// This sets Ordering to the parsed value.
-bool LLParser::ParseOrdering(AtomicOrdering &Ordering) {
+bool LLParser::parseOrdering(AtomicOrdering &Ordering) {
   switch (Lex.getKind()) {
-  default: return TokError("Expected ordering on atomic instruction");
+  default:
+    return tokError("Expected ordering on atomic instruction");
   case lltok::kw_unordered: Ordering = AtomicOrdering::Unordered; break;
   case lltok::kw_monotonic: Ordering = AtomicOrdering::Monotonic; break;
   // Not specified yet:
@@ -2332,50 +2412,53 @@ bool LLParser::ParseOrdering(AtomicOrdering &Ordering) {
   return false;
 }
 
-/// ParseOptionalStackAlignment
+/// parseOptionalStackAlignment
 ///   ::= /* empty */
 ///   ::= 'alignstack' '(' 4 ')'
-bool LLParser::ParseOptionalStackAlignment(unsigned &Alignment) {
+bool LLParser::parseOptionalStackAlignment(unsigned &Alignment) {
   Alignment = 0;
   if (!EatIfPresent(lltok::kw_alignstack))
     return false;
   LocTy ParenLoc = Lex.getLoc();
   if (!EatIfPresent(lltok::lparen))
-    return Error(ParenLoc, "expected '('");
+    return error(ParenLoc, "expected '('");
   LocTy AlignLoc = Lex.getLoc();
-  if (ParseUInt32(Alignment)) return true;
+  if (parseUInt32(Alignment))
+    return true;
   ParenLoc = Lex.getLoc();
   if (!EatIfPresent(lltok::rparen))
-    return Error(ParenLoc, "expected ')'");
+    return error(ParenLoc, "expected ')'");
   if (!isPowerOf2_32(Alignment))
-    return Error(AlignLoc, "stack alignment is not a power of two");
+    return error(AlignLoc, "stack alignment is not a power of two");
   return false;
 }
 
-/// ParseIndexList - This parses the index list for an insert/extractvalue
+/// parseIndexList - This parses the index list for an insert/extractvalue
 /// instruction.  This sets AteExtraComma in the case where we eat an extra
 /// comma at the end of the line and find that it is followed by metadata.
 /// Clients that don't allow metadata can call the version of this function that
 /// only takes one argument.
 ///
-/// ParseIndexList
+/// parseIndexList
 ///    ::=  (',' uint32)+
 ///
-bool LLParser::ParseIndexList(SmallVectorImpl<unsigned> &Indices,
+bool LLParser::parseIndexList(SmallVectorImpl<unsigned> &Indices,
                               bool &AteExtraComma) {
   AteExtraComma = false;
 
   if (Lex.getKind() != lltok::comma)
-    return TokError("expected ',' as start of index list");
+    return tokError("expected ',' as start of index list");
 
   while (EatIfPresent(lltok::comma)) {
     if (Lex.getKind() == lltok::MetadataVar) {
-      if (Indices.empty()) return TokError("expected index");
+      if (Indices.empty())
+        return tokError("expected index");
       AteExtraComma = true;
       return false;
     }
     unsigned Idx = 0;
-    if (ParseUInt32(Idx)) return true;
+    if (parseUInt32(Idx))
+      return true;
     Indices.push_back(Idx);
   }
 
@@ -2386,12 +2469,12 @@ bool LLParser::ParseIndexList(SmallVectorImpl<unsigned> &Indices,
 // Type Parsing.
 //===----------------------------------------------------------------------===//
 
-/// ParseType - Parse a type.
-bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
+/// parseType - parse a type.
+bool LLParser::parseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
   SMLoc TypeLoc = Lex.getLoc();
   switch (Lex.getKind()) {
   default:
-    return TokError(Msg);
+    return tokError(Msg);
   case lltok::Type:
     // Type ::= 'float' | 'void' (etc)
     Result = Lex.getTyVal();
@@ -2399,23 +2482,23 @@ bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
     break;
   case lltok::lbrace:
     // Type ::= StructType
-    if (ParseAnonStructType(Result, false))
+    if (parseAnonStructType(Result, false))
       return true;
     break;
   case lltok::lsquare:
     // Type ::= '[' ... ']'
     Lex.Lex(); // eat the lsquare.
-    if (ParseArrayVectorType(Result, false))
+    if (parseArrayVectorType(Result, false))
       return true;
     break;
   case lltok::less: // Either vector or packed struct.
     // Type ::= '<' ... '>'
     Lex.Lex();
     if (Lex.getKind() == lltok::lbrace) {
-      if (ParseAnonStructType(Result, true) ||
-          ParseToken(lltok::greater, "expected '>' at end of packed struct"))
+      if (parseAnonStructType(Result, true) ||
+          parseToken(lltok::greater, "expected '>' at end of packed struct"))
         return true;
-    } else if (ParseArrayVectorType(Result, true))
+    } else if (parseArrayVectorType(Result, true))
       return true;
     break;
   case lltok::LocalVar: {
@@ -2449,23 +2532,23 @@ bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
   }
   }
 
-  // Parse the type suffixes.
+  // parse the type suffixes.
   while (true) {
     switch (Lex.getKind()) {
     // End of type.
     default:
       if (!AllowVoid && Result->isVoidTy())
-        return Error(TypeLoc, "void type only allowed for function results");
+        return error(TypeLoc, "void type only allowed for function results");
       return false;
 
     // Type ::= Type '*'
     case lltok::star:
       if (Result->isLabelTy())
-        return TokError("basic block pointers are invalid");
+        return tokError("basic block pointers are invalid");
       if (Result->isVoidTy())
-        return TokError("pointers to void are invalid - use i8* instead");
+        return tokError("pointers to void are invalid - use i8* instead");
       if (!PointerType::isValidElementType(Result))
-        return TokError("pointer to this type is invalid");
+        return tokError("pointer to this type is invalid");
       Result = PointerType::getUnqual(Result);
       Lex.Lex();
       break;
@@ -2473,14 +2556,14 @@ bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
     // Type ::= Type 'addrspace' '(' uint32 ')' '*'
     case lltok::kw_addrspace: {
       if (Result->isLabelTy())
-        return TokError("basic block pointers are invalid");
+        return tokError("basic block pointers are invalid");
       if (Result->isVoidTy())
-        return TokError("pointers to void are invalid; use i8* instead");
+        return tokError("pointers to void are invalid; use i8* instead");
       if (!PointerType::isValidElementType(Result))
-        return TokError("pointer to this type is invalid");
+        return tokError("pointer to this type is invalid");
       unsigned AddrSpace;
-      if (ParseOptionalAddrSpace(AddrSpace) ||
-          ParseToken(lltok::star, "expected '*' in address space"))
+      if (parseOptionalAddrSpace(AddrSpace) ||
+          parseToken(lltok::star, "expected '*' in address space"))
         return true;
 
       Result = PointerType::get(Result, AddrSpace);
@@ -2489,55 +2572,55 @@ bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
 
     /// Types '(' ArgTypeListI ')' OptFuncAttrs
     case lltok::lparen:
-      if (ParseFunctionType(Result))
+      if (parseFunctionType(Result))
         return true;
       break;
     }
   }
 }
 
-/// ParseParameterList
+/// parseParameterList
 ///    ::= '(' ')'
 ///    ::= '(' Arg (',' Arg)* ')'
 ///  Arg
 ///    ::= Type OptionalAttributes Value OptionalAttributes
-bool LLParser::ParseParameterList(SmallVectorImpl<ParamInfo> &ArgList,
+bool LLParser::parseParameterList(SmallVectorImpl<ParamInfo> &ArgList,
                                   PerFunctionState &PFS, bool IsMustTailCall,
                                   bool InVarArgsFunc) {
-  if (ParseToken(lltok::lparen, "expected '(' in call"))
+  if (parseToken(lltok::lparen, "expected '(' in call"))
     return true;
 
   while (Lex.getKind() != lltok::rparen) {
     // If this isn't the first argument, we need a comma.
     if (!ArgList.empty() &&
-        ParseToken(lltok::comma, "expected ',' in argument list"))
+        parseToken(lltok::comma, "expected ',' in argument list"))
       return true;
 
-    // Parse an ellipsis if this is a musttail call in a variadic function.
+    // parse an ellipsis if this is a musttail call in a variadic function.
     if (Lex.getKind() == lltok::dotdotdot) {
       const char *Msg = "unexpected ellipsis in argument list for ";
       if (!IsMustTailCall)
-        return TokError(Twine(Msg) + "non-musttail call");
+        return tokError(Twine(Msg) + "non-musttail call");
       if (!InVarArgsFunc)
-        return TokError(Twine(Msg) + "musttail call in non-varargs function");
+        return tokError(Twine(Msg) + "musttail call in non-varargs function");
       Lex.Lex();  // Lex the '...', it is purely for readability.
-      return ParseToken(lltok::rparen, "expected ')' at end of argument list");
+      return parseToken(lltok::rparen, "expected ')' at end of argument list");
     }
 
-    // Parse the argument.
+    // parse the argument.
     LocTy ArgLoc;
     Type *ArgTy = nullptr;
     AttrBuilder ArgAttrs;
     Value *V;
-    if (ParseType(ArgTy, ArgLoc))
+    if (parseType(ArgTy, ArgLoc))
       return true;
 
     if (ArgTy->isMetadataTy()) {
-      if (ParseMetadataAsValue(V, PFS))
+      if (parseMetadataAsValue(V, PFS))
         return true;
     } else {
       // Otherwise, handle normal operands.
-      if (ParseOptionalParamAttrs(ArgAttrs) || ParseValue(ArgTy, V, PFS))
+      if (parseOptionalParamAttrs(ArgAttrs) || parseValue(ArgTy, V, PFS))
         return true;
     }
     ArgList.push_back(ParamInfo(
@@ -2545,45 +2628,41 @@ bool LLParser::ParseParameterList(SmallVectorImpl<ParamInfo> &ArgList,
   }
 
   if (IsMustTailCall && InVarArgsFunc)
-    return TokError("expected '...' at end of argument list for musttail call "
+    return tokError("expected '...' at end of argument list for musttail call "
                     "in varargs function");
 
   Lex.Lex();  // Lex the ')'.
   return false;
 }
 
-/// ParseByValWithOptionalType
-///   ::= byval
-///   ::= byval(<ty>)
-bool LLParser::ParseByValWithOptionalType(Type *&Result) {
+/// parseRequiredTypeAttr
+///   ::= attrname(<ty>)
+bool LLParser::parseRequiredTypeAttr(Type *&Result, lltok::Kind AttrName) {
   Result = nullptr;
-  if (!EatIfPresent(lltok::kw_byval))
+  if (!EatIfPresent(AttrName))
     return true;
   if (!EatIfPresent(lltok::lparen))
-    return false;
-  if (ParseType(Result))
+    return error(Lex.getLoc(), "expected '('");
+  if (parseType(Result))
     return true;
   if (!EatIfPresent(lltok::rparen))
-    return Error(Lex.getLoc(), "expected ')'");
+    return error(Lex.getLoc(), "expected ')'");
   return false;
 }
 
-/// ParsePreallocated
+/// parsePreallocated
 ///   ::= preallocated(<ty>)
-bool LLParser::ParsePreallocated(Type *&Result) {
-  Result = nullptr;
-  if (!EatIfPresent(lltok::kw_preallocated))
-    return true;
-  if (!EatIfPresent(lltok::lparen))
-    return Error(Lex.getLoc(), "expected '('");
-  if (ParseType(Result))
-    return true;
-  if (!EatIfPresent(lltok::rparen))
-    return Error(Lex.getLoc(), "expected ')'");
-  return false;
+bool LLParser::parsePreallocated(Type *&Result) {
+  return parseRequiredTypeAttr(Result, lltok::kw_preallocated);
+}
+
+/// parseByRef
+///   ::= byref(<type>)
+bool LLParser::parseByRef(Type *&Result) {
+  return parseRequiredTypeAttr(Result, lltok::kw_byref);
 }
 
-/// ParseOptionalOperandBundles
+/// parseOptionalOperandBundles
 ///    ::= /*empty*/
 ///    ::= '[' OperandBundle [, OperandBundle ]* ']'
 ///
@@ -2592,7 +2671,7 @@ bool LLParser::ParsePreallocated(Type *&Result) {
 ///    ::= bundle-tag '(' Type Value [, Type Value ]* ')'
 ///
 /// bundle-tag ::= String Constant
-bool LLParser::ParseOptionalOperandBundles(
+bool LLParser::parseOptionalOperandBundles(
     SmallVectorImpl<OperandBundleDef> &BundleList, PerFunctionState &PFS) {
   LocTy BeginLoc = Lex.getLoc();
   if (!EatIfPresent(lltok::lsquare))
@@ -2601,26 +2680,26 @@ bool LLParser::ParseOptionalOperandBundles(
   while (Lex.getKind() != lltok::rsquare) {
     // If this isn't the first operand bundle, we need a comma.
     if (!BundleList.empty() &&
-        ParseToken(lltok::comma, "expected ',' in input list"))
+        parseToken(lltok::comma, "expected ',' in input list"))
       return true;
 
     std::string Tag;
-    if (ParseStringConstant(Tag))
+    if (parseStringConstant(Tag))
       return true;
 
-    if (ParseToken(lltok::lparen, "expected '(' in operand bundle"))
+    if (parseToken(lltok::lparen, "expected '(' in operand bundle"))
       return true;
 
     std::vector<Value *> Inputs;
     while (Lex.getKind() != lltok::rparen) {
       // If this isn't the first input, we need a comma.
       if (!Inputs.empty() &&
-          ParseToken(lltok::comma, "expected ',' in input list"))
+          parseToken(lltok::comma, "expected ',' in input list"))
         return true;
 
       Type *Ty = nullptr;
       Value *Input = nullptr;
-      if (ParseType(Ty) || ParseValue(Ty, Input, PFS))
+      if (parseType(Ty) || parseValue(Ty, Input, PFS))
         return true;
       Inputs.push_back(Input);
     }
@@ -2631,13 +2710,13 @@ bool LLParser::ParseOptionalOperandBundles(
   }
 
   if (BundleList.empty())
-    return Error(BeginLoc, "operand bundle set must not be empty");
+    return error(BeginLoc, "operand bundle set must not be empty");
 
   Lex.Lex(); // Lex the ']'.
   return false;
 }
 
-/// ParseArgumentList - Parse the argument list for a function type or function
+/// parseArgumentList - parse the argument list for a function type or function
 /// prototype.
 ///   ::= '(' ArgTypeListI ')'
 /// ArgTypeListI
@@ -2646,17 +2725,17 @@ bool LLParser::ParseOptionalOperandBundles(
 ///   ::= ArgTypeList ',' '...'
 ///   ::= ArgType (',' ArgType)*
 ///
-bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
-                                 bool &isVarArg){
+bool LLParser::parseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
+                                 bool &IsVarArg) {
   unsigned CurValID = 0;
-  isVarArg = false;
+  IsVarArg = false;
   assert(Lex.getKind() == lltok::lparen);
   Lex.Lex(); // eat the (.
 
   if (Lex.getKind() == lltok::rparen) {
     // empty
   } else if (Lex.getKind() == lltok::dotdotdot) {
-    isVarArg = true;
+    IsVarArg = true;
     Lex.Lex();
   } else {
     LocTy TypeLoc = Lex.getLoc();
@@ -2664,25 +2743,25 @@ bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
     AttrBuilder Attrs;
     std::string Name;
 
-    if (ParseType(ArgTy) ||
-        ParseOptionalParamAttrs(Attrs)) return true;
+    if (parseType(ArgTy) || parseOptionalParamAttrs(Attrs))
+      return true;
 
     if (ArgTy->isVoidTy())
-      return Error(TypeLoc, "argument can not have void type");
+      return error(TypeLoc, "argument can not have void type");
 
     if (Lex.getKind() == lltok::LocalVar) {
       Name = Lex.getStrVal();
       Lex.Lex();
     } else if (Lex.getKind() == lltok::LocalVarID) {
       if (Lex.getUIntVal() != CurValID)
-        return Error(TypeLoc, "argument expected to be numbered '%" +
+        return error(TypeLoc, "argument expected to be numbered '%" +
                                   Twine(CurValID) + "'");
       ++CurValID;
       Lex.Lex();
     }
 
     if (!FunctionType::isValidArgumentType(ArgTy))
-      return Error(TypeLoc, "invalid type for function argument");
+      return error(TypeLoc, "invalid type for function argument");
 
     ArgList.emplace_back(TypeLoc, ArgTy,
                          AttributeSet::get(ArgTy->getContext(), Attrs),
@@ -2691,16 +2770,17 @@ bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
     while (EatIfPresent(lltok::comma)) {
       // Handle ... at end of arg list.
       if (EatIfPresent(lltok::dotdotdot)) {
-        isVarArg = true;
+        IsVarArg = true;
         break;
       }
 
       // Otherwise must be an argument type.
       TypeLoc = Lex.getLoc();
-      if (ParseType(ArgTy) || ParseOptionalParamAttrs(Attrs)) return true;
+      if (parseType(ArgTy) || parseOptionalParamAttrs(Attrs))
+        return true;
 
       if (ArgTy->isVoidTy())
-        return Error(TypeLoc, "argument can not have void type");
+        return error(TypeLoc, "argument can not have void type");
 
       if (Lex.getKind() == lltok::LocalVar) {
         Name = Lex.getStrVal();
@@ -2708,7 +2788,7 @@ bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
       } else {
         if (Lex.getKind() == lltok::LocalVarID) {
           if (Lex.getUIntVal() != CurValID)
-            return Error(TypeLoc, "argument expected to be numbered '%" +
+            return error(TypeLoc, "argument expected to be numbered '%" +
                                       Twine(CurValID) + "'");
           Lex.Lex();
         }
@@ -2717,7 +2797,7 @@ bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
       }
 
       if (!ArgTy->isFirstClassType())
-        return Error(TypeLoc, "invalid type for function argument");
+        return error(TypeLoc, "invalid type for function argument");
 
       ArgList.emplace_back(TypeLoc, ArgTy,
                            AttributeSet::get(ArgTy->getContext(), Attrs),
@@ -2725,28 +2805,28 @@ bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
     }
   }
 
-  return ParseToken(lltok::rparen, "expected ')' at end of argument list");
+  return parseToken(lltok::rparen, "expected ')' at end of argument list");
 }
 
-/// ParseFunctionType
+/// parseFunctionType
 ///  ::= Type ArgumentList OptionalAttrs
-bool LLParser::ParseFunctionType(Type *&Result) {
+bool LLParser::parseFunctionType(Type *&Result) {
   assert(Lex.getKind() == lltok::lparen);
 
   if (!FunctionType::isValidReturnType(Result))
-    return TokError("invalid function return type");
+    return tokError("invalid function return type");
 
   SmallVector<ArgInfo, 8> ArgList;
-  bool isVarArg;
-  if (ParseArgumentList(ArgList, isVarArg))
+  bool IsVarArg;
+  if (parseArgumentList(ArgList, IsVarArg))
     return true;
 
   // Reject names on the arguments lists.
   for (unsigned i = 0, e = ArgList.size(); i != e; ++i) {
     if (!ArgList[i].Name.empty())
-      return Error(ArgList[i].Loc, "argument name invalid in function type");
+      return error(ArgList[i].Loc, "argument name invalid in function type");
     if (ArgList[i].Attrs.hasAttributes())
-      return Error(ArgList[i].Loc,
+      return error(ArgList[i].Loc,
                    "argument attributes invalid in function type");
   }
 
@@ -2754,27 +2834,28 @@ bool LLParser::ParseFunctionType(Type *&Result) {
   for (unsigned i = 0, e = ArgList.size(); i != e; ++i)
     ArgListTy.push_back(ArgList[i].Ty);
 
-  Result = FunctionType::get(Result, ArgListTy, isVarArg);
+  Result = FunctionType::get(Result, ArgListTy, IsVarArg);
   return false;
 }
 
-/// ParseAnonStructType - Parse an anonymous struct type, which is inlined into
+/// parseAnonStructType - parse an anonymous struct type, which is inlined into
 /// other structs.
-bool LLParser::ParseAnonStructType(Type *&Result, bool Packed) {
+bool LLParser::parseAnonStructType(Type *&Result, bool Packed) {
   SmallVector<Type*, 8> Elts;
-  if (ParseStructBody(Elts)) return true;
+  if (parseStructBody(Elts))
+    return true;
 
   Result = StructType::get(Context, Elts, Packed);
   return false;
 }
 
-/// ParseStructDefinition - Parse a struct in a 'type' definition.
-bool LLParser::ParseStructDefinition(SMLoc TypeLoc, StringRef Name,
-                                     std::pair<Type*, LocTy> &Entry,
+/// parseStructDefinition - parse a struct in a 'type' definition.
+bool LLParser::parseStructDefinition(SMLoc TypeLoc, StringRef Name,
+                                     std::pair<Type *, LocTy> &Entry,
                                      Type *&ResultTy) {
   // If the type was already defined, diagnose the redefinition.
   if (Entry.first && !Entry.second.isValid())
-    return Error(TypeLoc, "redefinition of type");
+    return error(TypeLoc, "redefinition of type");
 
   // If we have opaque, just return without filling in the definition for the
   // struct.  This counts as a definition as far as the .ll file goes.
@@ -2797,12 +2878,12 @@ bool LLParser::ParseStructDefinition(SMLoc TypeLoc, StringRef Name,
   // forward referenced and not allowed to be recursive.
   if (Lex.getKind() != lltok::lbrace) {
     if (Entry.first)
-      return Error(TypeLoc, "forward references to non-struct type");
+      return error(TypeLoc, "forward references to non-struct type");
 
     ResultTy = nullptr;
     if (isPacked)
-      return ParseArrayVectorType(ResultTy, true);
-    return ParseType(ResultTy);
+      return parseArrayVectorType(ResultTy, true);
+    return parseType(ResultTy);
   }
 
   // This type is being defined, so clear the location to indicate this.
@@ -2815,8 +2896,8 @@ bool LLParser::ParseStructDefinition(SMLoc TypeLoc, StringRef Name,
   StructType *STy = cast<StructType>(Entry.first);
 
   SmallVector<Type*, 8> Body;
-  if (ParseStructBody(Body) ||
-      (isPacked && ParseToken(lltok::greater, "expected '>' in packed struct")))
+  if (parseStructBody(Body) ||
+      (isPacked && parseToken(lltok::greater, "expected '>' in packed struct")))
     return true;
 
   STy->setBody(Body, isPacked);
@@ -2824,13 +2905,13 @@ bool LLParser::ParseStructDefinition(SMLoc TypeLoc, StringRef Name,
   return false;
 }
 
-/// ParseStructType: Handles packed and unpacked types.  </> parsed elsewhere.
+/// parseStructType: Handles packed and unpacked types.  </> parsed elsewhere.
 ///   StructType
 ///     ::= '{' '}'
 ///     ::= '{' Type (',' Type)* '}'
 ///     ::= '<' '{' '}' '>'
 ///     ::= '<' '{' Type (',' Type)* '}' '>'
-bool LLParser::ParseStructBody(SmallVectorImpl<Type*> &Body) {
+bool LLParser::parseStructBody(SmallVectorImpl<Type *> &Body) {
   assert(Lex.getKind() == lltok::lbrace);
   Lex.Lex(); // Consume the '{'
 
@@ -2840,37 +2921,39 @@ bool LLParser::ParseStructBody(SmallVectorImpl<Type*> &Body) {
 
   LocTy EltTyLoc = Lex.getLoc();
   Type *Ty = nullptr;
-  if (ParseType(Ty)) return true;
+  if (parseType(Ty))
+    return true;
   Body.push_back(Ty);
 
   if (!StructType::isValidElementType(Ty))
-    return Error(EltTyLoc, "invalid element type for struct");
+    return error(EltTyLoc, "invalid element type for struct");
 
   while (EatIfPresent(lltok::comma)) {
     EltTyLoc = Lex.getLoc();
-    if (ParseType(Ty)) return true;
+    if (parseType(Ty))
+      return true;
 
     if (!StructType::isValidElementType(Ty))
-      return Error(EltTyLoc, "invalid element type for struct");
+      return error(EltTyLoc, "invalid element type for struct");
 
     Body.push_back(Ty);
   }
 
-  return ParseToken(lltok::rbrace, "expected '}' at end of struct");
+  return parseToken(lltok::rbrace, "expected '}' at end of struct");
 }
 
-/// ParseArrayVectorType - Parse an array or vector type, assuming the first
+/// parseArrayVectorType - parse an array or vector type, assuming the first
 /// token has already been consumed.
 ///   Type
 ///     ::= '[' APSINTVAL 'x' Types ']'
 ///     ::= '<' APSINTVAL 'x' Types '>'
 ///     ::= '<' 'vscale' 'x' APSINTVAL 'x' Types '>'
-bool LLParser::ParseArrayVectorType(Type *&Result, bool isVector) {
+bool LLParser::parseArrayVectorType(Type *&Result, bool IsVector) {
   bool Scalable = false;
 
-  if (isVector && Lex.getKind() == lltok::kw_vscale) {
+  if (IsVector && Lex.getKind() == lltok::kw_vscale) {
     Lex.Lex(); // consume the 'vscale'
-    if (ParseToken(lltok::kw_x, "expected 'x' after vscale"))
+    if (parseToken(lltok::kw_x, "expected 'x' after vscale"))
       return true;
 
     Scalable = true;
@@ -2878,34 +2961,35 @@ bool LLParser::ParseArrayVectorType(Type *&Result, bool isVector) {
 
   if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned() ||
       Lex.getAPSIntVal().getBitWidth() > 64)
-    return TokError("expected number in address space");
+    return tokError("expected number in address space");
 
   LocTy SizeLoc = Lex.getLoc();
   uint64_t Size = Lex.getAPSIntVal().getZExtValue();
   Lex.Lex();
 
-  if (ParseToken(lltok::kw_x, "expected 'x' after element count"))
-      return true;
+  if (parseToken(lltok::kw_x, "expected 'x' after element count"))
+    return true;
 
   LocTy TypeLoc = Lex.getLoc();
   Type *EltTy = nullptr;
-  if (ParseType(EltTy)) return true;
+  if (parseType(EltTy))
+    return true;
 
-  if (ParseToken(isVector ? lltok::greater : lltok::rsquare,
+  if (parseToken(IsVector ? lltok::greater : lltok::rsquare,
                  "expected end of sequential type"))
     return true;
 
-  if (isVector) {
+  if (IsVector) {
     if (Size == 0)
-      return Error(SizeLoc, "zero element vector is illegal");
+      return error(SizeLoc, "zero element vector is illegal");
     if ((unsigned)Size != Size)
-      return Error(SizeLoc, "size too large for vector");
+      return error(SizeLoc, "size too large for vector");
     if (!VectorType::isValidElementType(EltTy))
-      return Error(TypeLoc, "invalid vector element type");
+      return error(TypeLoc, "invalid vector element type");
     Result = VectorType::get(EltTy, unsigned(Size), Scalable);
   } else {
     if (!ArrayType::isValidElementType(EltTy))
-      return Error(TypeLoc, "invalid array element type");
+      return error(TypeLoc, "invalid array element type");
     Result = ArrayType::get(EltTy, Size);
   }
   return false;
@@ -2945,22 +3029,22 @@ LLParser::PerFunctionState::~PerFunctionState() {
   }
 }
 
-bool LLParser::PerFunctionState::FinishFunction() {
+bool LLParser::PerFunctionState::finishFunction() {
   if (!ForwardRefVals.empty())
-    return P.Error(ForwardRefVals.begin()->second.second,
+    return P.error(ForwardRefVals.begin()->second.second,
                    "use of undefined value '%" + ForwardRefVals.begin()->first +
-                   "'");
+                       "'");
   if (!ForwardRefValIDs.empty())
-    return P.Error(ForwardRefValIDs.begin()->second.second,
+    return P.error(ForwardRefValIDs.begin()->second.second,
                    "use of undefined value '%" +
-                   Twine(ForwardRefValIDs.begin()->first) + "'");
+                       Twine(ForwardRefValIDs.begin()->first) + "'");
   return false;
 }
 
-/// GetVal - Get a value with the specified name or ID, creating a
+/// getVal - Get a value with the specified name or ID, creating a
 /// forward reference record if needed.  This can return null if the value
 /// exists but does not have the right type.
-Value *LLParser::PerFunctionState::GetVal(const std::string &Name, Type *Ty,
+Value *LLParser::PerFunctionState::getVal(const std::string &Name, Type *Ty,
                                           LocTy Loc, bool IsCall) {
   // Look this name up in the normal function symbol table.
   Value *Val = F.getValueSymbolTable()->lookup(Name);
@@ -2979,7 +3063,7 @@ Value *LLParser::PerFunctionState::GetVal(const std::string &Name, Type *Ty,
 
   // Don't make placeholders with invalid type.
   if (!Ty->isFirstClassType()) {
-    P.Error(Loc, "invalid use of a non-first-class type");
+    P.error(Loc, "invalid use of a non-first-class type");
     return nullptr;
   }
 
@@ -2995,7 +3079,7 @@ Value *LLParser::PerFunctionState::GetVal(const std::string &Name, Type *Ty,
   return FwdVal;
 }
 
-Value *LLParser::PerFunctionState::GetVal(unsigned ID, Type *Ty, LocTy Loc,
+Value *LLParser::PerFunctionState::getVal(unsigned ID, Type *Ty, LocTy Loc,
                                           bool IsCall) {
   // Look this name up in the normal function symbol table.
   Value *Val = ID < NumberedVals.size() ? NumberedVals[ID] : nullptr;
@@ -3013,7 +3097,7 @@ Value *LLParser::PerFunctionState::GetVal(unsigned ID, Type *Ty, LocTy Loc,
     return P.checkValidVariableType(Loc, "%" + Twine(ID), Ty, Val, IsCall);
 
   if (!Ty->isFirstClassType()) {
-    P.Error(Loc, "invalid use of a non-first-class type");
+    P.error(Loc, "invalid use of a non-first-class type");
     return nullptr;
   }
 
@@ -3029,15 +3113,15 @@ Value *LLParser::PerFunctionState::GetVal(unsigned ID, Type *Ty, LocTy Loc,
   return FwdVal;
 }
 
-/// SetInstName - After an instruction is parsed and inserted into its
+/// setInstName - After an instruction is parsed and inserted into its
 /// basic block, this installs its name.
-bool LLParser::PerFunctionState::SetInstName(int NameID,
+bool LLParser::PerFunctionState::setInstName(int NameID,
                                              const std::string &NameStr,
                                              LocTy NameLoc, Instruction *Inst) {
   // If this instruction has void type, it cannot have a name or ID specified.
   if (Inst->getType()->isVoidTy()) {
     if (NameID != -1 || !NameStr.empty())
-      return P.Error(NameLoc, "instructions returning void cannot have a name");
+      return P.error(NameLoc, "instructions returning void cannot have a name");
     return false;
   }
 
@@ -3049,15 +3133,16 @@ bool LLParser::PerFunctionState::SetInstName(int NameID,
       NameID = NumberedVals.size();
 
     if (unsigned(NameID) != NumberedVals.size())
-      return P.Error(NameLoc, "instruction expected to be numbered '%" +
-                     Twine(NumberedVals.size()) + "'");
+      return P.error(NameLoc, "instruction expected to be numbered '%" +
+                                  Twine(NumberedVals.size()) + "'");
 
     auto FI = ForwardRefValIDs.find(NameID);
     if (FI != ForwardRefValIDs.end()) {
       Value *Sentinel = FI->second.first;
       if (Sentinel->getType() != Inst->getType())
-        return P.Error(NameLoc, "instruction forward referenced with type '" +
-                       getTypeString(FI->second.first->getType()) + "'");
+        return P.error(NameLoc, "instruction forward referenced with type '" +
+                                    getTypeString(FI->second.first->getType()) +
+                                    "'");
 
       Sentinel->replaceAllUsesWith(Inst);
       Sentinel->deleteValue();
@@ -3073,8 +3158,9 @@ bool LLParser::PerFunctionState::SetInstName(int NameID,
   if (FI != ForwardRefVals.end()) {
     Value *Sentinel = FI->second.first;
     if (Sentinel->getType() != Inst->getType())
-      return P.Error(NameLoc, "instruction forward referenced with type '" +
-                     getTypeString(FI->second.first->getType()) + "'");
+      return P.error(NameLoc, "instruction forward referenced with type '" +
+                                  getTypeString(FI->second.first->getType()) +
+                                  "'");
 
     Sentinel->replaceAllUsesWith(Inst);
     Sentinel->deleteValue();
@@ -3085,46 +3171,46 @@ bool LLParser::PerFunctionState::SetInstName(int NameID,
   Inst->setName(NameStr);
 
   if (Inst->getName() != NameStr)
-    return P.Error(NameLoc, "multiple definition of local value named '" +
-                   NameStr + "'");
+    return P.error(NameLoc, "multiple definition of local value named '" +
+                                NameStr + "'");
   return false;
 }
 
-/// GetBB - Get a basic block with the specified name or ID, creating a
+/// getBB - Get a basic block with the specified name or ID, creating a
 /// forward reference record if needed.
-BasicBlock *LLParser::PerFunctionState::GetBB(const std::string &Name,
+BasicBlock *LLParser::PerFunctionState::getBB(const std::string &Name,
                                               LocTy Loc) {
   return dyn_cast_or_null<BasicBlock>(
-      GetVal(Name, Type::getLabelTy(F.getContext()), Loc, /*IsCall=*/false));
+      getVal(Name, Type::getLabelTy(F.getContext()), Loc, /*IsCall=*/false));
 }
 
-BasicBlock *LLParser::PerFunctionState::GetBB(unsigned ID, LocTy Loc) {
+BasicBlock *LLParser::PerFunctionState::getBB(unsigned ID, LocTy Loc) {
   return dyn_cast_or_null<BasicBlock>(
-      GetVal(ID, Type::getLabelTy(F.getContext()), Loc, /*IsCall=*/false));
+      getVal(ID, Type::getLabelTy(F.getContext()), Loc, /*IsCall=*/false));
 }
 
-/// DefineBB - Define the specified basic block, which is either named or
+/// defineBB - Define the specified basic block, which is either named or
 /// unnamed.  If there is an error, this returns null otherwise it returns
 /// the block being defined.
-BasicBlock *LLParser::PerFunctionState::DefineBB(const std::string &Name,
+BasicBlock *LLParser::PerFunctionState::defineBB(const std::string &Name,
                                                  int NameID, LocTy Loc) {
   BasicBlock *BB;
   if (Name.empty()) {
     if (NameID != -1 && unsigned(NameID) != NumberedVals.size()) {
-      P.Error(Loc, "label expected to be numbered '" +
+      P.error(Loc, "label expected to be numbered '" +
                        Twine(NumberedVals.size()) + "'");
       return nullptr;
     }
-    BB = GetBB(NumberedVals.size(), Loc);
+    BB = getBB(NumberedVals.size(), Loc);
     if (!BB) {
-      P.Error(Loc, "unable to create block numbered '" +
+      P.error(Loc, "unable to create block numbered '" +
                        Twine(NumberedVals.size()) + "'");
       return nullptr;
     }
   } else {
-    BB = GetBB(Name, Loc);
+    BB = getBB(Name, Loc);
     if (!BB) {
-      P.Error(Loc, "unable to create block named '" + Name + "'");
+      P.error(Loc, "unable to create block named '" + Name + "'");
       return nullptr;
     }
   }
@@ -3149,16 +3235,17 @@ BasicBlock *LLParser::PerFunctionState::DefineBB(const std::string &Name,
 // Constants.
 //===----------------------------------------------------------------------===//
 
-/// ParseValID - Parse an abstract value that doesn't necessarily have a
+/// parseValID - parse an abstract value that doesn't necessarily have a
 /// type implied.  For example, if we parse "4" we don't know what integer type
 /// it has.  The value will later be combined with its type and checked for
 /// sanity.  PFS is used to convert function-local operands of metadata (since
 /// metadata operands are not just parsed here but also converted to values).
 /// PFS can be null when we are not parsing metadata values inside a function.
-bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
+bool LLParser::parseValID(ValID &ID, PerFunctionState *PFS) {
   ID.Loc = Lex.getLoc();
   switch (Lex.getKind()) {
-  default: return TokError("expected value token");
+  default:
+    return tokError("expected value token");
   case lltok::GlobalID:  // @42
     ID.UIntVal = Lex.getUIntVal();
     ID.Kind = ValID::t_GlobalID;
@@ -3193,6 +3280,7 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     break;
   case lltok::kw_null: ID.Kind = ValID::t_Null; break;
   case lltok::kw_undef: ID.Kind = ValID::t_Undef; break;
+  case lltok::kw_poison: ID.Kind = ValID::t_Poison; break;
   case lltok::kw_zeroinitializer: ID.Kind = ValID::t_Zero; break;
   case lltok::kw_none: ID.Kind = ValID::t_None; break;
 
@@ -3200,8 +3288,8 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     // ValID ::= '{' ConstVector '}'
     Lex.Lex();
     SmallVector<Constant*, 16> Elts;
-    if (ParseGlobalValueVector(Elts) ||
-        ParseToken(lltok::rbrace, "expected end of struct constant"))
+    if (parseGlobalValueVector(Elts) ||
+        parseToken(lltok::rbrace, "expected end of struct constant"))
       return true;
 
     ID.ConstantStructElts = std::make_unique<Constant *[]>(Elts.size());
@@ -3219,10 +3307,10 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
 
     SmallVector<Constant*, 16> Elts;
     LocTy FirstEltLoc = Lex.getLoc();
-    if (ParseGlobalValueVector(Elts) ||
+    if (parseGlobalValueVector(Elts) ||
         (isPackedStruct &&
-         ParseToken(lltok::rbrace, "expected end of packed struct")) ||
-        ParseToken(lltok::greater, "expected end of constant"))
+         parseToken(lltok::rbrace, "expected end of packed struct")) ||
+        parseToken(lltok::greater, "expected end of constant"))
       return true;
 
     if (isPackedStruct) {
@@ -3235,20 +3323,21 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     }
 
     if (Elts.empty())
-      return Error(ID.Loc, "constant vector must not be empty");
+      return error(ID.Loc, "constant vector must not be empty");
 
     if (!Elts[0]->getType()->isIntegerTy() &&
         !Elts[0]->getType()->isFloatingPointTy() &&
         !Elts[0]->getType()->isPointerTy())
-      return Error(FirstEltLoc,
-            "vector elements must have integer, pointer or floating point type");
+      return error(
+          FirstEltLoc,
+          "vector elements must have integer, pointer or floating point type");
 
     // Verify that all the vector elements have the same type.
     for (unsigned i = 1, e = Elts.size(); i != e; ++i)
       if (Elts[i]->getType() != Elts[0]->getType())
-        return Error(FirstEltLoc,
-                     "vector element #" + Twine(i) +
-                    " is not of type '" + getTypeString(Elts[0]->getType()));
+        return error(FirstEltLoc, "vector element #" + Twine(i) +
+                                      " is not of type '" +
+                                      getTypeString(Elts[0]->getType()));
 
     ID.ConstantVal = ConstantVector::get(Elts);
     ID.Kind = ValID::t_Constant;
@@ -3258,8 +3347,8 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     Lex.Lex();
     SmallVector<Constant*, 16> Elts;
     LocTy FirstEltLoc = Lex.getLoc();
-    if (ParseGlobalValueVector(Elts) ||
-        ParseToken(lltok::rsquare, "expected end of array constant"))
+    if (parseGlobalValueVector(Elts) ||
+        parseToken(lltok::rsquare, "expected end of array constant"))
       return true;
 
     // Handle empty element.
@@ -3271,17 +3360,17 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     }
 
     if (!Elts[0]->getType()->isFirstClassType())
-      return Error(FirstEltLoc, "invalid array element type: " +
-                   getTypeString(Elts[0]->getType()));
+      return error(FirstEltLoc, "invalid array element type: " +
+                                    getTypeString(Elts[0]->getType()));
 
     ArrayType *ATy = ArrayType::get(Elts[0]->getType(), Elts.size());
 
     // Verify all elements are correct type!
     for (unsigned i = 0, e = Elts.size(); i != e; ++i) {
       if (Elts[i]->getType() != Elts[0]->getType())
-        return Error(FirstEltLoc,
-                     "array element #" + Twine(i) +
-                     " is not of type '" + getTypeString(Elts[0]->getType()));
+        return error(FirstEltLoc, "array element #" + Twine(i) +
+                                      " is not of type '" +
+                                      getTypeString(Elts[0]->getType()));
     }
 
     ID.ConstantVal = ConstantArray::get(ATy, Elts);
@@ -3292,7 +3381,8 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     Lex.Lex();
     ID.ConstantVal = ConstantDataArray::getString(Context, Lex.getStrVal(),
                                                   false);
-    if (ParseToken(lltok::StringConstant, "expected string")) return true;
+    if (parseToken(lltok::StringConstant, "expected string"))
+      return true;
     ID.Kind = ValID::t_Constant;
     return false;
 
@@ -3301,12 +3391,12 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     //             STRINGCONSTANT
     bool HasSideEffect, AlignStack, AsmDialect;
     Lex.Lex();
-    if (ParseOptionalToken(lltok::kw_sideeffect, HasSideEffect) ||
-        ParseOptionalToken(lltok::kw_alignstack, AlignStack) ||
-        ParseOptionalToken(lltok::kw_inteldialect, AsmDialect) ||
-        ParseStringConstant(ID.StrVal) ||
-        ParseToken(lltok::comma, "expected comma in inline asm expression") ||
-        ParseToken(lltok::StringConstant, "expected constraint string"))
+    if (parseOptionalToken(lltok::kw_sideeffect, HasSideEffect) ||
+        parseOptionalToken(lltok::kw_alignstack, AlignStack) ||
+        parseOptionalToken(lltok::kw_inteldialect, AsmDialect) ||
+        parseStringConstant(ID.StrVal) ||
+        parseToken(lltok::comma, "expected comma in inline asm expression") ||
+        parseToken(lltok::StringConstant, "expected constraint string"))
       return true;
     ID.StrVal2 = Lex.getStrVal();
     ID.UIntVal = unsigned(HasSideEffect) | (unsigned(AlignStack)<<1) |
@@ -3321,17 +3411,18 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
 
     ValID Fn, Label;
 
-    if (ParseToken(lltok::lparen, "expected '(' in block address expression") ||
-        ParseValID(Fn) ||
-        ParseToken(lltok::comma, "expected comma in block address expression")||
-        ParseValID(Label) ||
-        ParseToken(lltok::rparen, "expected ')' in block address expression"))
+    if (parseToken(lltok::lparen, "expected '(' in block address expression") ||
+        parseValID(Fn) ||
+        parseToken(lltok::comma,
+                   "expected comma in block address expression") ||
+        parseValID(Label) ||
+        parseToken(lltok::rparen, "expected ')' in block address expression"))
       return true;
 
     if (Fn.Kind != ValID::t_GlobalID && Fn.Kind != ValID::t_GlobalName)
-      return Error(Fn.Loc, "expected function name in blockaddress");
+      return error(Fn.Loc, "expected function name in blockaddress");
     if (Label.Kind != ValID::t_LocalID && Label.Kind != ValID::t_LocalName)
-      return Error(Label.Loc, "expected basic block name in blockaddress");
+      return error(Label.Loc, "expected basic block name in blockaddress");
 
     // Try to find the function (but skip it if it's forward-referenced).
     GlobalValue *GV = nullptr;
@@ -3345,10 +3436,10 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     if (GV) {
       // Confirm that it's actually a function with a definition.
       if (!isa<Function>(GV))
-        return Error(Fn.Loc, "expected function name in blockaddress");
+        return error(Fn.Loc, "expected function name in blockaddress");
       F = cast<Function>(GV);
       if (F->isDeclaration())
-        return Error(Fn.Loc, "cannot take blockaddress inside a declaration");
+        return error(Fn.Loc, "cannot take blockaddress inside a declaration");
     }
 
     if (!F) {
@@ -3372,19 +3463,19 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     BasicBlock *BB;
     if (BlockAddressPFS && F == &BlockAddressPFS->getFunction()) {
       if (Label.Kind == ValID::t_LocalID)
-        BB = BlockAddressPFS->GetBB(Label.UIntVal, Label.Loc);
+        BB = BlockAddressPFS->getBB(Label.UIntVal, Label.Loc);
       else
-        BB = BlockAddressPFS->GetBB(Label.StrVal, Label.Loc);
+        BB = BlockAddressPFS->getBB(Label.StrVal, Label.Loc);
       if (!BB)
-        return Error(Label.Loc, "referenced value is not a basic block");
+        return error(Label.Loc, "referenced value is not a basic block");
     } else {
       if (Label.Kind == ValID::t_LocalID)
-        return Error(Label.Loc, "cannot take address of numeric label after "
+        return error(Label.Loc, "cannot take address of numeric label after "
                                 "the function is defined");
       BB = dyn_cast_or_null<BasicBlock>(
           F->getValueSymbolTable()->lookup(Label.StrVal));
       if (!BB)
-        return Error(Label.Loc, "referenced value is not a basic block");
+        return error(Label.Loc, "referenced value is not a basic block");
     }
 
     ID.ConstantVal = BlockAddress::get(F, BB);
@@ -3392,6 +3483,39 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     return false;
   }
 
+  case lltok::kw_dso_local_equivalent: {
+    // ValID ::= 'dso_local_equivalent' @foo
+    Lex.Lex();
+
+    ValID Fn;
+
+    if (parseValID(Fn))
+      return true;
+
+    if (Fn.Kind != ValID::t_GlobalID && Fn.Kind != ValID::t_GlobalName)
+      return error(Fn.Loc,
+                   "expected global value name in dso_local_equivalent");
+
+    // Try to find the function (but skip it if it's forward-referenced).
+    GlobalValue *GV = nullptr;
+    if (Fn.Kind == ValID::t_GlobalID) {
+      if (Fn.UIntVal < NumberedVals.size())
+        GV = NumberedVals[Fn.UIntVal];
+    } else if (!ForwardRefVals.count(Fn.StrVal)) {
+      GV = M->getNamedValue(Fn.StrVal);
+    }
+
+    assert(GV && "Could not find a corresponding global variable");
+
+    if (!GV->getValueType()->isFunctionTy())
+      return error(Fn.Loc, "expected a function, alias to function, or ifunc "
+                           "in dso_local_equivalent");
+
+    ID.ConstantVal = DSOLocalEquivalent::get(GV);
+    ID.Kind = ValID::t_Constant;
+    return false;
+  }
+
   case lltok::kw_trunc:
   case lltok::kw_zext:
   case lltok::kw_sext:
@@ -3409,16 +3533,16 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     Type *DestTy = nullptr;
     Constant *SrcVal;
     Lex.Lex();
-    if (ParseToken(lltok::lparen, "expected '(' after constantexpr cast") ||
-        ParseGlobalTypeAndValue(SrcVal) ||
-        ParseToken(lltok::kw_to, "expected 'to' in constantexpr cast") ||
-        ParseType(DestTy) ||
-        ParseToken(lltok::rparen, "expected ')' at end of constantexpr cast"))
+    if (parseToken(lltok::lparen, "expected '(' after constantexpr cast") ||
+        parseGlobalTypeAndValue(SrcVal) ||
+        parseToken(lltok::kw_to, "expected 'to' in constantexpr cast") ||
+        parseType(DestTy) ||
+        parseToken(lltok::rparen, "expected ')' at end of constantexpr cast"))
       return true;
     if (!CastInst::castIsValid((Instruction::CastOps)Opc, SrcVal, DestTy))
-      return Error(ID.Loc, "invalid cast opcode for cast from '" +
-                   getTypeString(SrcVal->getType()) + "' to '" +
-                   getTypeString(DestTy) + "'");
+      return error(ID.Loc, "invalid cast opcode for cast from '" +
+                               getTypeString(SrcVal->getType()) + "' to '" +
+                               getTypeString(DestTy) + "'");
     ID.ConstantVal = ConstantExpr::getCast((Instruction::CastOps)Opc,
                                                  SrcVal, DestTy);
     ID.Kind = ValID::t_Constant;
@@ -3428,16 +3552,16 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     Lex.Lex();
     Constant *Val;
     SmallVector<unsigned, 4> Indices;
-    if (ParseToken(lltok::lparen, "expected '(' in extractvalue constantexpr")||
-        ParseGlobalTypeAndValue(Val) ||
-        ParseIndexList(Indices) ||
-        ParseToken(lltok::rparen, "expected ')' in extractvalue constantexpr"))
+    if (parseToken(lltok::lparen,
+                   "expected '(' in extractvalue constantexpr") ||
+        parseGlobalTypeAndValue(Val) || parseIndexList(Indices) ||
+        parseToken(lltok::rparen, "expected ')' in extractvalue constantexpr"))
       return true;
 
     if (!Val->getType()->isAggregateType())
-      return Error(ID.Loc, "extractvalue operand must be aggregate type");
+      return error(ID.Loc, "extractvalue operand must be aggregate type");
     if (!ExtractValueInst::getIndexedType(Val->getType(), Indices))
-      return Error(ID.Loc, "invalid indices for extractvalue");
+      return error(ID.Loc, "invalid indices for extractvalue");
     ID.ConstantVal = ConstantExpr::getExtractValue(Val, Indices);
     ID.Kind = ValID::t_Constant;
     return false;
@@ -3446,21 +3570,21 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     Lex.Lex();
     Constant *Val0, *Val1;
     SmallVector<unsigned, 4> Indices;
-    if (ParseToken(lltok::lparen, "expected '(' in insertvalue constantexpr")||
-        ParseGlobalTypeAndValue(Val0) ||
-        ParseToken(lltok::comma, "expected comma in insertvalue constantexpr")||
-        ParseGlobalTypeAndValue(Val1) ||
-        ParseIndexList(Indices) ||
-        ParseToken(lltok::rparen, "expected ')' in insertvalue constantexpr"))
+    if (parseToken(lltok::lparen, "expected '(' in insertvalue constantexpr") ||
+        parseGlobalTypeAndValue(Val0) ||
+        parseToken(lltok::comma,
+                   "expected comma in insertvalue constantexpr") ||
+        parseGlobalTypeAndValue(Val1) || parseIndexList(Indices) ||
+        parseToken(lltok::rparen, "expected ')' in insertvalue constantexpr"))
       return true;
     if (!Val0->getType()->isAggregateType())
-      return Error(ID.Loc, "insertvalue operand must be aggregate type");
+      return error(ID.Loc, "insertvalue operand must be aggregate type");
     Type *IndexedType =
         ExtractValueInst::getIndexedType(Val0->getType(), Indices);
     if (!IndexedType)
-      return Error(ID.Loc, "invalid indices for insertvalue");
+      return error(ID.Loc, "invalid indices for insertvalue");
     if (IndexedType != Val1->getType())
-      return Error(ID.Loc, "insertvalue operand and field disagree in type: '" +
+      return error(ID.Loc, "insertvalue operand and field disagree in type: '" +
                                getTypeString(Val1->getType()) +
                                "' instead of '" + getTypeString(IndexedType) +
                                "'");
@@ -3473,28 +3597,28 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     unsigned PredVal, Opc = Lex.getUIntVal();
     Constant *Val0, *Val1;
     Lex.Lex();
-    if (ParseCmpPredicate(PredVal, Opc) ||
-        ParseToken(lltok::lparen, "expected '(' in compare constantexpr") ||
-        ParseGlobalTypeAndValue(Val0) ||
-        ParseToken(lltok::comma, "expected comma in compare constantexpr") ||
-        ParseGlobalTypeAndValue(Val1) ||
-        ParseToken(lltok::rparen, "expected ')' in compare constantexpr"))
+    if (parseCmpPredicate(PredVal, Opc) ||
+        parseToken(lltok::lparen, "expected '(' in compare constantexpr") ||
+        parseGlobalTypeAndValue(Val0) ||
+        parseToken(lltok::comma, "expected comma in compare constantexpr") ||
+        parseGlobalTypeAndValue(Val1) ||
+        parseToken(lltok::rparen, "expected ')' in compare constantexpr"))
       return true;
 
     if (Val0->getType() != Val1->getType())
-      return Error(ID.Loc, "compare operands must have the same type");
+      return error(ID.Loc, "compare operands must have the same type");
 
     CmpInst::Predicate Pred = (CmpInst::Predicate)PredVal;
 
     if (Opc == Instruction::FCmp) {
       if (!Val0->getType()->isFPOrFPVectorTy())
-        return Error(ID.Loc, "fcmp requires floating point operands");
+        return error(ID.Loc, "fcmp requires floating point operands");
       ID.ConstantVal = ConstantExpr::getFCmp(Pred, Val0, Val1);
     } else {
       assert(Opc == Instruction::ICmp && "Unexpected opcode for CmpInst!");
       if (!Val0->getType()->isIntOrIntVectorTy() &&
           !Val0->getType()->isPtrOrPtrVectorTy())
-        return Error(ID.Loc, "icmp requires pointer or integer operands");
+        return error(ID.Loc, "icmp requires pointer or integer operands");
       ID.ConstantVal = ConstantExpr::getICmp(Pred, Val0, Val1);
     }
     ID.Kind = ValID::t_Constant;
@@ -3506,16 +3630,16 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     unsigned Opc = Lex.getUIntVal();
     Constant *Val;
     Lex.Lex();
-    if (ParseToken(lltok::lparen, "expected '(' in unary constantexpr") ||
-        ParseGlobalTypeAndValue(Val) ||
-        ParseToken(lltok::rparen, "expected ')' in unary constantexpr"))
+    if (parseToken(lltok::lparen, "expected '(' in unary constantexpr") ||
+        parseGlobalTypeAndValue(Val) ||
+        parseToken(lltok::rparen, "expected ')' in unary constantexpr"))
       return true;
 
     // Check that the type is valid for the operator.
     switch (Opc) {
     case Instruction::FNeg:
       if (!Val->getType()->isFPOrFPVectorTy())
-        return Error(ID.Loc, "constexpr requires fp operands");
+        return error(ID.Loc, "constexpr requires fp operands");
       break;
     default: llvm_unreachable("Unknown unary operator!");
     }
@@ -3561,14 +3685,14 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
       if (EatIfPresent(lltok::kw_exact))
         Exact = true;
     }
-    if (ParseToken(lltok::lparen, "expected '(' in binary constantexpr") ||
-        ParseGlobalTypeAndValue(Val0) ||
-        ParseToken(lltok::comma, "expected comma in binary constantexpr") ||
-        ParseGlobalTypeAndValue(Val1) ||
-        ParseToken(lltok::rparen, "expected ')' in binary constantexpr"))
+    if (parseToken(lltok::lparen, "expected '(' in binary constantexpr") ||
+        parseGlobalTypeAndValue(Val0) ||
+        parseToken(lltok::comma, "expected comma in binary constantexpr") ||
+        parseGlobalTypeAndValue(Val1) ||
+        parseToken(lltok::rparen, "expected ')' in binary constantexpr"))
       return true;
     if (Val0->getType() != Val1->getType())
-      return Error(ID.Loc, "operands of constexpr must have same type");
+      return error(ID.Loc, "operands of constexpr must have same type");
     // Check that the type is valid for the operator.
     switch (Opc) {
     case Instruction::Add:
@@ -3582,7 +3706,7 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     case Instruction::AShr:
     case Instruction::LShr:
       if (!Val0->getType()->isIntOrIntVectorTy())
-        return Error(ID.Loc, "constexpr requires integer operands");
+        return error(ID.Loc, "constexpr requires integer operands");
       break;
     case Instruction::FAdd:
     case Instruction::FSub:
@@ -3590,7 +3714,7 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     case Instruction::FDiv:
     case Instruction::FRem:
       if (!Val0->getType()->isFPOrFPVectorTy())
-        return Error(ID.Loc, "constexpr requires fp operands");
+        return error(ID.Loc, "constexpr requires fp operands");
       break;
     default: llvm_unreachable("Unknown binary operator!");
     }
@@ -3611,16 +3735,16 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     unsigned Opc = Lex.getUIntVal();
     Constant *Val0, *Val1;
     Lex.Lex();
-    if (ParseToken(lltok::lparen, "expected '(' in logical constantexpr") ||
-        ParseGlobalTypeAndValue(Val0) ||
-        ParseToken(lltok::comma, "expected comma in logical constantexpr") ||
-        ParseGlobalTypeAndValue(Val1) ||
-        ParseToken(lltok::rparen, "expected ')' in logical constantexpr"))
+    if (parseToken(lltok::lparen, "expected '(' in logical constantexpr") ||
+        parseGlobalTypeAndValue(Val0) ||
+        parseToken(lltok::comma, "expected comma in logical constantexpr") ||
+        parseGlobalTypeAndValue(Val1) ||
+        parseToken(lltok::rparen, "expected ')' in logical constantexpr"))
       return true;
     if (Val0->getType() != Val1->getType())
-      return Error(ID.Loc, "operands of constexpr must have same type");
+      return error(ID.Loc, "operands of constexpr must have same type");
     if (!Val0->getType()->isIntOrIntVectorTy())
-      return Error(ID.Loc,
+      return error(ID.Loc,
                    "constexpr requires integer or integer vector operands");
     ID.ConstantVal = ConstantExpr::get(Opc, Val0, Val1);
     ID.Kind = ValID::t_Constant;
@@ -3641,31 +3765,31 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
     if (Opc == Instruction::GetElementPtr)
       InBounds = EatIfPresent(lltok::kw_inbounds);
 
-    if (ParseToken(lltok::lparen, "expected '(' in constantexpr"))
+    if (parseToken(lltok::lparen, "expected '(' in constantexpr"))
       return true;
 
     LocTy ExplicitTypeLoc = Lex.getLoc();
     if (Opc == Instruction::GetElementPtr) {
-      if (ParseType(Ty) ||
-          ParseToken(lltok::comma, "expected comma after getelementptr's type"))
+      if (parseType(Ty) ||
+          parseToken(lltok::comma, "expected comma after getelementptr's type"))
         return true;
     }
 
     Optional<unsigned> InRangeOp;
-    if (ParseGlobalValueVector(
+    if (parseGlobalValueVector(
             Elts, Opc == Instruction::GetElementPtr ? &InRangeOp : nullptr) ||
-        ParseToken(lltok::rparen, "expected ')' in constantexpr"))
+        parseToken(lltok::rparen, "expected ')' in constantexpr"))
       return true;
 
     if (Opc == Instruction::GetElementPtr) {
       if (Elts.size() == 0 ||
           !Elts[0]->getType()->isPtrOrPtrVectorTy())
-        return Error(ID.Loc, "base of getelementptr must be a pointer");
+        return error(ID.Loc, "base of getelementptr must be a pointer");
 
       Type *BaseType = Elts[0]->getType();
       auto *BasePointerType = cast<PointerType>(BaseType->getScalarType());
       if (Ty != BasePointerType->getElementType())
-        return Error(
+        return error(
             ExplicitTypeLoc,
             "explicit pointee type doesn't match operand's pointee type");
 
@@ -3678,11 +3802,11 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
       for (Constant *Val : Indices) {
         Type *ValTy = Val->getType();
         if (!ValTy->isIntOrIntVectorTy())
-          return Error(ID.Loc, "getelementptr index must be an integer");
+          return error(ID.Loc, "getelementptr index must be an integer");
         if (auto *ValVTy = dyn_cast<VectorType>(ValTy)) {
           unsigned ValNumEl = cast<FixedVectorType>(ValVTy)->getNumElements();
           if (GEPWidth && (ValNumEl != GEPWidth))
-            return Error(
+            return error(
                 ID.Loc,
                 "getelementptr vector index has a wrong number of elements");
           // GEPWidth may have been unknown because the base is a scalar,
@@ -3693,14 +3817,14 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
 
       SmallPtrSet<Type*, 4> Visited;
       if (!Indices.empty() && !Ty->isSized(&Visited))
-        return Error(ID.Loc, "base element of getelementptr must be sized");
+        return error(ID.Loc, "base element of getelementptr must be sized");
 
       if (!GetElementPtrInst::getIndexedType(Ty, Indices))
-        return Error(ID.Loc, "invalid getelementptr indices");
+        return error(ID.Loc, "invalid getelementptr indices");
 
       if (InRangeOp) {
         if (*InRangeOp == 0)
-          return Error(ID.Loc,
+          return error(ID.Loc,
                        "inrange keyword may not appear on pointer operand");
         --*InRangeOp;
       }
@@ -3709,31 +3833,31 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
                                                       InBounds, InRangeOp);
     } else if (Opc == Instruction::Select) {
       if (Elts.size() != 3)
-        return Error(ID.Loc, "expected three operands to select");
+        return error(ID.Loc, "expected three operands to select");
       if (const char *Reason = SelectInst::areInvalidOperands(Elts[0], Elts[1],
                                                               Elts[2]))
-        return Error(ID.Loc, Reason);
+        return error(ID.Loc, Reason);
       ID.ConstantVal = ConstantExpr::getSelect(Elts[0], Elts[1], Elts[2]);
     } else if (Opc == Instruction::ShuffleVector) {
       if (Elts.size() != 3)
-        return Error(ID.Loc, "expected three operands to shufflevector");
+        return error(ID.Loc, "expected three operands to shufflevector");
       if (!ShuffleVectorInst::isValidOperands(Elts[0], Elts[1], Elts[2]))
-        return Error(ID.Loc, "invalid operands to shufflevector");
+        return error(ID.Loc, "invalid operands to shufflevector");
       SmallVector<int, 16> Mask;
       ShuffleVectorInst::getShuffleMask(cast<Constant>(Elts[2]), Mask);
       ID.ConstantVal = ConstantExpr::getShuffleVector(Elts[0], Elts[1], Mask);
     } else if (Opc == Instruction::ExtractElement) {
       if (Elts.size() != 2)
-        return Error(ID.Loc, "expected two operands to extractelement");
+        return error(ID.Loc, "expected two operands to extractelement");
       if (!ExtractElementInst::isValidOperands(Elts[0], Elts[1]))
-        return Error(ID.Loc, "invalid extractelement operands");
+        return error(ID.Loc, "invalid extractelement operands");
       ID.ConstantVal = ConstantExpr::getExtractElement(Elts[0], Elts[1]);
     } else {
       assert(Opc == Instruction::InsertElement && "Unknown opcode");
       if (Elts.size() != 3)
-      return Error(ID.Loc, "expected three operands to insertelement");
+        return error(ID.Loc, "expected three operands to insertelement");
       if (!InsertElementInst::isValidOperands(Elts[0], Elts[1], Elts[2]))
-        return Error(ID.Loc, "invalid insertelement operands");
+        return error(ID.Loc, "invalid insertelement operands");
       ID.ConstantVal =
                  ConstantExpr::getInsertElement(Elts[0], Elts[1],Elts[2]);
     }
@@ -3747,22 +3871,21 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
   return false;
 }
 
-/// ParseGlobalValue - Parse a global value with the specified type.
-bool LLParser::ParseGlobalValue(Type *Ty, Constant *&C) {
+/// parseGlobalValue - parse a global value with the specified type.
+bool LLParser::parseGlobalValue(Type *Ty, Constant *&C) {
   C = nullptr;
   ValID ID;
   Value *V = nullptr;
-  bool Parsed = ParseValID(ID) ||
-                ConvertValIDToValue(Ty, ID, V, nullptr, /*IsCall=*/false);
+  bool Parsed = parseValID(ID) ||
+                convertValIDToValue(Ty, ID, V, nullptr, /*IsCall=*/false);
   if (V && !(C = dyn_cast<Constant>(V)))
-    return Error(ID.Loc, "global values must be constants");
+    return error(ID.Loc, "global values must be constants");
   return Parsed;
 }
 
-bool LLParser::ParseGlobalTypeAndValue(Constant *&V) {
+bool LLParser::parseGlobalTypeAndValue(Constant *&V) {
   Type *Ty = nullptr;
-  return ParseType(Ty) ||
-         ParseGlobalValue(Ty, V);
+  return parseType(Ty) || parseGlobalValue(Ty, V);
 }
 
 bool LLParser::parseOptionalComdat(StringRef GlobalName, Comdat *&C) {
@@ -3774,24 +3897,24 @@ bool LLParser::parseOptionalComdat(StringRef GlobalName, Comdat *&C) {
 
   if (EatIfPresent(lltok::lparen)) {
     if (Lex.getKind() != lltok::ComdatVar)
-      return TokError("expected comdat variable");
+      return tokError("expected comdat variable");
     C = getComdat(Lex.getStrVal(), Lex.getLoc());
     Lex.Lex();
-    if (ParseToken(lltok::rparen, "expected ')' after comdat var"))
+    if (parseToken(lltok::rparen, "expected ')' after comdat var"))
       return true;
   } else {
     if (GlobalName.empty())
-      return TokError("comdat cannot be unnamed");
+      return tokError("comdat cannot be unnamed");
     C = getComdat(std::string(GlobalName), KwLoc);
   }
 
   return false;
 }
 
-/// ParseGlobalValueVector
+/// parseGlobalValueVector
 ///   ::= /*empty*/
 ///   ::= [inrange] TypeAndValue (',' [inrange] TypeAndValue)*
-bool LLParser::ParseGlobalValueVector(SmallVectorImpl<Constant *> &Elts,
+bool LLParser::parseGlobalValueVector(SmallVectorImpl<Constant *> &Elts,
                                       Optional<unsigned> *InRangeOp) {
   // Empty list.
   if (Lex.getKind() == lltok::rbrace ||
@@ -3805,16 +3928,17 @@ bool LLParser::ParseGlobalValueVector(SmallVectorImpl<Constant *> &Elts,
       *InRangeOp = Elts.size();
 
     Constant *C;
-    if (ParseGlobalTypeAndValue(C)) return true;
+    if (parseGlobalTypeAndValue(C))
+      return true;
     Elts.push_back(C);
   } while (EatIfPresent(lltok::comma));
 
   return false;
 }
 
-bool LLParser::ParseMDTuple(MDNode *&MD, bool IsDistinct) {
+bool LLParser::parseMDTuple(MDNode *&MD, bool IsDistinct) {
   SmallVector<Metadata *, 16> Elts;
-  if (ParseMDNodeVector(Elts))
+  if (parseMDNodeVector(Elts))
     return true;
 
   MD = (IsDistinct ? MDTuple::getDistinct : MDTuple::get)(Context, Elts);
@@ -3825,21 +3949,20 @@ bool LLParser::ParseMDTuple(MDNode *&MD, bool IsDistinct) {
 ///  ::= !{ ... }
 ///  ::= !7
 ///  ::= !DILocation(...)
-bool LLParser::ParseMDNode(MDNode *&N) {
+bool LLParser::parseMDNode(MDNode *&N) {
   if (Lex.getKind() == lltok::MetadataVar)
-    return ParseSpecializedMDNode(N);
+    return parseSpecializedMDNode(N);
 
-  return ParseToken(lltok::exclaim, "expected '!' here") ||
-         ParseMDNodeTail(N);
+  return parseToken(lltok::exclaim, "expected '!' here") || parseMDNodeTail(N);
 }
 
-bool LLParser::ParseMDNodeTail(MDNode *&N) {
+bool LLParser::parseMDNodeTail(MDNode *&N) {
   // !{ ... }
   if (Lex.getKind() == lltok::lbrace)
-    return ParseMDTuple(N);
+    return parseMDTuple(N);
 
   // !42
-  return ParseMDNodeID(N);
+  return parseMDNodeID(N);
 }
 
 namespace {
@@ -4037,9 +4160,9 @@ struct MDSignedOrUnsignedField
 namespace llvm {
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, MDAPSIntField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, MDAPSIntField &Result) {
   if (Lex.getKind() != lltok::APSInt)
-    return TokError("expected integer");
+    return tokError("expected integer");
 
   Result.assign(Lex.getAPSIntVal());
   Lex.Lex();
@@ -4047,14 +4170,14 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name, MDAPSIntField &Result) {
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
+bool LLParser::parseMDField(LocTy Loc, StringRef Name,
                             MDUnsignedField &Result) {
   if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned())
-    return TokError("expected unsigned integer");
+    return tokError("expected unsigned integer");
 
   auto &U = Lex.getAPSIntVal();
   if (U.ugt(Result.Max))
-    return TokError("value for '" + Name + "' too large, limit is " +
+    return tokError("value for '" + Name + "' too large, limit is " +
                     Twine(Result.Max));
   Result.assign(U.getZExtValue());
   assert(Result.Val <= Result.Max && "Expected value in range");
@@ -4063,25 +4186,25 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, LineField &Result) {
-  return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, LineField &Result) {
+  return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 }
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, ColumnField &Result) {
-  return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, ColumnField &Result) {
+  return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DwarfTagField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, DwarfTagField &Result) {
   if (Lex.getKind() == lltok::APSInt)
-    return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 
   if (Lex.getKind() != lltok::DwarfTag)
-    return TokError("expected DWARF tag");
+    return tokError("expected DWARF tag");
 
   unsigned Tag = dwarf::getTag(Lex.getStrVal());
   if (Tag == dwarf::DW_TAG_invalid)
-    return TokError("invalid DWARF tag" + Twine(" '") + Lex.getStrVal() + "'");
+    return tokError("invalid DWARF tag" + Twine(" '") + Lex.getStrVal() + "'");
   assert(Tag <= Result.Max && "Expected valid DWARF tag");
 
   Result.assign(Tag);
@@ -4090,18 +4213,18 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DwarfTagField &Result) {
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
+bool LLParser::parseMDField(LocTy Loc, StringRef Name,
                             DwarfMacinfoTypeField &Result) {
   if (Lex.getKind() == lltok::APSInt)
-    return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 
   if (Lex.getKind() != lltok::DwarfMacinfo)
-    return TokError("expected DWARF macinfo type");
+    return tokError("expected DWARF macinfo type");
 
   unsigned Macinfo = dwarf::getMacinfo(Lex.getStrVal());
   if (Macinfo == dwarf::DW_MACINFO_invalid)
-    return TokError(
-        "invalid DWARF macinfo type" + Twine(" '") + Lex.getStrVal() + "'");
+    return tokError("invalid DWARF macinfo type" + Twine(" '") +
+                    Lex.getStrVal() + "'");
   assert(Macinfo <= Result.Max && "Expected valid DWARF macinfo type");
 
   Result.assign(Macinfo);
@@ -4110,17 +4233,17 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
+bool LLParser::parseMDField(LocTy Loc, StringRef Name,
                             DwarfVirtualityField &Result) {
   if (Lex.getKind() == lltok::APSInt)
-    return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 
   if (Lex.getKind() != lltok::DwarfVirtuality)
-    return TokError("expected DWARF virtuality code");
+    return tokError("expected DWARF virtuality code");
 
   unsigned Virtuality = dwarf::getVirtuality(Lex.getStrVal());
   if (Virtuality == dwarf::DW_VIRTUALITY_invalid)
-    return TokError("invalid DWARF virtuality code" + Twine(" '") +
+    return tokError("invalid DWARF virtuality code" + Twine(" '") +
                     Lex.getStrVal() + "'");
   assert(Virtuality <= Result.Max && "Expected valid DWARF virtuality code");
   Result.assign(Virtuality);
@@ -4129,16 +4252,16 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DwarfLangField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, DwarfLangField &Result) {
   if (Lex.getKind() == lltok::APSInt)
-    return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 
   if (Lex.getKind() != lltok::DwarfLang)
-    return TokError("expected DWARF language");
+    return tokError("expected DWARF language");
 
   unsigned Lang = dwarf::getLanguage(Lex.getStrVal());
   if (!Lang)
-    return TokError("invalid DWARF language" + Twine(" '") + Lex.getStrVal() +
+    return tokError("invalid DWARF language" + Twine(" '") + Lex.getStrVal() +
                     "'");
   assert(Lang <= Result.Max && "Expected valid DWARF language");
   Result.assign(Lang);
@@ -4147,17 +4270,17 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DwarfLangField &Result) {
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DwarfCCField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, DwarfCCField &Result) {
   if (Lex.getKind() == lltok::APSInt)
-    return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 
   if (Lex.getKind() != lltok::DwarfCC)
-    return TokError("expected DWARF calling convention");
+    return tokError("expected DWARF calling convention");
 
   unsigned CC = dwarf::getCallingConvention(Lex.getStrVal());
   if (!CC)
-    return TokError("invalid DWARF calling convention" + Twine(" '") + Lex.getStrVal() +
-                    "'");
+    return tokError("invalid DWARF calling convention" + Twine(" '") +
+                    Lex.getStrVal() + "'");
   assert(CC <= Result.Max && "Expected valid DWARF calling convention");
   Result.assign(CC);
   Lex.Lex();
@@ -4165,16 +4288,17 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DwarfCCField &Result) {
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, EmissionKindField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name,
+                            EmissionKindField &Result) {
   if (Lex.getKind() == lltok::APSInt)
-    return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 
   if (Lex.getKind() != lltok::EmissionKind)
-    return TokError("expected emission kind");
+    return tokError("expected emission kind");
 
   auto Kind = DICompileUnit::getEmissionKind(Lex.getStrVal());
   if (!Kind)
-    return TokError("invalid emission kind" + Twine(" '") + Lex.getStrVal() +
+    return tokError("invalid emission kind" + Twine(" '") + Lex.getStrVal() +
                     "'");
   assert(*Kind <= Result.Max && "Expected valid emission kind");
   Result.assign(*Kind);
@@ -4183,17 +4307,17 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name, EmissionKindField &Result
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
+bool LLParser::parseMDField(LocTy Loc, StringRef Name,
                             NameTableKindField &Result) {
   if (Lex.getKind() == lltok::APSInt)
-    return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 
   if (Lex.getKind() != lltok::NameTableKind)
-    return TokError("expected nameTable kind");
+    return tokError("expected nameTable kind");
 
   auto Kind = DICompileUnit::getNameTableKind(Lex.getStrVal());
   if (!Kind)
-    return TokError("invalid nameTable kind" + Twine(" '") + Lex.getStrVal() +
+    return tokError("invalid nameTable kind" + Twine(" '") + Lex.getStrVal() +
                     "'");
   assert(((unsigned)*Kind) <= Result.Max && "Expected valid nameTable kind");
   Result.assign((unsigned)*Kind);
@@ -4202,17 +4326,17 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
+bool LLParser::parseMDField(LocTy Loc, StringRef Name,
                             DwarfAttEncodingField &Result) {
   if (Lex.getKind() == lltok::APSInt)
-    return ParseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
+    return parseMDField(Loc, Name, static_cast<MDUnsignedField &>(Result));
 
   if (Lex.getKind() != lltok::DwarfAttEncoding)
-    return TokError("expected DWARF type attribute encoding");
+    return tokError("expected DWARF type attribute encoding");
 
   unsigned Encoding = dwarf::getAttributeEncoding(Lex.getStrVal());
   if (!Encoding)
-    return TokError("invalid DWARF type attribute encoding" + Twine(" '") +
+    return tokError("invalid DWARF type attribute encoding" + Twine(" '") +
                     Lex.getStrVal() + "'");
   assert(Encoding <= Result.Max && "Expected valid DWARF language");
   Result.assign(Encoding);
@@ -4225,29 +4349,29 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 ///  ::= DIFlagVector
 ///  ::= DIFlagVector '|' DIFlagFwdDecl '|' uint32 '|' DIFlagPublic
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DIFlagField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, DIFlagField &Result) {
 
-  // Parser for a single flag.
+  // parser for a single flag.
   auto parseFlag = [&](DINode::DIFlags &Val) {
     if (Lex.getKind() == lltok::APSInt && !Lex.getAPSIntVal().isSigned()) {
       uint32_t TempVal = static_cast<uint32_t>(Val);
-      bool Res = ParseUInt32(TempVal);
+      bool Res = parseUInt32(TempVal);
       Val = static_cast<DINode::DIFlags>(TempVal);
       return Res;
     }
 
     if (Lex.getKind() != lltok::DIFlag)
-      return TokError("expected debug info flag");
+      return tokError("expected debug info flag");
 
     Val = DINode::getFlag(Lex.getStrVal());
     if (!Val)
-      return TokError(Twine("invalid debug info flag flag '") +
+      return tokError(Twine("invalid debug info flag flag '") +
                       Lex.getStrVal() + "'");
     Lex.Lex();
     return false;
   };
 
-  // Parse the flags and combine them together.
+  // parse the flags and combine them together.
   DINode::DIFlags Combined = DINode::FlagZero;
   do {
     DINode::DIFlags Val;
@@ -4265,29 +4389,29 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DIFlagField &Result) {
 ///  ::= DISPFlagVector
 ///  ::= DISPFlagVector '|' DISPFlag* '|' uint32
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DISPFlagField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, DISPFlagField &Result) {
 
-  // Parser for a single flag.
+  // parser for a single flag.
   auto parseFlag = [&](DISubprogram::DISPFlags &Val) {
     if (Lex.getKind() == lltok::APSInt && !Lex.getAPSIntVal().isSigned()) {
       uint32_t TempVal = static_cast<uint32_t>(Val);
-      bool Res = ParseUInt32(TempVal);
+      bool Res = parseUInt32(TempVal);
       Val = static_cast<DISubprogram::DISPFlags>(TempVal);
       return Res;
     }
 
     if (Lex.getKind() != lltok::DISPFlag)
-      return TokError("expected debug info flag");
+      return tokError("expected debug info flag");
 
     Val = DISubprogram::getFlag(Lex.getStrVal());
     if (!Val)
-      return TokError(Twine("invalid subprogram debug info flag '") +
+      return tokError(Twine("invalid subprogram debug info flag '") +
                       Lex.getStrVal() + "'");
     Lex.Lex();
     return false;
   };
 
-  // Parse the flags and combine them together.
+  // parse the flags and combine them together.
   DISubprogram::DISPFlags Combined = DISubprogram::SPFlagZero;
   do {
     DISubprogram::DISPFlags Val;
@@ -4301,17 +4425,16 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name, DISPFlagField &Result) {
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
-                            MDSignedField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, MDSignedField &Result) {
   if (Lex.getKind() != lltok::APSInt)
-    return TokError("expected signed integer");
+    return tokError("expected signed integer");
 
   auto &S = Lex.getAPSIntVal();
   if (S < Result.Min)
-    return TokError("value for '" + Name + "' too small, limit is " +
+    return tokError("value for '" + Name + "' too small, limit is " +
                     Twine(Result.Min));
   if (S > Result.Max)
-    return TokError("value for '" + Name + "' too large, limit is " +
+    return tokError("value for '" + Name + "' too large, limit is " +
                     Twine(Result.Max));
   Result.assign(S.getExtValue());
   assert(Result.Val >= Result.Min && "Expected value in range");
@@ -4321,10 +4444,10 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, MDBoolField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, MDBoolField &Result) {
   switch (Lex.getKind()) {
   default:
-    return TokError("expected 'true' or 'false'");
+    return tokError("expected 'true' or 'false'");
   case lltok::kw_true:
     Result.assign(true);
     break;
@@ -4337,17 +4460,17 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name, MDBoolField &Result) {
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, MDField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, MDField &Result) {
   if (Lex.getKind() == lltok::kw_null) {
     if (!Result.AllowNull)
-      return TokError("'" + Name + "' cannot be null");
+      return tokError("'" + Name + "' cannot be null");
     Lex.Lex();
     Result.assign(nullptr);
     return false;
   }
 
   Metadata *MD;
-  if (ParseMetadata(MD, nullptr))
+  if (parseMetadata(MD, nullptr))
     return true;
 
   Result.assign(MD);
@@ -4355,12 +4478,12 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name, MDField &Result) {
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
+bool LLParser::parseMDField(LocTy Loc, StringRef Name,
                             MDSignedOrMDField &Result) {
   // Try to parse a signed int.
   if (Lex.getKind() == lltok::APSInt) {
     MDSignedField Res = Result.A;
-    if (!ParseMDField(Loc, Name, Res)) {
+    if (!parseMDField(Loc, Name, Res)) {
       Result.assign(Res);
       return false;
     }
@@ -4369,7 +4492,7 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 
   // Otherwise, try to parse as an MDField.
   MDField Res = Result.B;
-  if (!ParseMDField(Loc, Name, Res)) {
+  if (!parseMDField(Loc, Name, Res)) {
     Result.assign(Res);
     return false;
   }
@@ -4378,23 +4501,23 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, MDStringField &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, MDStringField &Result) {
   LocTy ValueLoc = Lex.getLoc();
   std::string S;
-  if (ParseStringConstant(S))
+  if (parseStringConstant(S))
     return true;
 
   if (!Result.AllowEmpty && S.empty())
-    return Error(ValueLoc, "'" + Name + "' cannot be empty");
+    return error(ValueLoc, "'" + Name + "' cannot be empty");
 
   Result.assign(S.empty() ? nullptr : MDString::get(Context, S));
   return false;
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name, MDFieldList &Result) {
+bool LLParser::parseMDField(LocTy Loc, StringRef Name, MDFieldList &Result) {
   SmallVector<Metadata *, 4> MDs;
-  if (ParseMDNodeVector(MDs))
+  if (parseMDNodeVector(MDs))
     return true;
 
   Result.assign(std::move(MDs));
@@ -4402,14 +4525,14 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name, MDFieldList &Result) {
 }
 
 template <>
-bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
+bool LLParser::parseMDField(LocTy Loc, StringRef Name,
                             ChecksumKindField &Result) {
   Optional<DIFile::ChecksumKind> CSKind =
       DIFile::getChecksumKind(Lex.getStrVal());
 
   if (Lex.getKind() != lltok::ChecksumKind || !CSKind)
-    return TokError(
-        "invalid checksum kind" + Twine(" '") + Lex.getStrVal() + "'");
+    return tokError("invalid checksum kind" + Twine(" '") + Lex.getStrVal() +
+                    "'");
 
   Result.assign(*CSKind);
   Lex.Lex();
@@ -4419,12 +4542,12 @@ bool LLParser::ParseMDField(LocTy Loc, StringRef Name,
 } // end namespace llvm
 
 template <class ParserTy>
-bool LLParser::ParseMDFieldsImplBody(ParserTy parseField) {
+bool LLParser::parseMDFieldsImplBody(ParserTy ParseField) {
   do {
     if (Lex.getKind() != lltok::LabelStr)
-      return TokError("expected field label here");
+      return tokError("expected field label here");
 
-    if (parseField())
+    if (ParseField())
       return true;
   } while (EatIfPresent(lltok::comma));
 
@@ -4432,67 +4555,70 @@ bool LLParser::ParseMDFieldsImplBody(ParserTy parseField) {
 }
 
 template <class ParserTy>
-bool LLParser::ParseMDFieldsImpl(ParserTy parseField, LocTy &ClosingLoc) {
+bool LLParser::parseMDFieldsImpl(ParserTy ParseField, LocTy &ClosingLoc) {
   assert(Lex.getKind() == lltok::MetadataVar && "Expected metadata type name");
   Lex.Lex();
 
-  if (ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::lparen, "expected '(' here"))
     return true;
   if (Lex.getKind() != lltok::rparen)
-    if (ParseMDFieldsImplBody(parseField))
+    if (parseMDFieldsImplBody(ParseField))
       return true;
 
   ClosingLoc = Lex.getLoc();
-  return ParseToken(lltok::rparen, "expected ')' here");
+  return parseToken(lltok::rparen, "expected ')' here");
 }
 
 template <class FieldTy>
-bool LLParser::ParseMDField(StringRef Name, FieldTy &Result) {
+bool LLParser::parseMDField(StringRef Name, FieldTy &Result) {
   if (Result.Seen)
-    return TokError("field '" + Name + "' cannot be specified more than once");
+    return tokError("field '" + Name + "' cannot be specified more than once");
 
   LocTy Loc = Lex.getLoc();
   Lex.Lex();
-  return ParseMDField(Loc, Name, Result);
+  return parseMDField(Loc, Name, Result);
 }
 
-bool LLParser::ParseSpecializedMDNode(MDNode *&N, bool IsDistinct) {
+bool LLParser::parseSpecializedMDNode(MDNode *&N, bool IsDistinct) {
   assert(Lex.getKind() == lltok::MetadataVar && "Expected metadata type name");
 
 #define HANDLE_SPECIALIZED_MDNODE_LEAF(CLASS)                                  \
   if (Lex.getStrVal() == #CLASS)                                               \
-    return Parse##CLASS(N, IsDistinct);
+    return parse##CLASS(N, IsDistinct);
 #include "llvm/IR/Metadata.def"
 
-  return TokError("expected metadata type");
+  return tokError("expected metadata type");
 }
 
 #define DECLARE_FIELD(NAME, TYPE, INIT) TYPE NAME INIT
 #define NOP_FIELD(NAME, TYPE, INIT)
 #define REQUIRE_FIELD(NAME, TYPE, INIT)                                        \
   if (!NAME.Seen)                                                              \
-    return Error(ClosingLoc, "missing required field '" #NAME "'");
+    return error(ClosingLoc, "missing required field '" #NAME "'");
 #define PARSE_MD_FIELD(NAME, TYPE, DEFAULT)                                    \
   if (Lex.getStrVal() == #NAME)                                                \
-    return ParseMDField(#NAME, NAME);
+    return parseMDField(#NAME, NAME);
 #define PARSE_MD_FIELDS()                                                      \
   VISIT_MD_FIELDS(DECLARE_FIELD, DECLARE_FIELD)                                \
   do {                                                                         \
     LocTy ClosingLoc;                                                          \
-    if (ParseMDFieldsImpl([&]() -> bool {                                      \
-      VISIT_MD_FIELDS(PARSE_MD_FIELD, PARSE_MD_FIELD)                          \
-      return TokError(Twine("invalid field '") + Lex.getStrVal() + "'");       \
-    }, ClosingLoc))                                                            \
+    if (parseMDFieldsImpl(                                                     \
+            [&]() -> bool {                                                    \
+              VISIT_MD_FIELDS(PARSE_MD_FIELD, PARSE_MD_FIELD)                  \
+              return tokError(Twine("invalid field '") + Lex.getStrVal() +     \
+                              "'");                                            \
+            },                                                                 \
+            ClosingLoc))                                                       \
       return true;                                                             \
     VISIT_MD_FIELDS(NOP_FIELD, REQUIRE_FIELD)                                  \
   } while (false)
 #define GET_OR_DISTINCT(CLASS, ARGS)                                           \
   (IsDistinct ? CLASS::getDistinct ARGS : CLASS::get ARGS)
 
-/// ParseDILocationFields:
+/// parseDILocationFields:
 ///   ::= !DILocation(line: 43, column: 8, scope: !5, inlinedAt: !6,
 ///   isImplicitCode: true)
-bool LLParser::ParseDILocation(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDILocation(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   OPTIONAL(line, LineField, );                                                 \
   OPTIONAL(column, ColumnField, );                                             \
@@ -4508,9 +4634,9 @@ bool LLParser::ParseDILocation(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseGenericDINode:
+/// parseGenericDINode:
 ///   ::= !GenericDINode(tag: 15, header: "...", operands: {...})
-bool LLParser::ParseGenericDINode(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseGenericDINode(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(tag, DwarfTagField, );                                              \
   OPTIONAL(header, MDStringField, );                                           \
@@ -4523,11 +4649,11 @@ bool LLParser::ParseGenericDINode(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDISubrange:
+/// parseDISubrange:
 ///   ::= !DISubrange(count: 30, lowerBound: 2)
 ///   ::= !DISubrange(count: !node, lowerBound: 2)
 ///   ::= !DISubrange(lowerBound: !node1, upperBound: !node2, stride: !node3)
-bool LLParser::ParseDISubrange(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDISubrange(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   OPTIONAL(count, MDSignedOrMDField, (-1, -1, INT64_MAX, false));              \
   OPTIONAL(lowerBound, MDSignedOrMDField, );                                   \
@@ -4565,9 +4691,42 @@ bool LLParser::ParseDISubrange(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIEnumerator:
+/// parseDIGenericSubrange:
+///   ::= !DIGenericSubrange(lowerBound: !node1, upperBound: !node2, stride:
+///   !node3)
+bool LLParser::parseDIGenericSubrange(MDNode *&Result, bool IsDistinct) {
+#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
+  OPTIONAL(count, MDSignedOrMDField, );                                        \
+  OPTIONAL(lowerBound, MDSignedOrMDField, );                                   \
+  OPTIONAL(upperBound, MDSignedOrMDField, );                                   \
+  OPTIONAL(stride, MDSignedOrMDField, );
+  PARSE_MD_FIELDS();
+#undef VISIT_MD_FIELDS
+
+  auto ConvToMetadata = [&](MDSignedOrMDField Bound) -> Metadata * {
+    if (Bound.isMDSignedField())
+      return DIExpression::get(
+          Context, {dwarf::DW_OP_consts,
+                    static_cast<uint64_t>(Bound.getMDSignedValue())});
+    if (Bound.isMDField())
+      return Bound.getMDFieldValue();
+    return nullptr;
+  };
+
+  Metadata *Count = ConvToMetadata(count);
+  Metadata *LowerBound = ConvToMetadata(lowerBound);
+  Metadata *UpperBound = ConvToMetadata(upperBound);
+  Metadata *Stride = ConvToMetadata(stride);
+
+  Result = GET_OR_DISTINCT(DIGenericSubrange,
+                           (Context, Count, LowerBound, UpperBound, Stride));
+
+  return false;
+}
+
+/// parseDIEnumerator:
 ///   ::= !DIEnumerator(value: 30, isUnsigned: true, name: "SomeKind")
-bool LLParser::ParseDIEnumerator(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDIEnumerator(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(name, MDStringField, );                                             \
   REQUIRED(value, MDAPSIntField, );                                            \
@@ -4576,7 +4735,7 @@ bool LLParser::ParseDIEnumerator(MDNode *&Result, bool IsDistinct) {
 #undef VISIT_MD_FIELDS
 
   if (isUnsigned.Val && value.Val.isNegative())
-    return TokError("unsigned enumerator with negative value");
+    return tokError("unsigned enumerator with negative value");
 
   APSInt Value(value.Val);
   // Add a leading zero so that unsigned values with the msb set are not
@@ -4590,10 +4749,10 @@ bool LLParser::ParseDIEnumerator(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIBasicType:
+/// parseDIBasicType:
 ///   ::= !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32,
 ///                    encoding: DW_ATE_encoding, flags: 0)
-bool LLParser::ParseDIBasicType(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDIBasicType(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   OPTIONAL(tag, DwarfTagField, (dwarf::DW_TAG_base_type));                     \
   OPTIONAL(name, MDStringField, );                                             \
@@ -4609,12 +4768,33 @@ bool LLParser::ParseDIBasicType(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIDerivedType:
+/// parseDIStringType:
+///   ::= !DIStringType(name: "character(4)", size: 32, align: 32)
+bool LLParser::parseDIStringType(MDNode *&Result, bool IsDistinct) {
+#define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
+  OPTIONAL(tag, DwarfTagField, (dwarf::DW_TAG_string_type));                   \
+  OPTIONAL(name, MDStringField, );                                             \
+  OPTIONAL(stringLength, MDField, );                                           \
+  OPTIONAL(stringLengthExpression, MDField, );                                 \
+  OPTIONAL(size, MDUnsignedField, (0, UINT64_MAX));                            \
+  OPTIONAL(align, MDUnsignedField, (0, UINT32_MAX));                           \
+  OPTIONAL(encoding, DwarfAttEncodingField, );
+  PARSE_MD_FIELDS();
+#undef VISIT_MD_FIELDS
+
+  Result = GET_OR_DISTINCT(DIStringType,
+                           (Context, tag.Val, name.Val, stringLength.Val,
+                            stringLengthExpression.Val, size.Val, align.Val,
+                            encoding.Val));
+  return false;
+}
+
+/// parseDIDerivedType:
 ///   ::= !DIDerivedType(tag: DW_TAG_pointer_type, name: "int", file: !0,
 ///                      line: 7, scope: !1, baseType: !2, size: 32,
 ///                      align: 32, offset: 0, flags: 0, extraData: !3,
 ///                      dwarfAddressSpace: 3)
-bool LLParser::ParseDIDerivedType(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDIDerivedType(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(tag, DwarfTagField, );                                              \
   OPTIONAL(name, MDStringField, );                                             \
@@ -4643,7 +4823,7 @@ bool LLParser::ParseDIDerivedType(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-bool LLParser::ParseDICompositeType(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDICompositeType(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(tag, DwarfTagField, );                                              \
   OPTIONAL(name, MDStringField, );                                             \
@@ -4661,17 +4841,28 @@ bool LLParser::ParseDICompositeType(MDNode *&Result, bool IsDistinct) {
   OPTIONAL(templateParams, MDField, );                                         \
   OPTIONAL(identifier, MDStringField, );                                       \
   OPTIONAL(discriminator, MDField, );                                          \
-  OPTIONAL(dataLocation, MDField, );
+  OPTIONAL(dataLocation, MDField, );                                           \
+  OPTIONAL(associated, MDField, );                                             \
+  OPTIONAL(allocated, MDField, );                                              \
+  OPTIONAL(rank, MDSignedOrMDField, );
   PARSE_MD_FIELDS();
 #undef VISIT_MD_FIELDS
 
+  Metadata *Rank = nullptr;
+  if (rank.isMDSignedField())
+    Rank = ConstantAsMetadata::get(ConstantInt::getSigned(
+        Type::getInt64Ty(Context), rank.getMDSignedValue()));
+  else if (rank.isMDField())
+    Rank = rank.getMDFieldValue();
+
   // If this has an identifier try to build an ODR type.
   if (identifier.Val)
     if (auto *CT = DICompositeType::buildODRType(
             Context, *identifier.Val, tag.Val, name.Val, file.Val, line.Val,
             scope.Val, baseType.Val, size.Val, align.Val, offset.Val, flags.Val,
             elements.Val, runtimeLang.Val, vtableHolder.Val, templateParams.Val,
-            discriminator.Val, dataLocation.Val)) {
+            discriminator.Val, dataLocation.Val, associated.Val, allocated.Val,
+            Rank)) {
       Result = CT;
       return false;
     }
@@ -4683,11 +4874,12 @@ bool LLParser::ParseDICompositeType(MDNode *&Result, bool IsDistinct) {
       (Context, tag.Val, name.Val, file.Val, line.Val, scope.Val, baseType.Val,
        size.Val, align.Val, offset.Val, flags.Val, elements.Val,
        runtimeLang.Val, vtableHolder.Val, templateParams.Val, identifier.Val,
-       discriminator.Val, dataLocation.Val));
+       discriminator.Val, dataLocation.Val, associated.Val, allocated.Val,
+       Rank));
   return false;
 }
 
-bool LLParser::ParseDISubroutineType(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDISubroutineType(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   OPTIONAL(flags, DIFlagField, );                                              \
   OPTIONAL(cc, DwarfCCField, );                                                \
@@ -4700,12 +4892,12 @@ bool LLParser::ParseDISubroutineType(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIFileType:
+/// parseDIFileType:
 ///   ::= !DIFileType(filename: "path/to/file", directory: "/path/to/dir",
 ///                   checksumkind: CSK_MD5,
 ///                   checksum: "000102030405060708090a0b0c0d0e0f",
 ///                   source: "source file contents")
-bool LLParser::ParseDIFile(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDIFile(MDNode *&Result, bool IsDistinct) {
   // The default constructed value for checksumkind is required, but will never
   // be used, as the parser checks if the field was actually Seen before using
   // the Val.
@@ -4732,14 +4924,14 @@ bool LLParser::ParseDIFile(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDICompileUnit:
+/// parseDICompileUnit:
 ///   ::= !DICompileUnit(language: DW_LANG_C99, file: !0, producer: "clang",
 ///                      isOptimized: true, flags: "-O2", runtimeVersion: 1,
 ///                      splitDebugFilename: "abc.debug",
 ///                      emissionKind: FullDebug, enums: !1, retainedTypes: !2,
 ///                      globals: !4, imports: !5, macros: !6, dwoId: 0x0abcd,
 ///                      sysroot: "/", sdk: "MacOSX.sdk")
-bool LLParser::ParseDICompileUnit(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDICompileUnit(MDNode *&Result, bool IsDistinct) {
   if (!IsDistinct)
     return Lex.Error("missing 'distinct', required for !DICompileUnit");
 
@@ -4776,7 +4968,7 @@ bool LLParser::ParseDICompileUnit(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDISubprogram:
+/// parseDISubprogram:
 ///   ::= !DISubprogram(scope: !0, name: "foo", linkageName: "_Zfoo",
 ///                     file: !1, line: 7, type: !2, isLocal: false,
 ///                     isDefinition: true, scopeLine: 8, containingType: !3,
@@ -4784,7 +4976,7 @@ bool LLParser::ParseDICompileUnit(MDNode *&Result, bool IsDistinct) {
 ///                     virtualIndex: 10, thisAdjustment: 4, flags: 11,
 ///                     spFlags: 10, isOptimized: false, templateParams: !4,
 ///                     declaration: !5, retainedNodes: !6, thrownTypes: !7)
-bool LLParser::ParseDISubprogram(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDISubprogram(MDNode *&Result, bool IsDistinct) {
   auto Loc = Lex.getLoc();
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   OPTIONAL(scope, MDField, );                                                  \
@@ -4830,9 +5022,9 @@ bool LLParser::ParseDISubprogram(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDILexicalBlock:
+/// parseDILexicalBlock:
 ///   ::= !DILexicalBlock(scope: !0, file: !2, line: 7, column: 9)
-bool LLParser::ParseDILexicalBlock(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDILexicalBlock(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(scope, MDField, (/* AllowNull */ false));                           \
   OPTIONAL(file, MDField, );                                                   \
@@ -4846,9 +5038,9 @@ bool LLParser::ParseDILexicalBlock(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDILexicalBlockFile:
+/// parseDILexicalBlockFile:
 ///   ::= !DILexicalBlockFile(scope: !0, file: !2, discriminator: 9)
-bool LLParser::ParseDILexicalBlockFile(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDILexicalBlockFile(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(scope, MDField, (/* AllowNull */ false));                           \
   OPTIONAL(file, MDField, );                                                   \
@@ -4861,9 +5053,9 @@ bool LLParser::ParseDILexicalBlockFile(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDICommonBlock:
+/// parseDICommonBlock:
 ///   ::= !DICommonBlock(scope: !0, file: !2, name: "COMMON name", line: 9)
-bool LLParser::ParseDICommonBlock(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDICommonBlock(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(scope, MDField, );                                                  \
   OPTIONAL(declaration, MDField, );                                            \
@@ -4879,9 +5071,9 @@ bool LLParser::ParseDICommonBlock(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDINamespace:
+/// parseDINamespace:
 ///   ::= !DINamespace(scope: !0, file: !2, name: "SomeNamespace", line: 9)
-bool LLParser::ParseDINamespace(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDINamespace(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(scope, MDField, );                                                  \
   OPTIONAL(name, MDStringField, );                                             \
@@ -4894,9 +5086,10 @@ bool LLParser::ParseDINamespace(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIMacro:
-///   ::= !DIMacro(macinfo: type, line: 9, name: "SomeMacro", value: "SomeValue")
-bool LLParser::ParseDIMacro(MDNode *&Result, bool IsDistinct) {
+/// parseDIMacro:
+///   ::= !DIMacro(macinfo: type, line: 9, name: "SomeMacro", value:
+///   "SomeValue")
+bool LLParser::parseDIMacro(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(type, DwarfMacinfoTypeField, );                                     \
   OPTIONAL(line, LineField, );                                                 \
@@ -4910,9 +5103,9 @@ bool LLParser::ParseDIMacro(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIMacroFile:
+/// parseDIMacroFile:
 ///   ::= !DIMacroFile(line: 9, file: !2, nodes: !3)
-bool LLParser::ParseDIMacroFile(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDIMacroFile(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   OPTIONAL(type, DwarfMacinfoTypeField, (dwarf::DW_MACINFO_start_file));       \
   OPTIONAL(line, LineField, );                                                 \
@@ -4926,11 +5119,11 @@ bool LLParser::ParseDIMacroFile(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIModule:
+/// parseDIModule:
 ///   ::= !DIModule(scope: !0, name: "SomeModule", configMacros:
 ///   "-DNDEBUG", includePath: "/usr/include", apinotes: "module.apinotes",
-///   file: !1, line: 4)
-bool LLParser::ParseDIModule(MDNode *&Result, bool IsDistinct) {
+///   file: !1, line: 4, isDecl: false)
+bool LLParser::parseDIModule(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(scope, MDField, );                                                  \
   REQUIRED(name, MDStringField, );                                             \
@@ -4938,19 +5131,20 @@ bool LLParser::ParseDIModule(MDNode *&Result, bool IsDistinct) {
   OPTIONAL(includePath, MDStringField, );                                      \
   OPTIONAL(apinotes, MDStringField, );                                         \
   OPTIONAL(file, MDField, );                                                   \
-  OPTIONAL(line, LineField, );
+  OPTIONAL(line, LineField, );                                                 \
+  OPTIONAL(isDecl, MDBoolField, );
   PARSE_MD_FIELDS();
 #undef VISIT_MD_FIELDS
 
   Result = GET_OR_DISTINCT(DIModule, (Context, file.Val, scope.Val, name.Val,
                                       configMacros.Val, includePath.Val,
-                                      apinotes.Val, line.Val));
+                                      apinotes.Val, line.Val, isDecl.Val));
   return false;
 }
 
-/// ParseDITemplateTypeParameter:
+/// parseDITemplateTypeParameter:
 ///   ::= !DITemplateTypeParameter(name: "Ty", type: !1, defaulted: false)
-bool LLParser::ParseDITemplateTypeParameter(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDITemplateTypeParameter(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   OPTIONAL(name, MDStringField, );                                             \
   REQUIRED(type, MDField, );                                                   \
@@ -4963,11 +5157,11 @@ bool LLParser::ParseDITemplateTypeParameter(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDITemplateValueParameter:
+/// parseDITemplateValueParameter:
 ///   ::= !DITemplateValueParameter(tag: DW_TAG_template_value_parameter,
 ///                                 name: "V", type: !1, defaulted: false,
 ///                                 value: i32 7)
-bool LLParser::ParseDITemplateValueParameter(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDITemplateValueParameter(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   OPTIONAL(tag, DwarfTagField, (dwarf::DW_TAG_template_value_parameter));      \
   OPTIONAL(name, MDStringField, );                                             \
@@ -4984,12 +5178,12 @@ bool LLParser::ParseDITemplateValueParameter(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIGlobalVariable:
+/// parseDIGlobalVariable:
 ///   ::= !DIGlobalVariable(scope: !0, name: "foo", linkageName: "foo",
 ///                         file: !1, line: 7, type: !2, isLocal: false,
 ///                         isDefinition: true, templateParams: !3,
 ///                         declaration: !4, align: 8)
-bool LLParser::ParseDIGlobalVariable(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDIGlobalVariable(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(name, MDStringField, (/* AllowEmpty */ false));                     \
   OPTIONAL(scope, MDField, );                                                  \
@@ -5013,14 +5207,14 @@ bool LLParser::ParseDIGlobalVariable(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDILocalVariable:
+/// parseDILocalVariable:
 ///   ::= !DILocalVariable(arg: 7, scope: !0, name: "foo",
 ///                        file: !1, line: 7, type: !2, arg: 2, flags: 7,
 ///                        align: 8)
 ///   ::= !DILocalVariable(scope: !0, name: "foo",
 ///                        file: !1, line: 7, type: !2, arg: 2, flags: 7,
 ///                        align: 8)
-bool LLParser::ParseDILocalVariable(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDILocalVariable(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(scope, MDField, (/* AllowNull */ false));                           \
   OPTIONAL(name, MDStringField, );                                             \
@@ -5039,9 +5233,9 @@ bool LLParser::ParseDILocalVariable(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDILabel:
+/// parseDILabel:
 ///   ::= !DILabel(scope: !0, name: "foo", file: !1, line: 7)
-bool LLParser::ParseDILabel(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDILabel(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(scope, MDField, (/* AllowNull */ false));                           \
   REQUIRED(name, MDStringField, );                                             \
@@ -5055,13 +5249,13 @@ bool LLParser::ParseDILabel(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIExpression:
+/// parseDIExpression:
 ///   ::= !DIExpression(0, 7, -1)
-bool LLParser::ParseDIExpression(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDIExpression(MDNode *&Result, bool IsDistinct) {
   assert(Lex.getKind() == lltok::MetadataVar && "Expected metadata type name");
   Lex.Lex();
 
-  if (ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   SmallVector<uint64_t, 8> Elements;
@@ -5073,7 +5267,7 @@ bool LLParser::ParseDIExpression(MDNode *&Result, bool IsDistinct) {
           Elements.push_back(Op);
           continue;
         }
-        return TokError(Twine("invalid DWARF op '") + Lex.getStrVal() + "'");
+        return tokError(Twine("invalid DWARF op '") + Lex.getStrVal() + "'");
       }
 
       if (Lex.getKind() == lltok::DwarfAttEncoding) {
@@ -5082,29 +5276,30 @@ bool LLParser::ParseDIExpression(MDNode *&Result, bool IsDistinct) {
           Elements.push_back(Op);
           continue;
         }
-        return TokError(Twine("invalid DWARF attribute encoding '") + Lex.getStrVal() + "'");
+        return tokError(Twine("invalid DWARF attribute encoding '") +
+                        Lex.getStrVal() + "'");
       }
 
       if (Lex.getKind() != lltok::APSInt || Lex.getAPSIntVal().isSigned())
-        return TokError("expected unsigned integer");
+        return tokError("expected unsigned integer");
 
       auto &U = Lex.getAPSIntVal();
       if (U.ugt(UINT64_MAX))
-        return TokError("element too large, limit is " + Twine(UINT64_MAX));
+        return tokError("element too large, limit is " + Twine(UINT64_MAX));
       Elements.push_back(U.getZExtValue());
       Lex.Lex();
     } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   Result = GET_OR_DISTINCT(DIExpression, (Context, Elements));
   return false;
 }
 
-/// ParseDIGlobalVariableExpression:
+/// parseDIGlobalVariableExpression:
 ///   ::= !DIGlobalVariableExpression(var: !0, expr: !1)
-bool LLParser::ParseDIGlobalVariableExpression(MDNode *&Result,
+bool LLParser::parseDIGlobalVariableExpression(MDNode *&Result,
                                                bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(var, MDField, );                                                    \
@@ -5117,10 +5312,10 @@ bool LLParser::ParseDIGlobalVariableExpression(MDNode *&Result,
   return false;
 }
 
-/// ParseDIObjCProperty:
+/// parseDIObjCProperty:
 ///   ::= !DIObjCProperty(name: "foo", file: !1, line: 7, setter: "setFoo",
 ///                       getter: "getFoo", attributes: 7, type: !2)
-bool LLParser::ParseDIObjCProperty(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDIObjCProperty(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   OPTIONAL(name, MDStringField, );                                             \
   OPTIONAL(file, MDField, );                                                   \
@@ -5138,10 +5333,10 @@ bool LLParser::ParseDIObjCProperty(MDNode *&Result, bool IsDistinct) {
   return false;
 }
 
-/// ParseDIImportedEntity:
+/// parseDIImportedEntity:
 ///   ::= !DIImportedEntity(tag: DW_TAG_imported_module, scope: !0, entity: !1,
 ///                         line: 7, name: "foo")
-bool LLParser::ParseDIImportedEntity(MDNode *&Result, bool IsDistinct) {
+bool LLParser::parseDIImportedEntity(MDNode *&Result, bool IsDistinct) {
 #define VISIT_MD_FIELDS(OPTIONAL, REQUIRED)                                    \
   REQUIRED(tag, DwarfTagField, );                                              \
   REQUIRED(scope, MDField, );                                                  \
@@ -5163,45 +5358,45 @@ bool LLParser::ParseDIImportedEntity(MDNode *&Result, bool IsDistinct) {
 #undef REQUIRE_FIELD
 #undef DECLARE_FIELD
 
-/// ParseMetadataAsValue
+/// parseMetadataAsValue
 ///  ::= metadata i32 %local
 ///  ::= metadata i32 @global
 ///  ::= metadata i32 7
 ///  ::= metadata !0
 ///  ::= metadata !{...}
 ///  ::= metadata !"string"
-bool LLParser::ParseMetadataAsValue(Value *&V, PerFunctionState &PFS) {
+bool LLParser::parseMetadataAsValue(Value *&V, PerFunctionState &PFS) {
   // Note: the type 'metadata' has already been parsed.
   Metadata *MD;
-  if (ParseMetadata(MD, &PFS))
+  if (parseMetadata(MD, &PFS))
     return true;
 
   V = MetadataAsValue::get(Context, MD);
   return false;
 }
 
-/// ParseValueAsMetadata
+/// parseValueAsMetadata
 ///  ::= i32 %local
 ///  ::= i32 @global
 ///  ::= i32 7
-bool LLParser::ParseValueAsMetadata(Metadata *&MD, const Twine &TypeMsg,
+bool LLParser::parseValueAsMetadata(Metadata *&MD, const Twine &TypeMsg,
                                     PerFunctionState *PFS) {
   Type *Ty;
   LocTy Loc;
-  if (ParseType(Ty, TypeMsg, Loc))
+  if (parseType(Ty, TypeMsg, Loc))
     return true;
   if (Ty->isMetadataTy())
-    return Error(Loc, "invalid metadata-value-metadata roundtrip");
+    return error(Loc, "invalid metadata-value-metadata roundtrip");
 
   Value *V;
-  if (ParseValue(Ty, V, PFS))
+  if (parseValue(Ty, V, PFS))
     return true;
 
   MD = ValueAsMetadata::get(V);
   return false;
 }
 
-/// ParseMetadata
+/// parseMetadata
 ///  ::= i32 %local
 ///  ::= i32 @global
 ///  ::= i32 7
@@ -5251,48 +5446,52 @@ bool LLParser::ParseMetadata(Metadata *&MD, PerFunctionState *PFS) {
 // Function Parsing.
 //===----------------------------------------------------------------------===//
 
-bool LLParser::ConvertValIDToValue(Type *Ty, ValID &ID, Value *&V,
+bool LLParser::convertValIDToValue(Type *Ty, ValID &ID, Value *&V,
                                    PerFunctionState *PFS, bool IsCall) {
   if (Ty->isFunctionTy())
-    return Error(ID.Loc, "functions are not values, refer to them as pointers");
+    return error(ID.Loc, "functions are not values, refer to them as pointers");
 
   switch (ID.Kind) {
   case ValID::t_LocalID:
-    if (!PFS) return Error(ID.Loc, "invalid use of function-local name");
-    V = PFS->GetVal(ID.UIntVal, Ty, ID.Loc, IsCall);
+    if (!PFS)
+      return error(ID.Loc, "invalid use of function-local name");
+    V = PFS->getVal(ID.UIntVal, Ty, ID.Loc, IsCall);
     return V == nullptr;
   case ValID::t_LocalName:
-    if (!PFS) return Error(ID.Loc, "invalid use of function-local name");
-    V = PFS->GetVal(ID.StrVal, Ty, ID.Loc, IsCall);
+    if (!PFS)
+      return error(ID.Loc, "invalid use of function-local name");
+    V = PFS->getVal(ID.StrVal, Ty, ID.Loc, IsCall);
     return V == nullptr;
   case ValID::t_InlineAsm: {
     if (!ID.FTy || !InlineAsm::Verify(ID.FTy, ID.StrVal2))
-      return Error(ID.Loc, "invalid type for inline asm constraint string");
+      return error(ID.Loc, "invalid type for inline asm constraint string");
     V = InlineAsm::get(ID.FTy, ID.StrVal, ID.StrVal2, ID.UIntVal & 1,
                        (ID.UIntVal >> 1) & 1,
                        (InlineAsm::AsmDialect(ID.UIntVal >> 2)));
     return false;
   }
   case ValID::t_GlobalName:
-    V = GetGlobalVal(ID.StrVal, Ty, ID.Loc, IsCall);
+    V = getGlobalVal(ID.StrVal, Ty, ID.Loc, IsCall);
     return V == nullptr;
   case ValID::t_GlobalID:
-    V = GetGlobalVal(ID.UIntVal, Ty, ID.Loc, IsCall);
+    V = getGlobalVal(ID.UIntVal, Ty, ID.Loc, IsCall);
     return V == nullptr;
   case ValID::t_APSInt:
     if (!Ty->isIntegerTy())
-      return Error(ID.Loc, "integer constant must have integer type");
+      return error(ID.Loc, "integer constant must have integer type");
     ID.APSIntVal = ID.APSIntVal.extOrTrunc(Ty->getPrimitiveSizeInBits());
     V = ConstantInt::get(Context, ID.APSIntVal);
     return false;
   case ValID::t_APFloat:
     if (!Ty->isFloatingPointTy() ||
         !ConstantFP::isValueValidForType(Ty, ID.APFloatVal))
-      return Error(ID.Loc, "floating point constant invalid for type");
+      return error(ID.Loc, "floating point constant invalid for type");
 
     // The lexer has no type info, so builds all half, bfloat, float, and double
     // FP constants as double.  Fix this here.  Long double does not need this.
     if (&ID.APFloatVal.getSemantics() == &APFloat::IEEEdouble()) {
+      // Check for signaling before potentially converting and losing that info.
+      bool IsSNAN = ID.APFloatVal.isSignaling();
       bool Ignored;
       if (Ty->isHalfTy())
         ID.APFloatVal.convert(APFloat::IEEEhalf(), APFloat::rmNearestTiesToEven,
@@ -5303,66 +5502,81 @@ bool LLParser::ConvertValIDToValue(Type *Ty, ValID &ID, Value *&V,
       else if (Ty->isFloatTy())
         ID.APFloatVal.convert(APFloat::IEEEsingle(), APFloat::rmNearestTiesToEven,
                               &Ignored);
+      if (IsSNAN) {
+        // The convert call above may quiet an SNaN, so manufacture another
+        // SNaN. The bitcast works because the payload (significand) parameter
+        // is truncated to fit.
+        APInt Payload = ID.APFloatVal.bitcastToAPInt();
+        ID.APFloatVal = APFloat::getSNaN(ID.APFloatVal.getSemantics(),
+                                         ID.APFloatVal.isNegative(), &Payload);
+      }
     }
     V = ConstantFP::get(Context, ID.APFloatVal);
 
     if (V->getType() != Ty)
-      return Error(ID.Loc, "floating point constant does not have type '" +
-                   getTypeString(Ty) + "'");
+      return error(ID.Loc, "floating point constant does not have type '" +
+                               getTypeString(Ty) + "'");
 
     return false;
   case ValID::t_Null:
     if (!Ty->isPointerTy())
-      return Error(ID.Loc, "null must be a pointer type");
+      return error(ID.Loc, "null must be a pointer type");
     V = ConstantPointerNull::get(cast<PointerType>(Ty));
     return false;
   case ValID::t_Undef:
     // FIXME: LabelTy should not be a first-class type.
     if (!Ty->isFirstClassType() || Ty->isLabelTy())
-      return Error(ID.Loc, "invalid type for undef constant");
+      return error(ID.Loc, "invalid type for undef constant");
     V = UndefValue::get(Ty);
     return false;
   case ValID::t_EmptyArray:
     if (!Ty->isArrayTy() || cast<ArrayType>(Ty)->getNumElements() != 0)
-      return Error(ID.Loc, "invalid empty array initializer");
+      return error(ID.Loc, "invalid empty array initializer");
     V = UndefValue::get(Ty);
     return false;
   case ValID::t_Zero:
     // FIXME: LabelTy should not be a first-class type.
     if (!Ty->isFirstClassType() || Ty->isLabelTy())
-      return Error(ID.Loc, "invalid type for null constant");
+      return error(ID.Loc, "invalid type for null constant");
     V = Constant::getNullValue(Ty);
     return false;
   case ValID::t_None:
     if (!Ty->isTokenTy())
-      return Error(ID.Loc, "invalid type for none constant");
+      return error(ID.Loc, "invalid type for none constant");
     V = Constant::getNullValue(Ty);
     return false;
+  case ValID::t_Poison:
+    // FIXME: LabelTy should not be a first-class type.
+    if (!Ty->isFirstClassType() || Ty->isLabelTy())
+      return error(ID.Loc, "invalid type for poison constant");
+    V = PoisonValue::get(Ty);
+    return false;
   case ValID::t_Constant:
     if (ID.ConstantVal->getType() != Ty)
-      return Error(ID.Loc, "constant expression type mismatch");
-
+      return error(ID.Loc, "constant expression type mismatch");
     V = ID.ConstantVal;
     return false;
   case ValID::t_ConstantStruct:
   case ValID::t_PackedConstantStruct:
     if (StructType *ST = dyn_cast<StructType>(Ty)) {
       if (ST->getNumElements() != ID.UIntVal)
-        return Error(ID.Loc,
+        return error(ID.Loc,
                      "initializer with struct type has wrong # elements");
       if (ST->isPacked() != (ID.Kind == ValID::t_PackedConstantStruct))
-        return Error(ID.Loc, "packed'ness of initializer and type don't match");
+        return error(ID.Loc, "packed'ness of initializer and type don't match");
 
       // Verify that the elements are compatible with the structtype.
       for (unsigned i = 0, e = ID.UIntVal; i != e; ++i)
         if (ID.ConstantStructElts[i]->getType() != ST->getElementType(i))
-          return Error(ID.Loc, "element " + Twine(i) +
-                    " of struct initializer doesn't match struct element type");
+          return error(
+              ID.Loc,
+              "element " + Twine(i) +
+                  " of struct initializer doesn't match struct element type");
 
       V = ConstantStruct::get(
           ST, makeArrayRef(ID.ConstantStructElts.get(), ID.UIntVal));
     } else
-      return Error(ID.Loc, "constant expression type mismatch");
+      return error(ID.Loc, "constant expression type mismatch");
     return false;
   }
   llvm_unreachable("Invalid ValID");
@@ -5458,20 +5672,20 @@ bool LLParser::ParseFunctionHeader(Function *&Fn, bool isDefine) {
   case GlobalValue::LinkOnceODRLinkage:
   case GlobalValue::WeakAnyLinkage:
   case GlobalValue::WeakODRLinkage:
-    if (!isDefine)
-      return Error(LinkageLoc, "invalid linkage for function declaration");
+    if (!IsDefine)
+      return error(LinkageLoc, "invalid linkage for function declaration");
     break;
   case GlobalValue::AppendingLinkage:
   case GlobalValue::CommonLinkage:
-    return Error(LinkageLoc, "invalid function linkage type");
+    return error(LinkageLoc, "invalid function linkage type");
   }
 
   if (!isValidVisibilityForLinkage(Visibility, Linkage))
-    return Error(LinkageLoc,
+    return error(LinkageLoc,
                  "symbol with local linkage must have default visibility");
 
   if (!FunctionType::isValidReturnType(RetType))
-    return Error(RetTypeLoc, "invalid function return type");
+    return error(RetTypeLoc, "invalid function return type");
 
   LocTy NameLoc = Lex.getLoc();
@@ -5509,29 +5723,24 @@ bool LLParser::ParseFunctionHeader(Function *&Fn, bool isDefine) {
   Constant *PersonalityFn = nullptr;
   Comdat *C;
 
-  if (ParseArgumentList(ArgList, isVarArg) ||
-      ParseOptionalUnnamedAddr(UnnamedAddr) ||
-      ParseOptionalProgramAddrSpace(AddrSpace) ||
-      ParseFnAttributeValuePairs(FuncAttrs, FwdRefAttrGrps, false,
+  if (parseArgumentList(ArgList, IsVarArg) ||
+      parseOptionalUnnamedAddr(UnnamedAddr) ||
+      parseOptionalProgramAddrSpace(AddrSpace) ||
+      parseFnAttributeValuePairs(FuncAttrs, FwdRefAttrGrps, false,
                                  BuiltinLoc) ||
-      (EatIfPresent(lltok::kw_section) &&
-       ParseStringConstant(Section)) ||
-      (EatIfPresent(lltok::kw_partition) &&
-       ParseStringConstant(Partition)) ||
+      (EatIfPresent(lltok::kw_section) && parseStringConstant(Section)) ||
+      (EatIfPresent(lltok::kw_partition) && parseStringConstant(Partition)) ||
       parseOptionalComdat(FunctionName, C) ||
-      ParseOptionalAlignment(Alignment) ||
-      (EatIfPresent(lltok::kw_gc) &&
-       ParseStringConstant(GC)) ||
-      (EatIfPresent(lltok::kw_prefix) &&
-       ParseGlobalTypeAndValue(Prefix)) ||
-      (EatIfPresent(lltok::kw_prologue) &&
-       ParseGlobalTypeAndValue(Prologue)) ||
+      parseOptionalAlignment(Alignment) ||
+      (EatIfPresent(lltok::kw_gc) && parseStringConstant(GC)) ||
+      (EatIfPresent(lltok::kw_prefix) && parseGlobalTypeAndValue(Prefix)) ||
+      (EatIfPresent(lltok::kw_prologue) && parseGlobalTypeAndValue(Prologue)) ||
       (EatIfPresent(lltok::kw_personality) &&
-       ParseGlobalTypeAndValue(PersonalityFn)))
+       parseGlobalTypeAndValue(PersonalityFn)))
     return true;
 
   if (FuncAttrs.contains(Attribute::Builtin))
-    return Error(BuiltinLoc, "'builtin' attribute not valid on function");
+    return error(BuiltinLoc, "'builtin' attribute not valid on function");
 
   // If the alignment was parsed as an attribute, move to the alignment field.
   if (FuncAttrs.hasAlignmentAttr()) {
@@ -5568,20 +5776,24 @@ bool LLParser::ParseFunctionHeader(Function *&Fn, bool isDefine) {
     if (FRVI != ForwardRefVals.end()) {
       Fn = M->getFunction(FunctionName);
       if (!Fn)
-        return Error(FRVI->second.second, "invalid forward reference to "
-                     "function as global value!");
+        return error(FRVI->second.second, "invalid forward reference to "
+                                          "function as global value!");
       if (Fn->getType() != PFT)
-        return Error(FRVI->second.second, "invalid forward reference to "
-                     "function '" + FunctionName + "' with wrong type: "
-                     "expected '" + getTypeString(PFT) + "' but was '" +
-                     getTypeString(Fn->getType()) + "'");
+        return error(FRVI->second.second,
+                     "invalid forward reference to "
+                     "function '" +
+                         FunctionName +
+                         "' with wrong type: "
+                         "expected '" +
+                         getTypeString(PFT) + "' but was '" +
+                         getTypeString(Fn->getType()) + "'");
       ForwardRefVals.erase(FRVI);
     } else if ((Fn = M->getFunction(FunctionName))) {
       // Reject redefinitions.
-      return Error(NameLoc, "invalid redefinition of function '" +
-                   FunctionName + "'");
+      return error(NameLoc,
+                   "invalid redefinition of function '" + FunctionName + "'");
     } else if (M->getNamedValue(FunctionName)) {
-      return Error(NameLoc, "redefinition of function '@" + FunctionName + "'");
+      return error(NameLoc, "redefinition of function '@" + FunctionName + "'");
     }
 
   } else {
@@ -5591,10 +5803,12 @@ bool LLParser::ParseFunctionHeader(Function *&Fn, bool isDefine) {
     if (I != ForwardRefValIDs.end()) {
       Fn = cast<Function>(I->second.first);
       if (Fn->getType() != PFT)
-        return Error(NameLoc, "type of definition and forward reference of '@" +
-                     Twine(NumberedVals.size()) + "' disagree: "
-                     "expected '" + getTypeString(PFT) + "' but was '" +
-                     getTypeString(Fn->getType()) + "'");
+        return error(NameLoc, "type of definition and forward reference of '@" +
+                                  Twine(NumberedVals.size()) +
+                                  "' disagree: "
+                                  "expected '" +
+                                  getTypeString(PFT) + "' but was '" +
+                                  getTypeString(Fn->getType()) + "'");
       ForwardRefValIDs.erase(I);
     }
   }
@@ -5637,11 +5851,11 @@ bool LLParser::ParseFunctionHeader(Function *&Fn, bool isDefine) {
     ArgIt->setName(ArgList[i].Name);
 
     if (ArgIt->getName() != ArgList[i].Name)
-      return Error(ArgList[i].Loc, "redefinition of argument '%" +
-                   ArgList[i].Name + "'");
+      return error(ArgList[i].Loc,
+                   "redefinition of argument '%" + ArgList[i].Name + "'");
   }
 
-  if (isDefine)
+  if (IsDefine)
     return false;
 
   // Check the declaration has no block address forward references.
@@ -5716,26 +5930,27 @@ bool LLParser::ParseFunctionBody(Function &Fn) {
 
   // We need at least one basic block.
   if (Lex.getKind() == lltok::rbrace || Lex.getKind() == lltok::kw_uselistorder)
-    return TokError("function body requires at least one basic block");
+    return tokError("function body requires at least one basic block");
 
   while (Lex.getKind() != lltok::rbrace &&
          Lex.getKind() != lltok::kw_uselistorder)
-    if (ParseBasicBlock(PFS)) return true;
+    if (parseBasicBlock(PFS))
+      return true;
 
   while (Lex.getKind() != lltok::rbrace)
-    if (ParseUseListOrder(&PFS))
+    if (parseUseListOrder(&PFS))
       return true;
 
   // Eat the }.
   Lex.Lex();
 
   // Verify function is ok.
-  return PFS.FinishFunction();
+  return PFS.finishFunction();
 }
 
-/// ParseBasicBlock
+/// parseBasicBlock
 ///   ::= (LabelStr|LabelID)? Instruction*
-bool LLParser::ParseBasicBlock(PerFunctionState &PFS) {
+bool LLParser::parseBasicBlock(PerFunctionState &PFS) {
   // If this basic block starts out with a name, remember it.
   std::string Name;
   int NameID = -1;
@@ -5808,37 +6025,50 @@ bool LLParser::ParseBasicBlock(PerFunctionState &PFS) {
 // Instruction Parsing.
 //===----------------------------------------------------------------------===//
 
-/// ParseInstruction - Parse one of the many different instructions.
+/// parseInstruction - parse one of the many different instructions.
 ///
-int LLParser::ParseInstruction(Instruction *&Inst, BasicBlock *BB,
+int LLParser::parseInstruction(Instruction *&Inst, BasicBlock *BB,
                                PerFunctionState &PFS) {
   lltok::Kind Token = Lex.getKind();
   if (Token == lltok::Eof)
-    return TokError("found end of file when expecting more instructions");
+    return tokError("found end of file when expecting more instructions");
   LocTy Loc = Lex.getLoc();
   unsigned KeywordVal = Lex.getUIntVal();
   Lex.Lex();  // Eat the keyword.
 
   switch (Token) {
-  default:                    return Error(Loc, "expected instruction opcode");
+  default:
+    return error(Loc, "expected instruction opcode");
   // Terminator Instructions.
   case lltok::kw_unreachable: Inst = new UnreachableInst(Context); return false;
-  case lltok::kw_ret:         return ParseRet(Inst, BB, PFS);
-  case lltok::kw_br:          return ParseBr(Inst, PFS);
-  case lltok::kw_switch:      return ParseSwitch(Inst, PFS);
-  case lltok::kw_indirectbr:  return ParseIndirectBr(Inst, PFS);
-  case lltok::kw_invoke:      return ParseInvoke(Inst, PFS);
-  case lltok::kw_resume:      return ParseResume(Inst, PFS);
-  case lltok::kw_cleanupret:  return ParseCleanupRet(Inst, PFS);
-  case lltok::kw_catchret:    return ParseCatchRet(Inst, PFS);
-  case lltok::kw_catchswitch: return ParseCatchSwitch(Inst, PFS);
-  case lltok::kw_catchpad:    return ParseCatchPad(Inst, PFS);
-  case lltok::kw_cleanuppad:  return ParseCleanupPad(Inst, PFS);
-  case lltok::kw_callbr:      return ParseCallBr(Inst, PFS);
+  case lltok::kw_ret:
+    return parseRet(Inst, BB, PFS);
+  case lltok::kw_br:
+    return parseBr(Inst, PFS);
+  case lltok::kw_switch:
+    return parseSwitch(Inst, PFS);
+  case lltok::kw_indirectbr:
+    return parseIndirectBr(Inst, PFS);
+  case lltok::kw_invoke:
+    return parseInvoke(Inst, PFS);
+  case lltok::kw_resume:
+    return parseResume(Inst, PFS);
+  case lltok::kw_cleanupret:
+    return parseCleanupRet(Inst, PFS);
+  case lltok::kw_catchret:
+    return parseCatchRet(Inst, PFS);
+  case lltok::kw_catchswitch:
+    return parseCatchSwitch(Inst, PFS);
+  case lltok::kw_catchpad:
+    return parseCatchPad(Inst, PFS);
+  case lltok::kw_cleanuppad:
+    return parseCleanupPad(Inst, PFS);
+  case lltok::kw_callbr:
+    return parseCallBr(Inst, PFS);
   // Unary Operators.
   case lltok::kw_fneg: {
     FastMathFlags FMF = EatFastMathFlagsIfPresent();
-    int Res = ParseUnaryOp(Inst, PFS, KeywordVal, /*IsFP*/true);
+    int Res = parseUnaryOp(Inst, PFS, KeywordVal, /*IsFP*/ true);
     if (Res != 0)
       return Res;
     if (FMF.any())
@@ -5854,7 +6084,8 @@ int LLParser::ParseInstruction(Instruction *&Inst, BasicBlock *BB,
     bool NSW = EatIfPresent(lltok::kw_nsw);
     if (!NUW) NUW = EatIfPresent(lltok::kw_nuw);
 
-    if (ParseArithmetic(Inst, PFS, KeywordVal, /*IsFP*/false)) return true;
+    if (parseArithmetic(Inst, PFS, KeywordVal, /*IsFP*/ false))
+      return true;
 
     if (NUW) cast<BinaryOperator>(Inst)->setHasNoUnsignedWrap(true);
     if (NSW) cast<BinaryOperator>(Inst)->setHasNoSignedWrap(true);
@@ -5880,21 +6111,25 @@ int LLParser::ParseInstruction(Instruction *&Inst, BasicBlock *BB,
   case lltok::kw_ashr: {
     bool Exact = EatIfPresent(lltok::kw_exact);
 
-    if (ParseArithmetic(Inst, PFS, KeywordVal, /*IsFP*/false)) return true;
+    if (parseArithmetic(Inst, PFS, KeywordVal, /*IsFP*/ false))
+      return true;
     if (Exact) cast<BinaryOperator>(Inst)->setIsExact(true);
     return false;
   }
 
   case lltok::kw_urem:
-  case lltok::kw_srem:   return ParseArithmetic(Inst, PFS, KeywordVal,
-                                                /*IsFP*/false);
+  case lltok::kw_srem:
+    return parseArithmetic(Inst, PFS, KeywordVal,
+                           /*IsFP*/ false);
   case lltok::kw_and:
   case lltok::kw_or:
-  case lltok::kw_xor:    return ParseLogical(Inst, PFS, KeywordVal);
-  case lltok::kw_icmp:   return ParseCompare(Inst, PFS, KeywordVal);
+  case lltok::kw_xor:
+    return parseLogical(Inst, PFS, KeywordVal);
+  case lltok::kw_icmp:
+    return parseCompare(Inst, PFS, KeywordVal);
   case lltok::kw_fcmp: {
     FastMathFlags FMF = EatFastMathFlagsIfPresent();
-    int Res = ParseCompare(Inst, PFS, KeywordVal);
+    int Res = parseCompare(Inst, PFS, KeywordVal);
     if (Res != 0)
       return Res;
     if (FMF.any())
@@ -5915,63 +6150,84 @@ int LLParser::ParseInstruction(Instruction *&Inst, BasicBlock *BB,
   case lltok::kw_fptoui:
   case lltok::kw_fptosi:
   case lltok::kw_inttoptr:
-  case lltok::kw_ptrtoint:       return ParseCast(Inst, PFS, KeywordVal);
+  case lltok::kw_ptrtoint:
+    return parseCast(Inst, PFS, KeywordVal);
   // Other.
   case lltok::kw_select: {
     FastMathFlags FMF = EatFastMathFlagsIfPresent();
-    int Res = ParseSelect(Inst, PFS);
+    int Res = parseSelect(Inst, PFS);
     if (Res != 0)
       return Res;
     if (FMF.any()) {
       if (!isa<FPMathOperator>(Inst))
-        return Error(Loc, "fast-math-flags specified for select without "
+        return error(Loc, "fast-math-flags specified for select without "
                           "floating-point scalar or vector return type");
       Inst->setFastMathFlags(FMF);
     }
     return 0;
   }
-  case lltok::kw_va_arg:         return ParseVA_Arg(Inst, PFS);
-  case lltok::kw_extractelement: return ParseExtractElement(Inst, PFS);
-  case lltok::kw_insertelement:  return ParseInsertElement(Inst, PFS);
-  case lltok::kw_shufflevector:  return ParseShuffleVector(Inst, PFS);
+  case lltok::kw_va_arg:
+    return parseVAArg(Inst, PFS);
+  case lltok::kw_extractelement:
+    return parseExtractElement(Inst, PFS);
+  case lltok::kw_insertelement:
+    return parseInsertElement(Inst, PFS);
+  case lltok::kw_shufflevector:
+    return parseShuffleVector(Inst, PFS);
   case lltok::kw_phi: {
     FastMathFlags FMF = EatFastMathFlagsIfPresent();
-    int Res = ParsePHI(Inst, PFS);
+    int Res = parsePHI(Inst, PFS);
     if (Res != 0)
       return Res;
     if (FMF.any()) {
       if (!isa<FPMathOperator>(Inst))
-        return Error(Loc, "fast-math-flags specified for phi without "
+        return error(Loc, "fast-math-flags specified for phi without "
                           "floating-point scalar or vector return type");
       Inst->setFastMathFlags(FMF);
     }
     return 0;
   }
-  case lltok::kw_landingpad:     return ParseLandingPad(Inst, PFS);
-  case lltok::kw_freeze:         return ParseFreeze(Inst, PFS);
+  case lltok::kw_landingpad:
+    return parseLandingPad(Inst, PFS);
+  case lltok::kw_freeze:
+    return parseFreeze(Inst, PFS);
   // Call.
-  case lltok::kw_call:     return ParseCall(Inst, PFS, CallInst::TCK_None);
-  case lltok::kw_tail:     return ParseCall(Inst, PFS, CallInst::TCK_Tail);
-  case lltok::kw_musttail: return ParseCall(Inst, PFS, CallInst::TCK_MustTail);
-  case lltok::kw_notail:   return ParseCall(Inst, PFS, CallInst::TCK_NoTail);
+  case lltok::kw_call:
+    return parseCall(Inst, PFS, CallInst::TCK_None);
+  case lltok::kw_tail:
+    return parseCall(Inst, PFS, CallInst::TCK_Tail);
+  case lltok::kw_musttail:
+    return parseCall(Inst, PFS, CallInst::TCK_MustTail);
+  case lltok::kw_notail:
+    return parseCall(Inst, PFS, CallInst::TCK_NoTail);
   // Memory.
-  case lltok::kw_alloca:         return ParseAlloc(Inst, PFS);
-  case lltok::kw_load:           return ParseLoad(Inst, PFS);
-  case lltok::kw_store:          return ParseStore(Inst, PFS);
-  case lltok::kw_cmpxchg:        return ParseCmpXchg(Inst, PFS);
-  case lltok::kw_atomicrmw:      return ParseAtomicRMW(Inst, PFS);
-  case lltok::kw_fence:          return ParseFence(Inst, PFS);
-  case lltok::kw_getelementptr: return ParseGetElementPtr(Inst, PFS);
-  case lltok::kw_extractvalue:  return ParseExtractValue(Inst, PFS);
-  case lltok::kw_insertvalue:   return ParseInsertValue(Inst, PFS);
+  case lltok::kw_alloca:
+    return parseAlloc(Inst, PFS);
+  case lltok::kw_load:
+    return parseLoad(Inst, PFS);
+  case lltok::kw_store:
+    return parseStore(Inst, PFS);
+  case lltok::kw_cmpxchg:
+    return parseCmpXchg(Inst, PFS);
+  case lltok::kw_atomicrmw:
+    return parseAtomicRMW(Inst, PFS);
+  case lltok::kw_fence:
+    return parseFence(Inst, PFS);
+  case lltok::kw_getelementptr:
+    return parseGetElementPtr(Inst, PFS);
+  case lltok::kw_extractvalue:
+    return parseExtractValue(Inst, PFS);
+  case lltok::kw_insertvalue:
+    return parseInsertValue(Inst, PFS);
   }
 }
 
-/// ParseCmpPredicate - Parse an integer or fp predicate, based on Kind.
-bool LLParser::ParseCmpPredicate(unsigned &P, unsigned Opc) {
+/// parseCmpPredicate - parse an integer or fp predicate, based on Kind.
+bool LLParser::parseCmpPredicate(unsigned &P, unsigned Opc) {
   if (Opc == Instruction::FCmp) {
     switch (Lex.getKind()) {
-    default: return TokError("expected fcmp predicate (e.g. 'oeq')");
+    default:
+      return tokError("expected fcmp predicate (e.g. 'oeq')");
     case lltok::kw_oeq: P = CmpInst::FCMP_OEQ; break;
     case lltok::kw_one: P = CmpInst::FCMP_ONE; break;
     case lltok::kw_olt: P = CmpInst::FCMP_OLT; break;
@@ -5991,7 +6247,8 @@ bool LLParser::ParseCmpPredicate(unsigned &P, unsigned Opc) {
     }
   } else {
     switch (Lex.getKind()) {
-    default: return TokError("expected icmp predicate (e.g. 'eq')");
+    default:
+      return tokError("expected icmp predicate (e.g. 'eq')");
     case lltok::kw_eq:  P = CmpInst::ICMP_EQ; break;
     case lltok::kw_ne:  P = CmpInst::ICMP_NE; break;
     case lltok::kw_slt: P = CmpInst::ICMP_SLT; break;
@@ -6012,45 +6269,48 @@ bool LLParser::ParseCmpPredicate(unsigned &P, unsigned Opc) {
 // Terminator Instructions.
 //===----------------------------------------------------------------------===//
 
-/// ParseRet - Parse a return instruction.
+/// parseRet - parse a return instruction.
 ///   ::= 'ret' void (',' !dbg, !1)*
 ///   ::= 'ret' TypeAndValue (',' !dbg, !1)*
-bool LLParser::ParseRet(Instruction *&Inst, BasicBlock *BB,
+bool LLParser::parseRet(Instruction *&Inst, BasicBlock *BB,
                         PerFunctionState &PFS) {
   SMLoc TypeLoc = Lex.getLoc();
   Type *Ty = nullptr;
-  if (ParseType(Ty, true /*void allowed*/)) return true;
+  if (parseType(Ty, true /*void allowed*/))
+    return true;
 
   Type *ResType = PFS.getFunction().getReturnType();
 
   if (Ty->isVoidTy()) {
     if (!ResType->isVoidTy())
-      return Error(TypeLoc, "value doesn't match function result type '" +
-                   getTypeString(ResType) + "'");
+      return error(TypeLoc, "value doesn't match function result type '" +
+                                getTypeString(ResType) + "'");
 
     Inst = ReturnInst::Create(Context);
     return false;
   }
 
   Value *RV;
-  if (ParseValue(Ty, RV, PFS)) return true;
+  if (parseValue(Ty, RV, PFS))
+    return true;
 
   if (ResType != RV->getType())
-    return Error(TypeLoc, "value doesn't match function result type '" +
-                 getTypeString(ResType) + "'");
+    return error(TypeLoc, "value doesn't match function result type '" +
+                              getTypeString(ResType) + "'");
 
   Inst = ReturnInst::Create(Context, RV);
   return false;
 }
 
-/// ParseBr
+/// parseBr
 ///   ::= 'br' TypeAndValue
 ///   ::= 'br' TypeAndValue ',' TypeAndValue ',' TypeAndValue
-bool LLParser::ParseBr(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseBr(Instruction *&Inst, PerFunctionState &PFS) {
   LocTy Loc, Loc2;
   Value *Op0;
   BasicBlock *Op1, *Op2;
-  if (ParseTypeAndValue(Op0, Loc, PFS)) return true;
+  if (parseTypeAndValue(Op0, Loc, PFS))
+    return true;
 
   if (BasicBlock *BB = dyn_cast<BasicBlock>(Op0)) {
     Inst = BranchInst::Create(BB);
@@ -6058,52 +6318,52 @@ bool LLParser::ParseBr(Instruction *&Inst, PerFunctionState &PFS) {
   }
 
   if (Op0->getType() != Type::getInt1Ty(Context))
-    return Error(Loc, "branch condition must have 'i1' type");
+    return error(Loc, "branch condition must have 'i1' type");
 
-  if (ParseToken(lltok::comma, "expected ',' after branch condition") ||
-      ParseTypeAndBasicBlock(Op1, Loc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after true destination") ||
-      ParseTypeAndBasicBlock(Op2, Loc2, PFS))
+  if (parseToken(lltok::comma, "expected ',' after branch condition") ||
+      parseTypeAndBasicBlock(Op1, Loc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after true destination") ||
+      parseTypeAndBasicBlock(Op2, Loc2, PFS))
     return true;
 
   Inst = BranchInst::Create(Op1, Op2, Op0);
   return false;
 }
 
-/// ParseSwitch
+/// parseSwitch
 ///  Instruction
 ///    ::= 'switch' TypeAndValue ',' TypeAndValue '[' JumpTable ']'
 ///  JumpTable
 ///    ::= (TypeAndValue ',' TypeAndValue)*
-bool LLParser::ParseSwitch(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseSwitch(Instruction *&Inst, PerFunctionState &PFS) {
   LocTy CondLoc, BBLoc;
   Value *Cond;
   BasicBlock *DefaultBB;
-  if (ParseTypeAndValue(Cond, CondLoc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after switch condition") ||
-      ParseTypeAndBasicBlock(DefaultBB, BBLoc, PFS) ||
-      ParseToken(lltok::lsquare, "expected '[' with switch table"))
+  if (parseTypeAndValue(Cond, CondLoc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after switch condition") ||
+      parseTypeAndBasicBlock(DefaultBB, BBLoc, PFS) ||
+      parseToken(lltok::lsquare, "expected '[' with switch table"))
     return true;
 
   if (!Cond->getType()->isIntegerTy())
-    return Error(CondLoc, "switch condition must have integer type");
+    return error(CondLoc, "switch condition must have integer type");
 
-  // Parse the jump table pairs.
+  // parse the jump table pairs.
   SmallPtrSet<Value*, 32> SeenCases;
   SmallVector<std::pair<ConstantInt*, BasicBlock*>, 32> Table;
   while (Lex.getKind() != lltok::rsquare) {
     Value *Constant;
     BasicBlock *DestBB;
 
-    if (ParseTypeAndValue(Constant, CondLoc, PFS) ||
-        ParseToken(lltok::comma, "expected ',' after case value") ||
-        ParseTypeAndBasicBlock(DestBB, PFS))
+    if (parseTypeAndValue(Constant, CondLoc, PFS) ||
+        parseToken(lltok::comma, "expected ',' after case value") ||
+        parseTypeAndBasicBlock(DestBB, PFS))
       return true;
 
     if (!SeenCases.insert(Constant).second)
-      return Error(CondLoc, "duplicate case value in switch");
+      return error(CondLoc, "duplicate case value in switch");
     if (!isa<ConstantInt>(Constant))
-      return Error(CondLoc, "case value is not a constant integer");
+      return error(CondLoc, "case value is not a constant integer");
 
     Table.push_back(std::make_pair(cast<ConstantInt>(Constant), DestBB));
   }
@@ -6117,37 +6377,37 @@ bool LLParser::ParseSwitch(Instruction *&Inst, PerFunctionState &PFS) {
   return false;
 }
 
-/// ParseIndirectBr
+/// parseIndirectBr
 ///  Instruction
 ///    ::= 'indirectbr' TypeAndValue ',' '[' LabelList ']'
-bool LLParser::ParseIndirectBr(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseIndirectBr(Instruction *&Inst, PerFunctionState &PFS) {
   LocTy AddrLoc;
   Value *Address;
-  if (ParseTypeAndValue(Address, AddrLoc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after indirectbr address") ||
-      ParseToken(lltok::lsquare, "expected '[' with indirectbr"))
+  if (parseTypeAndValue(Address, AddrLoc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after indirectbr address") ||
+      parseToken(lltok::lsquare, "expected '[' with indirectbr"))
     return true;
 
   if (!Address->getType()->isPointerTy())
-    return Error(AddrLoc, "indirectbr address must have pointer type");
+    return error(AddrLoc, "indirectbr address must have pointer type");
 
-  // Parse the destination list.
+  // parse the destination list.
   SmallVector<BasicBlock*, 16> DestList;
 
   if (Lex.getKind() != lltok::rsquare) {
     BasicBlock *DestBB;
-    if (ParseTypeAndBasicBlock(DestBB, PFS))
+    if (parseTypeAndBasicBlock(DestBB, PFS))
       return true;
     DestList.push_back(DestBB);
 
     while (EatIfPresent(lltok::comma)) {
-      if (ParseTypeAndBasicBlock(DestBB, PFS))
+      if (parseTypeAndBasicBlock(DestBB, PFS))
         return true;
       DestList.push_back(DestBB);
     }
   }
 
-  if (ParseToken(lltok::rsquare, "expected ']' at end of block list"))
+  if (parseToken(lltok::rsquare, "expected ']' at end of block list"))
     return true;
 
   IndirectBrInst *IBI = IndirectBrInst::Create(Address, DestList.size());
@@ -6157,10 +6417,10 @@ bool LLParser::ParseIndirectBr(Instruction *&Inst, PerFunctionState &PFS) {
   return false;
 }
 
-/// ParseInvoke
+/// parseInvoke
 ///   ::= 'invoke' OptionalCallingConv OptionalAttrs Type Value ParamList
 ///       OptionalAttrs 'to' TypeAndValue 'unwind' TypeAndValue
-bool LLParser::ParseInvoke(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseInvoke(Instruction *&Inst, PerFunctionState &PFS) {
   LocTy CallLoc = Lex.getLoc();
   AttrBuilder RetAttrs, FnAttrs;
   std::vector<unsigned> FwdRefAttrGrps;
@@ -6174,17 +6434,17 @@ bool LLParser::ParseInvoke(Instruction *&Inst, PerFunctionState &PFS) {
   SmallVector<OperandBundleDef, 2> BundleList;
 
   BasicBlock *NormalBB, *UnwindBB;
-  if (ParseOptionalCallingConv(CC) || ParseOptionalReturnAttrs(RetAttrs) ||
-      ParseOptionalProgramAddrSpace(InvokeAddrSpace) ||
-      ParseType(RetType, RetTypeLoc, true /*void allowed*/) ||
-      ParseValID(CalleeID) || ParseParameterList(ArgList, PFS) ||
-      ParseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false,
+  if (parseOptionalCallingConv(CC) || parseOptionalReturnAttrs(RetAttrs) ||
+      parseOptionalProgramAddrSpace(InvokeAddrSpace) ||
+      parseType(RetType, RetTypeLoc, true /*void allowed*/) ||
+      parseValID(CalleeID) || parseParameterList(ArgList, PFS) ||
+      parseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false,
                                  NoBuiltinLoc) ||
-      ParseOptionalOperandBundles(BundleList, PFS) ||
-      ParseToken(lltok::kw_to, "expected 'to' in invoke") ||
-      ParseTypeAndBasicBlock(NormalBB, PFS) ||
-      ParseToken(lltok::kw_unwind, "expected 'unwind' in invoke") ||
-      ParseTypeAndBasicBlock(UnwindBB, PFS))
+      parseOptionalOperandBundles(BundleList, PFS) ||
+      parseToken(lltok::kw_to, "expected 'to' in invoke") ||
+      parseTypeAndBasicBlock(NormalBB, PFS) ||
+      parseToken(lltok::kw_unwind, "expected 'unwind' in invoke") ||
+      parseTypeAndBasicBlock(UnwindBB, PFS))
     return true;
 
   // If RetType is a non-function pointer type, then this is the short syntax
@@ -6266,29 +6526,29 @@ bool LLParser::ParseResume(Instruction *&Inst, PerFunctionState &PFS) {
   return false;
 }
 
-bool LLParser::ParseExceptionArgs(SmallVectorImpl<Value *> &Args,
+bool LLParser::parseExceptionArgs(SmallVectorImpl<Value *> &Args,
                                   PerFunctionState &PFS) {
-  if (ParseToken(lltok::lsquare, "expected '[' in catchpad/cleanuppad"))
+  if (parseToken(lltok::lsquare, "expected '[' in catchpad/cleanuppad"))
     return true;
 
   while (Lex.getKind() != lltok::rsquare) {
     // If this isn't the first argument, we need a comma.
     if (!Args.empty() &&
-        ParseToken(lltok::comma, "expected ',' in argument list"))
+        parseToken(lltok::comma, "expected ',' in argument list"))
       return true;
 
-    // Parse the argument.
+    // parse the argument.
     LocTy ArgLoc;
     Type *ArgTy = nullptr;
-    if (ParseType(ArgTy, ArgLoc))
+    if (parseType(ArgTy, ArgLoc))
       return true;
 
     Value *V;
     if (ArgTy->isMetadataTy()) {
-      if (ParseMetadataAsValue(V, PFS))
+      if (parseMetadataAsValue(V, PFS))
         return true;
     } else {
-      if (ParseValue(ArgTy, V, PFS))
+      if (parseValue(ArgTy, V, PFS))
         return true;
     }
     Args.push_back(V);
@@ -6298,27 +6558,27 @@ bool LLParser::ParseExceptionArgs(SmallVectorImpl<Value *> &Args,
   return false;
 }
 
-/// ParseCleanupRet
+/// parseCleanupRet
 ///   ::= 'cleanupret' from Value unwind ('to' 'caller' | TypeAndValue)
-bool LLParser::ParseCleanupRet(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseCleanupRet(Instruction *&Inst, PerFunctionState &PFS) {
   Value *CleanupPad = nullptr;
 
-  if (ParseToken(lltok::kw_from, "expected 'from' after cleanupret"))
+  if (parseToken(lltok::kw_from, "expected 'from' after cleanupret"))
     return true;
 
-  if (ParseValue(Type::getTokenTy(Context), CleanupPad, PFS))
+  if (parseValue(Type::getTokenTy(Context), CleanupPad, PFS))
     return true;
 
-  if (ParseToken(lltok::kw_unwind, "expected 'unwind' in cleanupret"))
+  if (parseToken(lltok::kw_unwind, "expected 'unwind' in cleanupret"))
     return true;
 
   BasicBlock *UnwindBB = nullptr;
   if (Lex.getKind() == lltok::kw_to) {
     Lex.Lex();
-    if (ParseToken(lltok::kw_caller, "expected 'caller' in cleanupret"))
+    if (parseToken(lltok::kw_caller, "expected 'caller' in cleanupret"))
       return true;
   } else {
-    if (ParseTypeAndBasicBlock(UnwindBB, PFS)) {
+    if (parseTypeAndBasicBlock(UnwindBB, PFS)) {
       return true;
     }
   }
@@ -6327,65 +6587,64 @@ bool LLParser::ParseCleanupRet(Instruction *&Inst, PerFunctionState &PFS) {
   return false;
 }
 
-/// ParseCatchRet
+/// parseCatchRet
 ///   ::= 'catchret' from Parent Value 'to' TypeAndValue
-bool LLParser::ParseCatchRet(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseCatchRet(Instruction *&Inst, PerFunctionState &PFS) {
   Value *CatchPad = nullptr;
 
-  if (ParseToken(lltok::kw_from, "expected 'from' after catchret"))
+  if (parseToken(lltok::kw_from, "expected 'from' after catchret"))
     return true;
 
-  if (ParseValue(Type::getTokenTy(Context), CatchPad, PFS))
+  if (parseValue(Type::getTokenTy(Context), CatchPad, PFS))
     return true;
 
   BasicBlock *BB;
-  if (ParseToken(lltok::kw_to, "expected 'to' in catchret") ||
-      ParseTypeAndBasicBlock(BB, PFS))
-      return true;
+  if (parseToken(lltok::kw_to, "expected 'to' in catchret") ||
+      parseTypeAndBasicBlock(BB, PFS))
+    return true;
 
   Inst = CatchReturnInst::Create(CatchPad, BB);
   return false;
 }
 
-/// ParseCatchSwitch
+/// parseCatchSwitch
 ///   ::= 'catchswitch' within Parent
-bool LLParser::ParseCatchSwitch(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseCatchSwitch(Instruction *&Inst, PerFunctionState &PFS) {
   Value *ParentPad;
 
-  if (ParseToken(lltok::kw_within, "expected 'within' after catchswitch"))
+  if (parseToken(lltok::kw_within, "expected 'within' after catchswitch"))
     return true;
 
   if (Lex.getKind() != lltok::kw_none && Lex.getKind() != lltok::LocalVar &&
       Lex.getKind() != lltok::LocalVarID)
-    return TokError("expected scope value for catchswitch");
+    return tokError("expected scope value for catchswitch");
 
-  if (ParseValue(Type::getTokenTy(Context), ParentPad, PFS))
+  if (parseValue(Type::getTokenTy(Context), ParentPad, PFS))
     return true;
 
-  if (ParseToken(lltok::lsquare, "expected '[' with catchswitch labels"))
+  if (parseToken(lltok::lsquare, "expected '[' with catchswitch labels"))
     return true;
 
   SmallVector<BasicBlock *, 32> Table;
   do {
     BasicBlock *DestBB;
-    if (ParseTypeAndBasicBlock(DestBB, PFS))
+    if (parseTypeAndBasicBlock(DestBB, PFS))
       return true;
     Table.push_back(DestBB);
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rsquare, "expected ']' after catchswitch labels"))
+  if (parseToken(lltok::rsquare, "expected ']' after catchswitch labels"))
     return true;
 
-  if (ParseToken(lltok::kw_unwind,
-                 "expected 'unwind' after catchswitch scope"))
+  if (parseToken(lltok::kw_unwind, "expected 'unwind' after catchswitch scope"))
     return true;
 
   BasicBlock *UnwindBB = nullptr;
   if (EatIfPresent(lltok::kw_to)) {
-    if (ParseToken(lltok::kw_caller, "expected 'caller' in catchswitch"))
+    if (parseToken(lltok::kw_caller, "expected 'caller' in catchswitch"))
       return true;
   } else {
-    if (ParseTypeAndBasicBlock(UnwindBB, PFS))
+    if (parseTypeAndBasicBlock(UnwindBB, PFS))
       return true;
   }
 
@@ -6397,45 +6656,45 @@ bool LLParser::ParseCatchSwitch(Instruction *&Inst, PerFunctionState &PFS) {
   return false;
 }
 
-/// ParseCatchPad
+/// parseCatchPad
 ///   ::= 'catchpad' ParamList 'to' TypeAndValue 'unwind' TypeAndValue
-bool LLParser::ParseCatchPad(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseCatchPad(Instruction *&Inst, PerFunctionState &PFS) {
   Value *CatchSwitch = nullptr;
 
-  if (ParseToken(lltok::kw_within, "expected 'within' after catchpad"))
+  if (parseToken(lltok::kw_within, "expected 'within' after catchpad"))
     return true;
 
   if (Lex.getKind() != lltok::LocalVar && Lex.getKind() != lltok::LocalVarID)
-    return TokError("expected scope value for catchpad");
+    return tokError("expected scope value for catchpad");
 
-  if (ParseValue(Type::getTokenTy(Context), CatchSwitch, PFS))
+  if (parseValue(Type::getTokenTy(Context), CatchSwitch, PFS))
     return true;
 
   SmallVector<Value *, 8> Args;
-  if (ParseExceptionArgs(Args, PFS))
+  if (parseExceptionArgs(Args, PFS))
     return true;
 
   Inst = CatchPadInst::Create(CatchSwitch, Args);
   return false;
 }
 
-/// ParseCleanupPad
+/// parseCleanupPad
 ///   ::= 'cleanuppad' within Parent ParamList
-bool LLParser::ParseCleanupPad(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseCleanupPad(Instruction *&Inst, PerFunctionState &PFS) {
   Value *ParentPad = nullptr;
 
-  if (ParseToken(lltok::kw_within, "expected 'within' after cleanuppad"))
+  if (parseToken(lltok::kw_within, "expected 'within' after cleanuppad"))
     return true;
 
   if (Lex.getKind() != lltok::kw_none && Lex.getKind() != lltok::LocalVar &&
       Lex.getKind() != lltok::LocalVarID)
-    return TokError("expected scope value for cleanuppad");
+    return tokError("expected scope value for cleanuppad");
 
-  if (ParseValue(Type::getTokenTy(Context), ParentPad, PFS))
+  if (parseValue(Type::getTokenTy(Context), ParentPad, PFS))
     return true;
 
   SmallVector<Value *, 8> Args;
-  if (ParseExceptionArgs(Args, PFS))
+  if (parseExceptionArgs(Args, PFS))
     return true;
 
   Inst = CleanupPadInst::Create(ParentPad, Args);
@@ -6446,32 +6705,32 @@ bool LLParser::ParseCleanupPad(Instruction *&Inst, PerFunctionState &PFS) {
 // Unary Operators.
 //===----------------------------------------------------------------------===//
 
-/// ParseUnaryOp
+/// parseUnaryOp
 ///  ::= UnaryOp TypeAndValue ',' Value
 ///
 /// If IsFP is false, then any integer operand is allowed, if it is true, any fp
 /// operand is allowed.
-bool LLParser::ParseUnaryOp(Instruction *&Inst, PerFunctionState &PFS,
+bool LLParser::parseUnaryOp(Instruction *&Inst, PerFunctionState &PFS,
                             unsigned Opc, bool IsFP) {
   LocTy Loc; Value *LHS;
-  if (ParseTypeAndValue(LHS, Loc, PFS))
+  if (parseTypeAndValue(LHS, Loc, PFS))
     return true;
 
   bool Valid = IsFP ? LHS->getType()->isFPOrFPVectorTy()
                     : LHS->getType()->isIntOrIntVectorTy();
 
   if (!Valid)
-    return Error(Loc, "invalid operand type for instruction");
+    return error(Loc, "invalid operand type for instruction");
 
   Inst = UnaryOperator::Create((Instruction::UnaryOps)Opc, LHS);
   return false;
 }
 
-/// ParseCallBr
+/// parseCallBr
 ///   ::= 'callbr' OptionalCallingConv OptionalAttrs Type Value ParamList
 ///       OptionalAttrs OptionalOperandBundles 'to' TypeAndValue
 ///       '[' LabelList ']'
-bool LLParser::ParseCallBr(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseCallBr(Instruction *&Inst, PerFunctionState &PFS) {
   LocTy CallLoc = Lex.getLoc();
   AttrBuilder RetAttrs, FnAttrs;
   std::vector<unsigned> FwdRefAttrGrps;
@@ -6484,34 +6743,34 @@ bool LLParser::ParseCallBr(Instruction *&Inst, PerFunctionState &PFS) {
   SmallVector<OperandBundleDef, 2> BundleList;
 
   BasicBlock *DefaultDest;
-  if (ParseOptionalCallingConv(CC) || ParseOptionalReturnAttrs(RetAttrs) ||
-      ParseType(RetType, RetTypeLoc, true /*void allowed*/) ||
-      ParseValID(CalleeID) || ParseParameterList(ArgList, PFS) ||
-      ParseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false,
+  if (parseOptionalCallingConv(CC) || parseOptionalReturnAttrs(RetAttrs) ||
+      parseType(RetType, RetTypeLoc, true /*void allowed*/) ||
+      parseValID(CalleeID) || parseParameterList(ArgList, PFS) ||
+      parseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false,
                                  NoBuiltinLoc) ||
-      ParseOptionalOperandBundles(BundleList, PFS) ||
-      ParseToken(lltok::kw_to, "expected 'to' in callbr") ||
-      ParseTypeAndBasicBlock(DefaultDest, PFS) ||
-      ParseToken(lltok::lsquare, "expected '[' in callbr"))
+      parseOptionalOperandBundles(BundleList, PFS) ||
+      parseToken(lltok::kw_to, "expected 'to' in callbr") ||
+      parseTypeAndBasicBlock(DefaultDest, PFS) ||
+      parseToken(lltok::lsquare, "expected '[' in callbr"))
     return true;
 
-  // Parse the destination list.
+  // parse the destination list.
   SmallVector<BasicBlock *, 16> IndirectDests;
 
   if (Lex.getKind() != lltok::rsquare) {
     BasicBlock *DestBB;
-    if (ParseTypeAndBasicBlock(DestBB, PFS))
+    if (parseTypeAndBasicBlock(DestBB, PFS))
       return true;
     IndirectDests.push_back(DestBB);
 
     while (EatIfPresent(lltok::comma)) {
-      if (ParseTypeAndBasicBlock(DestBB, PFS))
+      if (parseTypeAndBasicBlock(DestBB, PFS))
         return true;
       IndirectDests.push_back(DestBB);
     }
   }
 
-  if (ParseToken(lltok::rsquare, "expected ']' at end of block list"))
+  if (parseToken(lltok::rsquare, "expected ']' at end of block list"))
     return true;
 
   // If RetType is a non-function pointer type, then this is the short syntax
@@ -6525,7 +6784,7 @@ bool LLParser::ParseCallBr(Instruction *&Inst, PerFunctionState &PFS) {
       ParamTypes.push_back(ArgList[i].V->getType());
 
     if (!FunctionType::isValidReturnType(RetType))
-      return Error(RetTypeLoc, "Invalid result type for LLVM function");
+      return error(RetTypeLoc, "Invalid result type for LLVM function");
 
     Ty = FunctionType::get(RetType, ParamTypes, false);
   }
@@ -6534,7 +6793,7 @@ bool LLParser::ParseCallBr(Instruction *&Inst, PerFunctionState &PFS) {
 
   // Look up the callee.
   Value *Callee;
-  if (ConvertValIDToValue(PointerType::getUnqual(Ty), CalleeID, Callee, &PFS,
+  if (convertValIDToValue(PointerType::getUnqual(Ty), CalleeID, Callee, &PFS,
                           /*IsCall=*/true))
     return true;
 
@@ -6551,21 +6810,21 @@ bool LLParser::ParseCallBr(Instruction *&Inst, PerFunctionState &PFS) {
     if (I != E) {
       ExpectedTy = *I++;
     } else if (!Ty->isVarArg()) {
-      return Error(ArgList[i].Loc, "too many arguments specified");
+      return error(ArgList[i].Loc, "too many arguments specified");
     }
 
     if (ExpectedTy && ExpectedTy != ArgList[i].V->getType())
-      return Error(ArgList[i].Loc, "argument is not of expected type '" +
+      return error(ArgList[i].Loc, "argument is not of expected type '" +
                                        getTypeString(ExpectedTy) + "'");
     Args.push_back(ArgList[i].V);
     ArgAttrs.push_back(ArgList[i].Attrs);
   }
 
   if (I != E)
-    return Error(CallLoc, "not enough parameters specified for call");
+    return error(CallLoc, "not enough parameters specified for call");
 
   if (FnAttrs.hasAlignmentAttr())
-    return Error(CallLoc, "callbr instructions may not have an alignment");
+    return error(CallLoc, "callbr instructions may not have an alignment");
 
   // Finish off the Attribute and check them
   AttributeList PAL =
@@ -6586,70 +6845,70 @@ bool LLParser::ParseCallBr(Instruction *&Inst, PerFunctionState &PFS) {
 // Binary Operators.
 //===----------------------------------------------------------------------===//
 
-/// ParseArithmetic
+/// parseArithmetic
 ///  ::= ArithmeticOps TypeAndValue ',' Value
 ///
 /// If IsFP is false, then any integer operand is allowed, if it is true, any fp
 /// operand is allowed.
-bool LLParser::ParseArithmetic(Instruction *&Inst, PerFunctionState &PFS,
+bool LLParser::parseArithmetic(Instruction *&Inst, PerFunctionState &PFS,
                                unsigned Opc, bool IsFP) {
   LocTy Loc; Value *LHS, *RHS;
-  if (ParseTypeAndValue(LHS, Loc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' in arithmetic operation") ||
-      ParseValue(LHS->getType(), RHS, PFS))
+  if (parseTypeAndValue(LHS, Loc, PFS) ||
+      parseToken(lltok::comma, "expected ',' in arithmetic operation") ||
+      parseValue(LHS->getType(), RHS, PFS))
     return true;
 
   bool Valid = IsFP ? LHS->getType()->isFPOrFPVectorTy()
                     : LHS->getType()->isIntOrIntVectorTy();
 
   if (!Valid)
-    return Error(Loc, "invalid operand type for instruction");
+    return error(Loc, "invalid operand type for instruction");
 
   Inst = BinaryOperator::Create((Instruction::BinaryOps)Opc, LHS, RHS);
   return false;
 }
 
-/// ParseLogical
+/// parseLogical
 ///  ::= ArithmeticOps TypeAndValue ',' Value {
-bool LLParser::ParseLogical(Instruction *&Inst, PerFunctionState &PFS,
+bool LLParser::parseLogical(Instruction *&Inst, PerFunctionState &PFS,
                             unsigned Opc) {
   LocTy Loc; Value *LHS, *RHS;
-  if (ParseTypeAndValue(LHS, Loc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' in logical operation") ||
-      ParseValue(LHS->getType(), RHS, PFS))
+  if (parseTypeAndValue(LHS, Loc, PFS) ||
+      parseToken(lltok::comma, "expected ',' in logical operation") ||
+      parseValue(LHS->getType(), RHS, PFS))
     return true;
 
   if (!LHS->getType()->isIntOrIntVectorTy())
-    return Error(Loc,"instruction requires integer or integer vector operands");
+    return error(Loc,
+                 "instruction requires integer or integer vector operands");
 
   Inst = BinaryOperator::Create((Instruction::BinaryOps)Opc, LHS, RHS);
   return false;
 }
 
-/// ParseCompare
+/// parseCompare
 ///  ::= 'icmp' IPredicates TypeAndValue ',' Value
 ///  ::= 'fcmp' FPredicates TypeAndValue ',' Value
-bool LLParser::ParseCompare(Instruction *&Inst, PerFunctionState &PFS,
+bool LLParser::parseCompare(Instruction *&Inst, PerFunctionState &PFS,
                             unsigned Opc) {
-  // Parse the integer/fp comparison predicate.
+  // parse the integer/fp comparison predicate.
   LocTy Loc;
   unsigned Pred;
   Value *LHS, *RHS;
-  if (ParseCmpPredicate(Pred, Opc) ||
-      ParseTypeAndValue(LHS, Loc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after compare value") ||
-      ParseValue(LHS->getType(), RHS, PFS))
+  if (parseCmpPredicate(Pred, Opc) || parseTypeAndValue(LHS, Loc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after compare value") ||
+      parseValue(LHS->getType(), RHS, PFS))
     return true;
 
   if (Opc == Instruction::FCmp) {
     if (!LHS->getType()->isFPOrFPVectorTy())
-      return Error(Loc, "fcmp requires floating point operands");
+      return error(Loc, "fcmp requires floating point operands");
     Inst = new FCmpInst(CmpInst::Predicate(Pred), LHS, RHS);
   } else {
     assert(Opc == Instruction::ICmp && "Unknown opcode for CmpInst!");
     if (!LHS->getType()->isIntOrIntVectorTy() &&
         !LHS->getType()->isPtrOrPtrVectorTy())
-      return Error(Loc, "icmp requires integer operands");
+      return error(Loc, "icmp requires integer operands");
     Inst = new ICmpInst(CmpInst::Predicate(Pred), LHS, RHS);
   }
   return false;
@@ -6659,133 +6918,132 @@ bool LLParser::ParseCompare(Instruction *&Inst, PerFunctionState &PFS,
 // Other Instructions.
 //===----------------------------------------------------------------------===//
 
-
-/// ParseCast
+/// parseCast
 ///   ::= CastOpc TypeAndValue 'to' Type
-bool LLParser::ParseCast(Instruction *&Inst, PerFunctionState &PFS,
+bool LLParser::parseCast(Instruction *&Inst, PerFunctionState &PFS,
                          unsigned Opc) {
   LocTy Loc;
   Value *Op;
   Type *DestTy = nullptr;
-  if (ParseTypeAndValue(Op, Loc, PFS) ||
-      ParseToken(lltok::kw_to, "expected 'to' after cast value") ||
-      ParseType(DestTy))
+  if (parseTypeAndValue(Op, Loc, PFS) ||
+      parseToken(lltok::kw_to, "expected 'to' after cast value") ||
+      parseType(DestTy))
     return true;
 
   if (!CastInst::castIsValid((Instruction::CastOps)Opc, Op, DestTy)) {
     CastInst::castIsValid((Instruction::CastOps)Opc, Op, DestTy);
-    return Error(Loc, "invalid cast opcode for cast from '" +
-                 getTypeString(Op->getType()) + "' to '" +
-                 getTypeString(DestTy) + "'");
+    return error(Loc, "invalid cast opcode for cast from '" +
+                          getTypeString(Op->getType()) + "' to '" +
+                          getTypeString(DestTy) + "'");
   }
   Inst = CastInst::Create((Instruction::CastOps)Opc, Op, DestTy);
   return false;
 }
 
-/// ParseSelect
+/// parseSelect
 ///   ::= 'select' TypeAndValue ',' TypeAndValue ',' TypeAndValue
-bool LLParser::ParseSelect(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseSelect(Instruction *&Inst, PerFunctionState &PFS) {
   LocTy Loc;
   Value *Op0, *Op1, *Op2;
-  if (ParseTypeAndValue(Op0, Loc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after select condition") ||
-      ParseTypeAndValue(Op1, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after select value") ||
-      ParseTypeAndValue(Op2, PFS))
+  if (parseTypeAndValue(Op0, Loc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after select condition") ||
+      parseTypeAndValue(Op1, PFS) ||
+      parseToken(lltok::comma, "expected ',' after select value") ||
+      parseTypeAndValue(Op2, PFS))
     return true;
 
   if (const char *Reason = SelectInst::areInvalidOperands(Op0, Op1, Op2))
-    return Error(Loc, Reason);
+    return error(Loc, Reason);
 
   Inst = SelectInst::Create(Op0, Op1, Op2);
   return false;
 }
 
-/// ParseVA_Arg
+/// parseVAArg
 ///   ::= 'va_arg' TypeAndValue ',' Type
-bool LLParser::ParseVA_Arg(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseVAArg(Instruction *&Inst, PerFunctionState &PFS) {
   Value *Op;
   Type *EltTy = nullptr;
   LocTy TypeLoc;
-  if (ParseTypeAndValue(Op, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after vaarg operand") ||
-      ParseType(EltTy, TypeLoc))
+  if (parseTypeAndValue(Op, PFS) ||
+      parseToken(lltok::comma, "expected ',' after vaarg operand") ||
+      parseType(EltTy, TypeLoc))
     return true;
 
   if (!EltTy->isFirstClassType())
-    return Error(TypeLoc, "va_arg requires operand with first class type");
+    return error(TypeLoc, "va_arg requires operand with first class type");
 
   Inst = new VAArgInst(Op, EltTy);
   return false;
 }
 
-/// ParseExtractElement
+/// parseExtractElement
 ///   ::= 'extractelement' TypeAndValue ',' TypeAndValue
-bool LLParser::ParseExtractElement(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseExtractElement(Instruction *&Inst, PerFunctionState &PFS) {
   LocTy Loc;
   Value *Op0, *Op1;
-  if (ParseTypeAndValue(Op0, Loc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after extract value") ||
-      ParseTypeAndValue(Op1, PFS))
+  if (parseTypeAndValue(Op0, Loc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after extract value") ||
+      parseTypeAndValue(Op1, PFS))
     return true;
 
   if (!ExtractElementInst::isValidOperands(Op0, Op1))
-    return Error(Loc, "invalid extractelement operands");
+    return error(Loc, "invalid extractelement operands");
 
   Inst = ExtractElementInst::Create(Op0, Op1);
   return false;
 }
 
-/// ParseInsertElement
+/// parseInsertElement
 ///   ::= 'insertelement' TypeAndValue ',' TypeAndValue ',' TypeAndValue
-bool LLParser::ParseInsertElement(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseInsertElement(Instruction *&Inst, PerFunctionState &PFS) {
   LocTy Loc;
   Value *Op0, *Op1, *Op2;
-  if (ParseTypeAndValue(Op0, Loc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after insertelement value") ||
-      ParseTypeAndValue(Op1, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after insertelement value") ||
-      ParseTypeAndValue(Op2, PFS))
+  if (parseTypeAndValue(Op0, Loc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after insertelement value") ||
+      parseTypeAndValue(Op1, PFS) ||
+      parseToken(lltok::comma, "expected ',' after insertelement value") ||
+      parseTypeAndValue(Op2, PFS))
     return true;
 
   if (!InsertElementInst::isValidOperands(Op0, Op1, Op2))
-    return Error(Loc, "invalid insertelement operands");
+    return error(Loc, "invalid insertelement operands");
 
   Inst = InsertElementInst::Create(Op0, Op1, Op2);
   return false;
 }
 
-/// ParseShuffleVector
+/// parseShuffleVector
 ///   ::= 'shufflevector' TypeAndValue ',' TypeAndValue ',' TypeAndValue
-bool LLParser::ParseShuffleVector(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseShuffleVector(Instruction *&Inst, PerFunctionState &PFS) {
   LocTy Loc;
   Value *Op0, *Op1, *Op2;
-  if (ParseTypeAndValue(Op0, Loc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after shuffle mask") ||
-      ParseTypeAndValue(Op1, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after shuffle value") ||
-      ParseTypeAndValue(Op2, PFS))
+  if (parseTypeAndValue(Op0, Loc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after shuffle mask") ||
+      parseTypeAndValue(Op1, PFS) ||
+      parseToken(lltok::comma, "expected ',' after shuffle value") ||
+      parseTypeAndValue(Op2, PFS))
     return true;
 
   if (!ShuffleVectorInst::isValidOperands(Op0, Op1, Op2))
-    return Error(Loc, "invalid shufflevector operands");
+    return error(Loc, "invalid shufflevector operands");
 
   Inst = new ShuffleVectorInst(Op0, Op1, Op2);
   return false;
 }
 
-/// ParsePHI
+/// parsePHI
 ///   ::= 'phi' Type '[' Value ',' Value ']' (',' '[' Value ',' Value ']')*
-int LLParser::ParsePHI(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parsePHI(Instruction *&Inst, PerFunctionState &PFS) {
   Type *Ty = nullptr;  LocTy TypeLoc;
   Value *Op0, *Op1;
 
-  if (ParseType(Ty, TypeLoc) ||
-      ParseToken(lltok::lsquare, "expected '[' in phi value list") ||
-      ParseValue(Ty, Op0, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after insertelement value") ||
-      ParseValue(Type::getLabelTy(Context), Op1, PFS) ||
-      ParseToken(lltok::rsquare, "expected ']' in phi value list"))
+  if (parseType(Ty, TypeLoc) ||
+      parseToken(lltok::lsquare, "expected '[' in phi value list") ||
+      parseValue(Ty, Op0, PFS) ||
+      parseToken(lltok::comma, "expected ',' after insertelement value") ||
+      parseValue(Type::getLabelTy(Context), Op1, PFS) ||
+      parseToken(lltok::rsquare, "expected ']' in phi value list"))
     return true;
 
   bool AteExtraComma = false;
@@ -6802,16 +7060,16 @@ int LLParser::ParsePHI(Instruction *&Inst, PerFunctionState &PFS) {
       break;
     }
 
-    if (ParseToken(lltok::lsquare, "expected '[' in phi value list") ||
-        ParseValue(Ty, Op0, PFS) ||
-        ParseToken(lltok::comma, "expected ',' after insertelement value") ||
-        ParseValue(Type::getLabelTy(Context), Op1, PFS) ||
-        ParseToken(lltok::rsquare, "expected ']' in phi value list"))
+    if (parseToken(lltok::lsquare, "expected '[' in phi value list") ||
+        parseValue(Ty, Op0, PFS) ||
+        parseToken(lltok::comma, "expected ',' after insertelement value") ||
+        parseValue(Type::getLabelTy(Context), Op1, PFS) ||
+        parseToken(lltok::rsquare, "expected ']' in phi value list"))
       return true;
   }
 
   if (!Ty->isFirstClassType())
-    return Error(TypeLoc, "phi node must have first class type");
+    return error(TypeLoc, "phi node must have first class type");
 
   PHINode *PN = PHINode::Create(Ty, PHIVals.size());
   for (unsigned i = 0, e = PHIVals.size(); i != e; ++i)
@@ -6820,16 +7078,16 @@ int LLParser::ParsePHI(Instruction *&Inst, PerFunctionState &PFS) {
   return AteExtraComma ? InstExtraComma : InstNormal;
 }
 
-/// ParseLandingPad
+/// parseLandingPad
 ///   ::= 'landingpad' Type 'personality' TypeAndValue 'cleanup'? Clause+
 /// Clause
 ///   ::= 'catch' TypeAndValue
 ///   ::= 'filter'
 ///   ::= 'filter' TypeAndValue ( ',' TypeAndValue )*
-bool LLParser::ParseLandingPad(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseLandingPad(Instruction *&Inst, PerFunctionState &PFS) {
   Type *Ty = nullptr; LocTy TyLoc;
 
-  if (ParseType(Ty, TyLoc))
+  if (parseType(Ty, TyLoc))
     return true;
 
   std::unique_ptr<LandingPadInst> LP(LandingPadInst::Create(Ty, 0));
@@ -6842,26 +7100,26 @@ bool LLParser::ParseLandingPad(Instruction *&Inst, PerFunctionState &PFS) {
     else if (EatIfPresent(lltok::kw_filter))
       CT = LandingPadInst::Filter;
     else
-      return TokError("expected 'catch' or 'filter' clause type");
+      return tokError("expected 'catch' or 'filter' clause type");
 
     Value *V;
     LocTy VLoc;
-    if (ParseTypeAndValue(V, VLoc, PFS))
+    if (parseTypeAndValue(V, VLoc, PFS))
       return true;
 
     // A 'catch' type expects a non-array constant. A filter clause expects an
     // array constant.
     if (CT == LandingPadInst::Catch) {
       if (isa<ArrayType>(V->getType()))
-        Error(VLoc, "'catch' clause has an invalid type");
+        error(VLoc, "'catch' clause has an invalid type");
     } else {
       if (!isa<ArrayType>(V->getType()))
-        Error(VLoc, "'filter' clause has an invalid type");
+        error(VLoc, "'filter' clause has an invalid type");
     }
 
     Constant *CV = dyn_cast<Constant>(V);
     if (!CV)
-      return Error(VLoc, "clause argument must be a constant");
+      return error(VLoc, "clause argument must be a constant");
     LP->addClause(CV);
   }
 
@@ -6869,19 +7127,19 @@ bool LLParser::ParseLandingPad(Instruction *&Inst, PerFunctionState &PFS) {
   return false;
 }
 
-/// ParseFreeze
+/// parseFreeze
 ///   ::= 'freeze' Type Value
-bool LLParser::ParseFreeze(Instruction *&Inst, PerFunctionState &PFS) {
+bool LLParser::parseFreeze(Instruction *&Inst, PerFunctionState &PFS) {
   LocTy Loc;
   Value *Op;
-  if (ParseTypeAndValue(Op, Loc, PFS))
+  if (parseTypeAndValue(Op, Loc, PFS))
     return true;
 
   Inst = new FreezeInst(Op);
   return false;
 }
 
-/// ParseCall
+/// parseCall
 ///   ::= 'call' OptionalFastMathFlags OptionalCallingConv
 ///           OptionalAttrs Type Value ParameterList OptionalAttrs
 ///   ::= 'tail' 'call' OptionalFastMathFlags OptionalCallingConv
@@ -6890,7 +7148,7 @@ bool LLParser::ParseFreeze(Instruction *&Inst, PerFunctionState &PFS) {
 ///           OptionalAttrs Type Value ParameterList OptionalAttrs
 ///   ::= 'notail' 'call'  OptionalFastMathFlags OptionalCallingConv
 ///           OptionalAttrs Type Value ParameterList OptionalAttrs
-bool LLParser::ParseCall(Instruction *&Inst, PerFunctionState &PFS,
+bool LLParser::parseCall(Instruction *&Inst, PerFunctionState &PFS,
                          CallInst::TailCallKind TCK) {
   AttrBuilder RetAttrs, FnAttrs;
   std::vector<unsigned> FwdRefAttrGrps;
@@ -6905,20 +7163,20 @@ bool LLParser::ParseCall(Instruction *&Inst, PerFunctionState &PFS,
   LocTy CallLoc = Lex.getLoc();
 
   if (TCK != CallInst::TCK_None &&
-      ParseToken(lltok::kw_call,
+      parseToken(lltok::kw_call,
                  "expected 'tail call', 'musttail call', or 'notail call'"))
     return true;
 
   FastMathFlags FMF = EatFastMathFlagsIfPresent();
 
-  if (ParseOptionalCallingConv(CC) || ParseOptionalReturnAttrs(RetAttrs) ||
-      ParseOptionalProgramAddrSpace(CallAddrSpace) ||
-      ParseType(RetType, RetTypeLoc, true /*void allowed*/) ||
-      ParseValID(CalleeID) ||
-      ParseParameterList(ArgList, PFS, TCK == CallInst::TCK_MustTail,
+  if (parseOptionalCallingConv(CC) || parseOptionalReturnAttrs(RetAttrs) ||
+      parseOptionalProgramAddrSpace(CallAddrSpace) ||
+      parseType(RetType, RetTypeLoc, true /*void allowed*/) ||
+      parseValID(CalleeID) ||
+      parseParameterList(ArgList, PFS, TCK == CallInst::TCK_MustTail,
                          PFS.getFunction().isVarArg()) ||
-      ParseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false, BuiltinLoc) ||
-      ParseOptionalOperandBundles(BundleList, PFS))
+      parseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false, BuiltinLoc) ||
+      parseOptionalOperandBundles(BundleList, PFS))
     return true;
 
   // If RetType is a non-function pointer type, then this is the short syntax
@@ -6932,7 +7190,7 @@ bool LLParser::ParseCall(Instruction *&Inst, PerFunctionState &PFS,
       ParamTypes.push_back(ArgList[i].V->getType());
 
     if (!FunctionType::isValidReturnType(RetType))
-      return Error(RetTypeLoc, "Invalid result type for LLVM function");
+      return error(RetTypeLoc, "Invalid result type for LLVM function");
 
     Ty = FunctionType::get(RetType, ParamTypes, false);
   }
@@ -6941,7 +7199,7 @@ bool LLParser::ParseCall(Instruction *&Inst, PerFunctionState &PFS,
 
   // Look up the callee.
   Value *Callee;
-  if (ConvertValIDToValue(PointerType::get(Ty, CallAddrSpace), CalleeID, Callee,
+  if (convertValIDToValue(PointerType::get(Ty, CallAddrSpace), CalleeID, Callee,
                           &PFS, /*IsCall=*/true))
     return true;
 
@@ -6959,21 +7217,21 @@ bool LLParser::ParseCall(Instruction *&Inst, PerFunctionState &PFS,
     if (I != E) {
       ExpectedTy = *I++;
     } else if (!Ty->isVarArg()) {
-      return Error(ArgList[i].Loc, "too many arguments specified");
+      return error(ArgList[i].Loc, "too many arguments specified");
     }
 
     if (ExpectedTy && ExpectedTy != ArgList[i].V->getType())
-      return Error(ArgList[i].Loc, "argument is not of expected type '" +
-                   getTypeString(ExpectedTy) + "'");
+      return error(ArgList[i].Loc, "argument is not of expected type '" +
+                                       getTypeString(ExpectedTy) + "'");
     Args.push_back(ArgList[i].V);
     Attrs.push_back(ArgList[i].Attrs);
   }
 
   if (I != E)
-    return Error(CallLoc, "not enough parameters specified for call");
+    return error(CallLoc, "not enough parameters specified for call");
 
   if (FnAttrs.hasAlignmentAttr())
-    return Error(CallLoc, "call instructions may not have an alignment");
+    return error(CallLoc, "call instructions may not have an alignment");
 
   // Finish off the Attribute and check them
   AttributeList PAL =
@@ -6986,8 +7244,8 @@ bool LLParser::ParseCall(Instruction *&Inst, PerFunctionState &PFS,
   if (FMF.any()) {
     if (!isa<FPMathOperator>(CI)) {
       CI->deleteValue();
-      return Error(CallLoc, "fast-math-flags specified for call without "
-                   "floating-point scalar or vector return type");
+      return error(CallLoc, "fast-math-flags specified for call without "
+                            "floating-point scalar or vector return type");
     }
     CI->setFastMathFlags(FMF);
   }
@@ -7001,10 +7259,10 @@ bool LLParser::ParseCall(Instruction *&Inst, PerFunctionState &PFS,
 // Memory Instructions.
 //===----------------------------------------------------------------------===//
 
-/// ParseAlloc
+/// parseAlloc
 ///   ::= 'alloca' 'inalloca'? 'swifterror'? Type (',' TypeAndValue)?
 ///       (',' 'align' i32)? (',', 'addrspace(n))?
-int LLParser::ParseAlloc(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parseAlloc(Instruction *&Inst, PerFunctionState &PFS) {
   Value *Size = nullptr;
   LocTy SizeLoc, TyLoc, ASLoc;
   MaybeAlign Alignment;
@@ -7014,36 +7272,37 @@ int LLParser::ParseAlloc(Instruction *&Inst, PerFunctionState &PFS) {
   bool IsInAlloca = EatIfPresent(lltok::kw_inalloca);
   bool IsSwiftError = EatIfPresent(lltok::kw_swifterror);
 
-  if (ParseType(Ty, TyLoc)) return true;
+  if (parseType(Ty, TyLoc))
+    return true;
 
   if (Ty->isFunctionTy() || !PointerType::isValidElementType(Ty))
-    return Error(TyLoc, "invalid type for alloca");
+    return error(TyLoc, "invalid type for alloca");
 
   bool AteExtraComma = false;
   if (EatIfPresent(lltok::comma)) {
     if (Lex.getKind() == lltok::kw_align) {
-      if (ParseOptionalAlignment(Alignment))
+      if (parseOptionalAlignment(Alignment))
         return true;
-      if (ParseOptionalCommaAddrSpace(AddrSpace, ASLoc, AteExtraComma))
+      if (parseOptionalCommaAddrSpace(AddrSpace, ASLoc, AteExtraComma))
         return true;
     } else if (Lex.getKind() == lltok::kw_addrspace) {
       ASLoc = Lex.getLoc();
-      if (ParseOptionalAddrSpace(AddrSpace))
+      if (parseOptionalAddrSpace(AddrSpace))
         return true;
     } else if (Lex.getKind() == lltok::MetadataVar) {
       AteExtraComma = true;
     } else {
-      if (ParseTypeAndValue(Size, SizeLoc, PFS))
+      if (parseTypeAndValue(Size, SizeLoc, PFS))
         return true;
       if (EatIfPresent(lltok::comma)) {
         if (Lex.getKind() == lltok::kw_align) {
-          if (ParseOptionalAlignment(Alignment))
+          if (parseOptionalAlignment(Alignment))
             return true;
-          if (ParseOptionalCommaAddrSpace(AddrSpace, ASLoc, AteExtraComma))
+          if (parseOptionalCommaAddrSpace(AddrSpace, ASLoc, AteExtraComma))
             return true;
         } else if (Lex.getKind() == lltok::kw_addrspace) {
           ASLoc = Lex.getLoc();
-          if (ParseOptionalAddrSpace(AddrSpace))
+          if (parseOptionalAddrSpace(AddrSpace))
             return true;
         } else if (Lex.getKind() == lltok::MetadataVar) {
           AteExtraComma = true;
@@ -7053,11 +7312,11 @@ int LLParser::ParseAlloc(Instruction *&Inst, PerFunctionState &PFS) {
   }
 
   if (Size && !Size->getType()->isIntegerTy())
-    return Error(SizeLoc, "element count must have integer type");
+    return error(SizeLoc, "element count must have integer type");
 
   SmallPtrSet<Type *, 4> Visited;
   if (!Alignment && !Ty->isSized(&Visited))
-    return Error(TyLoc, "Cannot allocate unsized type");
+    return error(TyLoc, "Cannot allocate unsized type");
   if (!Alignment)
     Alignment = M->getDataLayout().getPrefTypeAlign(Ty);
   AllocaInst *AI = new AllocaInst(Ty, AddrSpace, Size, *Alignment);
@@ -7067,11 +7326,11 @@ int LLParser::ParseAlloc(Instruction *&Inst, PerFunctionState &PFS) {
   return AteExtraComma ? InstExtraComma : InstNormal;
 }
 
-/// ParseLoad
+/// parseLoad
 ///   ::= 'load' 'volatile'? TypeAndValue (',' 'align' i32)?
 ///   ::= 'load' 'atomic' 'volatile'? TypeAndValue
 ///       'singlethread'? AtomicOrdering (',' 'align' i32)?
-int LLParser::ParseLoad(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parseLoad(Instruction *&Inst, PerFunctionState &PFS) {
   Value *Val; LocTy Loc;
   MaybeAlign Alignment;
   bool AteExtraComma = false;
@@ -7092,39 +7351,39 @@ int LLParser::ParseLoad(Instruction *&Inst, PerFunctionState &PFS) {
 
   Type *Ty;
   LocTy ExplicitTypeLoc = Lex.getLoc();
-  if (ParseType(Ty) ||
-      ParseToken(lltok::comma, "expected comma after load's type") ||
-      ParseTypeAndValue(Val, Loc, PFS) ||
-      ParseScopeAndOrdering(isAtomic, SSID, Ordering) ||
-      ParseOptionalCommaAlign(Alignment, AteExtraComma))
+  if (parseType(Ty) ||
+      parseToken(lltok::comma, "expected comma after load's type") ||
+      parseTypeAndValue(Val, Loc, PFS) ||
+      parseScopeAndOrdering(isAtomic, SSID, Ordering) ||
+      parseOptionalCommaAlign(Alignment, AteExtraComma))
     return true;
 
   if (!Val->getType()->isPointerTy() || !Ty->isFirstClassType())
-    return Error(Loc, "load operand must be a pointer to a first class type");
+    return error(Loc, "load operand must be a pointer to a first class type");
   if (isAtomic && !Alignment)
-    return Error(Loc, "atomic load must have explicit non-zero alignment");
+    return error(Loc, "atomic load must have explicit non-zero alignment");
   if (Ordering == AtomicOrdering::Release ||
       Ordering == AtomicOrdering::AcquireRelease)
-    return Error(Loc, "atomic load cannot use Release ordering");
+    return error(Loc, "atomic load cannot use Release ordering");
 
   if (Ty != cast<PointerType>(Val->getType())->getElementType())
-    return Error(ExplicitTypeLoc,
+    return error(ExplicitTypeLoc,
                  "explicit pointee type doesn't match operand's pointee type");
   SmallPtrSet<Type *, 4> Visited;
   if (!Alignment && !Ty->isSized(&Visited))
-    return Error(ExplicitTypeLoc, "loading unsized types is not allowed");
+    return error(ExplicitTypeLoc, "loading unsized types is not allowed");
   if (!Alignment)
     Alignment = M->getDataLayout().getABITypeAlign(Ty);
   Inst = new LoadInst(Ty, Val, "", isVolatile, *Alignment, Ordering, SSID);
   return AteExtraComma ? InstExtraComma : InstNormal;
 }
 
-/// ParseStore
+/// parseStore
 
 ///   ::= 'store' 'volatile'? TypeAndValue ',' TypeAndValue (',' 'align' i32)?
 ///   ::= 'store' 'atomic' 'volatile'? TypeAndValue ',' TypeAndValue
 ///       'singlethread'? AtomicOrdering (',' 'align' i32)?
-int LLParser::ParseStore(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parseStore(Instruction *&Inst, PerFunctionState &PFS) {
   Value *Val, *Ptr; LocTy Loc, PtrLoc;
   MaybeAlign Alignment;
   bool AteExtraComma = false;
@@ -7143,27 +7402,27 @@ int LLParser::ParseStore(Instruction *&Inst, PerFunctionState &PFS) {
     Lex.Lex();
   }
 
-  if (ParseTypeAndValue(Val, Loc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after store operand") ||
-      ParseTypeAndValue(Ptr, PtrLoc, PFS) ||
-      ParseScopeAndOrdering(isAtomic, SSID, Ordering) ||
-      ParseOptionalCommaAlign(Alignment, AteExtraComma))
+  if (parseTypeAndValue(Val, Loc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after store operand") ||
+      parseTypeAndValue(Ptr, PtrLoc, PFS) ||
+      parseScopeAndOrdering(isAtomic, SSID, Ordering) ||
+      parseOptionalCommaAlign(Alignment, AteExtraComma))
     return true;
 
   if (!Ptr->getType()->isPointerTy())
-    return Error(PtrLoc, "store operand must be a pointer");
+    return error(PtrLoc, "store operand must be a pointer");
   if (!Val->getType()->isFirstClassType())
-    return Error(Loc, "store operand must be a first class value");
+    return error(Loc, "store operand must be a first class value");
   if (cast<PointerType>(Ptr->getType())->getElementType() != Val->getType())
-    return Error(Loc, "stored value and pointer type do not match");
+    return error(Loc, "stored value and pointer type do not match");
   if (isAtomic && !Alignment)
-    return Error(Loc, "atomic store must have explicit non-zero alignment");
+    return error(Loc, "atomic store must have explicit non-zero alignment");
   if (Ordering == AtomicOrdering::Acquire ||
       Ordering == AtomicOrdering::AcquireRelease)
-    return Error(Loc, "atomic store cannot use Acquire ordering");
+    return error(Loc, "atomic store cannot use Acquire ordering");
   SmallPtrSet<Type *, 4> Visited;
   if (!Alignment && !Val->getType()->isSized(&Visited))
-    return Error(Loc, "storing unsized types is not allowed");
+    return error(Loc, "storing unsized types is not allowed");
   if (!Alignment)
     Alignment = M->getDataLayout().getABITypeAlign(Val->getType());
 
@@ -7171,10 +7430,10 @@ int LLParser::ParseStore(Instruction *&Inst, PerFunctionState &PFS) {
   return AteExtraComma ? InstExtraComma : InstNormal;
 }
 
-/// ParseCmpXchg
+/// parseCmpXchg
 ///   ::= 'cmpxchg' 'weak'? 'volatile'? TypeAndValue ',' TypeAndValue ','
 ///       TypeAndValue 'singlethread'? AtomicOrdering AtomicOrdering
-int LLParser::ParseCmpXchg(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parseCmpXchg(Instruction *&Inst, PerFunctionState &PFS) {
   Value *Ptr, *Cmp, *New; LocTy PtrLoc, CmpLoc, NewLoc;
   bool AteExtraComma = false;
   AtomicOrdering SuccessOrdering = AtomicOrdering::NotAtomic;
@@ -7189,33 +7448,33 @@ int LLParser::ParseCmpXchg(Instruction *&Inst, PerFunctionState &PFS) {
   if (EatIfPresent(lltok::kw_volatile))
     isVolatile = true;
 
-  if (ParseTypeAndValue(Ptr, PtrLoc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after cmpxchg address") ||
-      ParseTypeAndValue(Cmp, CmpLoc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after cmpxchg cmp operand") ||
-      ParseTypeAndValue(New, NewLoc, PFS) ||
-      ParseScopeAndOrdering(true /*Always atomic*/, SSID, SuccessOrdering) ||
-      ParseOrdering(FailureOrdering))
+  if (parseTypeAndValue(Ptr, PtrLoc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after cmpxchg address") ||
+      parseTypeAndValue(Cmp, CmpLoc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after cmpxchg cmp operand") ||
+      parseTypeAndValue(New, NewLoc, PFS) ||
+      parseScopeAndOrdering(true /*Always atomic*/, SSID, SuccessOrdering) ||
+      parseOrdering(FailureOrdering))
     return true;
 
   if (SuccessOrdering == AtomicOrdering::Unordered ||
       FailureOrdering == AtomicOrdering::Unordered)
-    return TokError("cmpxchg cannot be unordered");
+    return tokError("cmpxchg cannot be unordered");
   if (isStrongerThan(FailureOrdering, SuccessOrdering))
-    return TokError("cmpxchg failure argument shall be no stronger than the "
+    return tokError("cmpxchg failure argument shall be no stronger than the "
                     "success argument");
   if (FailureOrdering == AtomicOrdering::Release ||
       FailureOrdering == AtomicOrdering::AcquireRelease)
-    return TokError(
+    return tokError(
         "cmpxchg failure ordering cannot include release semantics");
   if (!Ptr->getType()->isPointerTy())
-    return Error(PtrLoc, "cmpxchg operand must be a pointer");
+    return error(PtrLoc, "cmpxchg operand must be a pointer");
   if (cast<PointerType>(Ptr->getType())->getElementType() != Cmp->getType())
-    return Error(CmpLoc, "compare value and pointer type do not match");
+    return error(CmpLoc, "compare value and pointer type do not match");
   if (cast<PointerType>(Ptr->getType())->getElementType() != New->getType())
-    return Error(NewLoc, "new value and pointer type do not match");
+    return error(NewLoc, "new value and pointer type do not match");
   if (!New->getType()->isFirstClassType())
-    return Error(NewLoc, "cmpxchg operand must be a first class value");
+    return error(NewLoc, "cmpxchg operand must be a first class value");
 
   Align Alignment(
       PFS.getFunction().getParent()->getDataLayout().getTypeStoreSize(
@@ -7229,10 +7488,10 @@ int LLParser::ParseCmpXchg(Instruction *&Inst, PerFunctionState &PFS) {
   return AteExtraComma ? InstExtraComma : InstNormal;
 }
 
-/// ParseAtomicRMW
+/// parseAtomicRMW
 ///   ::= 'atomicrmw' 'volatile'? BinOp TypeAndValue ',' TypeAndValue
 ///       'singlethread'? AtomicOrdering
-int LLParser::ParseAtomicRMW(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parseAtomicRMW(Instruction *&Inst, PerFunctionState &PFS) {
   Value *Ptr, *Val; LocTy PtrLoc, ValLoc;
   bool AteExtraComma = false;
   AtomicOrdering Ordering = AtomicOrdering::NotAtomic;
@@ -7245,7 +7504,8 @@ int LLParser::ParseAtomicRMW(Instruction *&Inst, PerFunctionState &PFS) {
     isVolatile = true;
 
   switch (Lex.getKind()) {
-  default: return TokError("expected binary operation in atomicrmw");
+  default:
+    return tokError("expected binary operation in atomicrmw");
   case lltok::kw_xchg: Operation = AtomicRMWInst::Xchg; break;
   case lltok::kw_add: Operation = AtomicRMWInst::Add; break;
   case lltok::kw_sub: Operation = AtomicRMWInst::Sub; break;
@@ -7268,43 +7528,43 @@ int LLParser::ParseAtomicRMW(Instruction *&Inst, PerFunctionState &PFS) {
   }
   Lex.Lex();  // Eat the operation.
 
-  if (ParseTypeAndValue(Ptr, PtrLoc, PFS) ||
-      ParseToken(lltok::comma, "expected ',' after atomicrmw address") ||
-      ParseTypeAndValue(Val, ValLoc, PFS) ||
-      ParseScopeAndOrdering(true /*Always atomic*/, SSID, Ordering))
+  if (parseTypeAndValue(Ptr, PtrLoc, PFS) ||
+      parseToken(lltok::comma, "expected ',' after atomicrmw address") ||
+      parseTypeAndValue(Val, ValLoc, PFS) ||
+      parseScopeAndOrdering(true /*Always atomic*/, SSID, Ordering))
     return true;
 
   if (Ordering == AtomicOrdering::Unordered)
-    return TokError("atomicrmw cannot be unordered");
+    return tokError("atomicrmw cannot be unordered");
   if (!Ptr->getType()->isPointerTy())
-    return Error(PtrLoc, "atomicrmw operand must be a pointer");
+    return error(PtrLoc, "atomicrmw operand must be a pointer");
   if (cast<PointerType>(Ptr->getType())->getElementType() != Val->getType())
-    return Error(ValLoc, "atomicrmw value and pointer type do not match");
+    return error(ValLoc, "atomicrmw value and pointer type do not match");
 
   if (Operation == AtomicRMWInst::Xchg) {
     if (!Val->getType()->isIntegerTy() &&
         !Val->getType()->isFloatingPointTy()) {
-      return Error(ValLoc, "atomicrmw " +
-                   AtomicRMWInst::getOperationName(Operation) +
-                   " operand must be an integer or floating point type");
+      return error(ValLoc,
+                   "atomicrmw " + AtomicRMWInst::getOperationName(Operation) +
+                       " operand must be an integer or floating point type");
     }
   } else if (IsFP) {
     if (!Val->getType()->isFloatingPointTy()) {
-      return Error(ValLoc, "atomicrmw " +
-                   AtomicRMWInst::getOperationName(Operation) +
-                   " operand must be a floating point type");
+      return error(ValLoc, "atomicrmw " +
+                               AtomicRMWInst::getOperationName(Operation) +
+                               " operand must be a floating point type");
     }
   } else {
     if (!Val->getType()->isIntegerTy()) {
-      return Error(ValLoc, "atomicrmw " +
-                   AtomicRMWInst::getOperationName(Operation) +
-                   " operand must be an integer");
+      return error(ValLoc, "atomicrmw " +
+                               AtomicRMWInst::getOperationName(Operation) +
+                               " operand must be an integer");
     }
   }
 
   unsigned Size = Val->getType()->getPrimitiveSizeInBits();
   if (Size < 8 || (Size & (Size - 1)))
-    return Error(ValLoc, "atomicrmw operand must be power-of-two byte-sized"
+    return error(ValLoc, "atomicrmw operand must be power-of-two byte-sized"
                          " integer");
   Align Alignment(
       PFS.getFunction().getParent()->getDataLayout().getTypeStoreSize(
@@ -7316,26 +7576,26 @@ int LLParser::ParseAtomicRMW(Instruction *&Inst, PerFunctionState &PFS) {
   return AteExtraComma ? InstExtraComma : InstNormal;
 }
 
-/// ParseFence
+/// parseFence
 ///   ::= 'fence' 'singlethread'? AtomicOrdering
-int LLParser::ParseFence(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parseFence(Instruction *&Inst, PerFunctionState &PFS) {
   AtomicOrdering Ordering = AtomicOrdering::NotAtomic;
   SyncScope::ID SSID = SyncScope::System;
-  if (ParseScopeAndOrdering(true /*Always atomic*/, SSID, Ordering))
+  if (parseScopeAndOrdering(true /*Always atomic*/, SSID, Ordering))
     return true;
 
   if (Ordering == AtomicOrdering::Unordered)
-    return TokError("fence cannot be unordered");
+    return tokError("fence cannot be unordered");
   if (Ordering == AtomicOrdering::Monotonic)
-    return TokError("fence cannot be monotonic");
+    return tokError("fence cannot be monotonic");
 
   Inst = new FenceInst(Context, Ordering, SSID);
   return InstNormal;
 }
 
-/// ParseGetElementPtr
+/// parseGetElementPtr
 ///   ::= 'getelementptr' 'inbounds'? TypeAndValue (',' TypeAndValue)*
-int LLParser::ParseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS) {
   Value *Ptr = nullptr;
   Value *Val = nullptr;
   LocTy Loc, EltLoc;
@@ -7344,18 +7604,18 @@ int LLParser::ParseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS) {
 
   Type *Ty = nullptr;
   LocTy ExplicitTypeLoc = Lex.getLoc();
-  if (ParseType(Ty) ||
-      ParseToken(lltok::comma, "expected comma after getelementptr's type") ||
-      ParseTypeAndValue(Ptr, Loc, PFS))
+  if (parseType(Ty) ||
+      parseToken(lltok::comma, "expected comma after getelementptr's type") ||
+      parseTypeAndValue(Ptr, Loc, PFS))
     return true;
 
   Type *BaseType = Ptr->getType();
   PointerType *BasePointerType = dyn_cast<PointerType>(BaseType->getScalarType());
   if (!BasePointerType)
-    return Error(Loc, "base of getelementptr must be a pointer");
+    return error(Loc, "base of getelementptr must be a pointer");
 
   if (Ty != BasePointerType->getElementType())
-    return Error(ExplicitTypeLoc,
+    return error(ExplicitTypeLoc,
                  "explicit pointee type doesn't match operand's pointee type");
 
   SmallVector<Value*, 16> Indices;
@@ -7364,22 +7624,24 @@ int LLParser::ParseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS) {
   // All vector parameters should have the same vector width.
   ElementCount GEPWidth = BaseType->isVectorTy()
                               ? cast<VectorType>(BaseType)->getElementCount()
-                              : ElementCount(0, false);
+                              : ElementCount::getFixed(0);
 
   while (EatIfPresent(lltok::comma)) {
     if (Lex.getKind() == lltok::MetadataVar) {
       AteExtraComma = true;
       break;
     }
-    if (ParseTypeAndValue(Val, EltLoc, PFS)) return true;
+    if (parseTypeAndValue(Val, EltLoc, PFS))
+      return true;
     if (!Val->getType()->isIntOrIntVectorTy())
-      return Error(EltLoc, "getelementptr index must be an integer");
+      return error(EltLoc, "getelementptr index must be an integer");
 
     if (auto *ValVTy = dyn_cast<VectorType>(Val->getType())) {
       ElementCount ValNumEl = ValVTy->getElementCount();
-      if (GEPWidth != ElementCount(0, false) && GEPWidth != ValNumEl)
-        return Error(EltLoc,
-          "getelementptr vector index has a wrong number of elements");
+      if (GEPWidth != ElementCount::getFixed(0) && GEPWidth != ValNumEl)
+        return error(
+            EltLoc,
+            "getelementptr vector index has a wrong number of elements");
       GEPWidth = ValNumEl;
     }
     Indices.push_back(Val);
@@ -7387,55 +7649,55 @@ int LLParser::ParseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS) {
 
   SmallPtrSet<Type*, 4> Visited;
   if (!Indices.empty() && !Ty->isSized(&Visited))
-    return Error(Loc, "base element of getelementptr must be sized");
+    return error(Loc, "base element of getelementptr must be sized");
 
   if (!GetElementPtrInst::getIndexedType(Ty, Indices))
-    return Error(Loc, "invalid getelementptr indices");
+    return error(Loc, "invalid getelementptr indices");
   Inst = GetElementPtrInst::Create(Ty, Ptr, Indices);
   if (InBounds)
     cast<GetElementPtrInst>(Inst)->setIsInBounds(true);
   return AteExtraComma ? InstExtraComma : InstNormal;
 }
 
-/// ParseExtractValue
+/// parseExtractValue
 ///   ::= 'extractvalue' TypeAndValue (',' uint32)+
-int LLParser::ParseExtractValue(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parseExtractValue(Instruction *&Inst, PerFunctionState &PFS) {
   Value *Val; LocTy Loc;
   SmallVector<unsigned, 4> Indices;
   bool AteExtraComma;
-  if (ParseTypeAndValue(Val, Loc, PFS) ||
-      ParseIndexList(Indices, AteExtraComma))
+  if (parseTypeAndValue(Val, Loc, PFS) ||
+      parseIndexList(Indices, AteExtraComma))
     return true;
 
   if (!Val->getType()->isAggregateType())
-    return Error(Loc, "extractvalue operand must be aggregate type");
+    return error(Loc, "extractvalue operand must be aggregate type");
 
   if (!ExtractValueInst::getIndexedType(Val->getType(), Indices))
-    return Error(Loc, "invalid indices for extractvalue");
+    return error(Loc, "invalid indices for extractvalue");
   Inst = ExtractValueInst::Create(Val, Indices);
   return AteExtraComma ? InstExtraComma : InstNormal;
 }
 
-/// ParseInsertValue
+/// parseInsertValue
 ///   ::= 'insertvalue' TypeAndValue ',' TypeAndValue (',' uint32)+
-int LLParser::ParseInsertValue(Instruction *&Inst, PerFunctionState &PFS) {
+int LLParser::parseInsertValue(Instruction *&Inst, PerFunctionState &PFS) {
   Value *Val0, *Val1; LocTy Loc0, Loc1;
   SmallVector<unsigned, 4> Indices;
   bool AteExtraComma;
-  if (ParseTypeAndValue(Val0, Loc0, PFS) ||
-      ParseToken(lltok::comma, "expected comma after insertvalue operand") ||
-      ParseTypeAndValue(Val1, Loc1, PFS) ||
-      ParseIndexList(Indices, AteExtraComma))
+  if (parseTypeAndValue(Val0, Loc0, PFS) ||
+      parseToken(lltok::comma, "expected comma after insertvalue operand") ||
+      parseTypeAndValue(Val1, Loc1, PFS) ||
+      parseIndexList(Indices, AteExtraComma))
     return true;
 
   if (!Val0->getType()->isAggregateType())
-    return Error(Loc0, "insertvalue operand must be aggregate type");
+    return error(Loc0, "insertvalue operand must be aggregate type");
 
   Type *IndexedType = ExtractValueInst::getIndexedType(Val0->getType(), Indices);
   if (!IndexedType)
-    return Error(Loc0, "invalid indices for insertvalue");
+    return error(Loc0, "invalid indices for insertvalue");
   if (IndexedType != Val1->getType())
-    return Error(Loc1, "insertvalue operand and field disagree in type: '" +
+    return error(Loc1, "insertvalue operand and field disagree in type: '" +
                            getTypeString(Val1->getType()) + "' instead of '" +
                            getTypeString(IndexedType) + "'");
   Inst = InsertValueInst::Create(Val0, Val1, Indices);
@@ -7446,12 +7708,12 @@ int LLParser::ParseInsertValue(Instruction *&Inst, PerFunctionState &PFS) {
 // Embedded metadata.
 //===----------------------------------------------------------------------===//
 
-/// ParseMDNodeVector
+/// parseMDNodeVector
 ///   ::= { Element (',' Element)* }
 /// Element
 ///   ::= 'null' | TypeAndValue
-bool LLParser::ParseMDNodeVector(SmallVectorImpl<Metadata *> &Elts) {
-  if (ParseToken(lltok::lbrace, "expected '{' here"))
+bool LLParser::parseMDNodeVector(SmallVectorImpl<Metadata *> &Elts) {
+  if (parseToken(lltok::lbrace, "expected '{' here"))
     return true;
 
   // Check for an empty list.
@@ -7466,12 +7728,12 @@ bool LLParser::ParseMDNodeVector(SmallVectorImpl<Metadata *> &Elts) {
     }
 
     Metadata *MD;
-    if (ParseMetadata(MD, nullptr))
+    if (parseMetadata(MD, nullptr))
       return true;
     Elts.push_back(MD);
   } while (EatIfPresent(lltok::comma));
 
-  return ParseToken(lltok::rbrace, "expected end of metadata node");
+  return parseToken(lltok::rbrace, "expected end of metadata node");
 }
 
 //===----------------------------------------------------------------------===//
@@ -7480,7 +7742,7 @@ bool LLParser::ParseMDNodeVector(SmallVectorImpl<Metadata *> &Elts) {
 bool LLParser::sortUseListOrder(Value *V, ArrayRef<unsigned> Indexes,
                                 SMLoc Loc) {
   if (V->use_empty())
-    return Error(Loc, "value has no uses");
+    return error(Loc, "value has no uses");
 
   unsigned NumUses = 0;
   SmallDenseMap<const Use *, unsigned, 16> Order;
@@ -7490,9 +7752,9 @@ bool LLParser::sortUseListOrder(Value *V, ArrayRef<unsigned> Indexes,
     Order[&U] = Indexes[NumUses - 1];
   }
   if (NumUses < 2)
-    return Error(Loc, "value only has one use");
+    return error(Loc, "value only has one use");
   if (Order.size() != Indexes.size() || NumUses > Indexes.size())
-    return Error(Loc,
+    return error(Loc,
                  "wrong number of indexes, expected " + Twine(V->getNumUses()));
 
   V->sortUseList([&](const Use &L, const Use &R) {
@@ -7501,11 +7763,11 @@ bool LLParser::sortUseListOrder(Value *V, ArrayRef<unsigned> Indexes,
   return false;
 }
 
-/// ParseUseListOrderIndexes
+/// parseUseListOrderIndexes
 ///   ::= '{' uint32 (',' uint32)+ '}'
-bool LLParser::ParseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes) {
+bool LLParser::parseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes) {
   SMLoc Loc = Lex.getLoc();
-  if (ParseToken(lltok::lbrace, "expected '{' here"))
+  if (parseToken(lltok::lbrace, "expected '{' here"))
     return true;
   if (Lex.getKind() == lltok::rbrace)
     return Lex.Error("expected non-empty list of uselistorder indexes");
@@ -7519,7 +7781,7 @@ bool LLParser::ParseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes) {
   assert(Indexes.empty() && "Expected empty order vector");
   do {
     unsigned Index;
-    if (ParseUInt32(Index))
+    if (parseUInt32(Index))
       return true;
 
     // Update consistency checks.
@@ -7530,50 +7792,51 @@ bool LLParser::ParseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes) {
     Indexes.push_back(Index);
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rbrace, "expected '}' here"))
+  if (parseToken(lltok::rbrace, "expected '}' here"))
     return true;
 
   if (Indexes.size() < 2)
-    return Error(Loc, "expected >= 2 uselistorder indexes");
+    return error(Loc, "expected >= 2 uselistorder indexes");
   if (Offset != 0 || Max >= Indexes.size())
-    return Error(Loc, "expected distinct uselistorder indexes in range [0, size)");
+    return error(Loc,
+                 "expected distinct uselistorder indexes in range [0, size)");
   if (IsOrdered)
-    return Error(Loc, "expected uselistorder indexes to change the order");
+    return error(Loc, "expected uselistorder indexes to change the order");
 
   return false;
 }
 
-/// ParseUseListOrder
+/// parseUseListOrder
 ///   ::= 'uselistorder' Type Value ',' UseListOrderIndexes
-bool LLParser::ParseUseListOrder(PerFunctionState *PFS) {
+bool LLParser::parseUseListOrder(PerFunctionState *PFS) {
   SMLoc Loc = Lex.getLoc();
-  if (ParseToken(lltok::kw_uselistorder, "expected uselistorder directive"))
+  if (parseToken(lltok::kw_uselistorder, "expected uselistorder directive"))
     return true;
 
   Value *V;
   SmallVector<unsigned, 16> Indexes;
-  if (ParseTypeAndValue(V, PFS) ||
-      ParseToken(lltok::comma, "expected comma in uselistorder directive") ||
-      ParseUseListOrderIndexes(Indexes))
+  if (parseTypeAndValue(V, PFS) ||
+      parseToken(lltok::comma, "expected comma in uselistorder directive") ||
+      parseUseListOrderIndexes(Indexes))
     return true;
 
   return sortUseListOrder(V, Indexes, Loc);
 }
 
-/// ParseUseListOrderBB
+/// parseUseListOrderBB
 ///   ::= 'uselistorder_bb' @foo ',' %bar ',' UseListOrderIndexes
-bool LLParser::ParseUseListOrderBB() {
+bool LLParser::parseUseListOrderBB() {
   assert(Lex.getKind() == lltok::kw_uselistorder_bb);
   SMLoc Loc = Lex.getLoc();
   Lex.Lex();
 
   ValID Fn, Label;
   SmallVector<unsigned, 16> Indexes;
-  if (ParseValID(Fn) ||
-      ParseToken(lltok::comma, "expected comma in uselistorder_bb directive") ||
-      ParseValID(Label) ||
-      ParseToken(lltok::comma, "expected comma in uselistorder_bb directive") ||
-      ParseUseListOrderIndexes(Indexes))
+  if (parseValID(Fn) ||
+      parseToken(lltok::comma, "expected comma in uselistorder_bb directive") ||
+      parseValID(Label) ||
+      parseToken(lltok::comma, "expected comma in uselistorder_bb directive") ||
+      parseUseListOrderIndexes(Indexes))
     return true;
 
   // Check the function.
@@ -7583,25 +7846,26 @@ bool LLParser::ParseUseListOrderBB() {
   else if (Fn.Kind == ValID::t_GlobalID)
     GV = Fn.UIntVal < NumberedVals.size() ? NumberedVals[Fn.UIntVal] : nullptr;
   else
-    return Error(Fn.Loc, "expected function name in uselistorder_bb");
+    return error(Fn.Loc, "expected function name in uselistorder_bb");
   if (!GV)
-    return Error(Fn.Loc, "invalid function forward reference in uselistorder_bb");
+    return error(Fn.Loc,
+                 "invalid function forward reference in uselistorder_bb");
   auto *F = dyn_cast<Function>(GV);
   if (!F)
-    return Error(Fn.Loc, "expected function name in uselistorder_bb");
+    return error(Fn.Loc, "expected function name in uselistorder_bb");
   if (F->isDeclaration())
-    return Error(Fn.Loc, "invalid declaration in uselistorder_bb");
+    return error(Fn.Loc, "invalid declaration in uselistorder_bb");
 
   // Check the basic block.
   if (Label.Kind == ValID::t_LocalID)
-    return Error(Label.Loc, "invalid numeric label in uselistorder_bb");
+    return error(Label.Loc, "invalid numeric label in uselistorder_bb");
   if (Label.Kind != ValID::t_LocalName)
-    return Error(Label.Loc, "expected basic block name in uselistorder_bb");
+    return error(Label.Loc, "expected basic block name in uselistorder_bb");
   Value *V = F->getValueSymbolTable()->lookup(Label.StrVal);
   if (!V)
-    return Error(Label.Loc, "invalid basic block in uselistorder_bb");
+    return error(Label.Loc, "invalid basic block in uselistorder_bb");
   if (!isa<BasicBlock>(V))
-    return Error(Label.Loc, "expected basic block in uselistorder_bb");
+    return error(Label.Loc, "expected basic block in uselistorder_bb");
 
   return sortUseListOrder(V, Indexes, Loc);
 }
@@ -7609,32 +7873,32 @@ bool LLParser::ParseUseListOrderBB() {
 /// ModuleEntry
 ///   ::= 'module' ':' '(' 'path' ':' STRINGCONSTANT ',' 'hash' ':' Hash ')'
 /// Hash ::= '(' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ')'
-bool LLParser::ParseModuleEntry(unsigned ID) {
+bool LLParser::parseModuleEntry(unsigned ID) {
   assert(Lex.getKind() == lltok::kw_module);
   Lex.Lex();
 
   std::string Path;
-  if (ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseToken(lltok::kw_path, "expected 'path' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseStringConstant(Path) ||
-      ParseToken(lltok::comma, "expected ',' here") ||
-      ParseToken(lltok::kw_hash, "expected 'hash' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here") ||
+      parseToken(lltok::kw_path, "expected 'path' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseStringConstant(Path) ||
+      parseToken(lltok::comma, "expected ',' here") ||
+      parseToken(lltok::kw_hash, "expected 'hash' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   ModuleHash Hash;
-  if (ParseUInt32(Hash[0]) || ParseToken(lltok::comma, "expected ',' here") ||
-      ParseUInt32(Hash[1]) || ParseToken(lltok::comma, "expected ',' here") ||
-      ParseUInt32(Hash[2]) || ParseToken(lltok::comma, "expected ',' here") ||
-      ParseUInt32(Hash[3]) || ParseToken(lltok::comma, "expected ',' here") ||
-      ParseUInt32(Hash[4]))
+  if (parseUInt32(Hash[0]) || parseToken(lltok::comma, "expected ',' here") ||
+      parseUInt32(Hash[1]) || parseToken(lltok::comma, "expected ',' here") ||
+      parseUInt32(Hash[2]) || parseToken(lltok::comma, "expected ',' here") ||
+      parseUInt32(Hash[3]) || parseToken(lltok::comma, "expected ',' here") ||
+      parseUInt32(Hash[4]))
     return true;
 
-  if (ParseToken(lltok::rparen, "expected ')' here") ||
-      ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here") ||
+      parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   auto ModuleEntry = Index->addModule(Path, ID, Hash);
@@ -7645,21 +7909,21 @@ bool LLParser::ParseModuleEntry(unsigned ID) {
 
 /// TypeIdEntry
 ///   ::= 'typeid' ':' '(' 'name' ':' STRINGCONSTANT ',' TypeIdSummary ')'
-bool LLParser::ParseTypeIdEntry(unsigned ID) {
+bool LLParser::parseTypeIdEntry(unsigned ID) {
   assert(Lex.getKind() == lltok::kw_typeid);
   Lex.Lex();
 
   std::string Name;
-  if (ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseToken(lltok::kw_name, "expected 'name' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseStringConstant(Name))
+  if (parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here") ||
+      parseToken(lltok::kw_name, "expected 'name' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseStringConstant(Name))
     return true;
 
   TypeIdSummary &TIS = Index->getOrInsertTypeIdSummary(Name);
-  if (ParseToken(lltok::comma, "expected ',' here") ||
-      ParseTypeIdSummary(TIS) || ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::comma, "expected ',' here") ||
+      parseTypeIdSummary(TIS) || parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   // Check if this ID was forward referenced, and if so, update the
@@ -7679,20 +7943,20 @@ bool LLParser::ParseTypeIdEntry(unsigned ID) {
 
 /// TypeIdSummary
 ///   ::= 'summary' ':' '(' TypeTestResolution [',' OptionalWpdResolutions]? ')'
-bool LLParser::ParseTypeIdSummary(TypeIdSummary &TIS) {
-  if (ParseToken(lltok::kw_summary, "expected 'summary' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseTypeTestResolution(TIS.TTRes))
+bool LLParser::parseTypeIdSummary(TypeIdSummary &TIS) {
+  if (parseToken(lltok::kw_summary, "expected 'summary' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here") ||
+      parseTypeTestResolution(TIS.TTRes))
     return true;
 
   if (EatIfPresent(lltok::comma)) {
     // Expect optional wpdResolutions field
-    if (ParseOptionalWpdResolutions(TIS.WPDRes))
+    if (parseOptionalWpdResolutions(TIS.WPDRes))
       return true;
   }
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -7705,40 +7969,40 @@ static ValueInfo EmptyVI =
 ///   ::= 'typeidCompatibleVTable' ':' '(' 'name' ':' STRINGCONSTANT ','
 ///   TypeIdCompatibleVtableInfo
 ///   ')'
-bool LLParser::ParseTypeIdCompatibleVtableEntry(unsigned ID) {
+bool LLParser::parseTypeIdCompatibleVtableEntry(unsigned ID) {
   assert(Lex.getKind() == lltok::kw_typeidCompatibleVTable);
   Lex.Lex();
 
   std::string Name;
-  if (ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseToken(lltok::kw_name, "expected 'name' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseStringConstant(Name))
+  if (parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here") ||
+      parseToken(lltok::kw_name, "expected 'name' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseStringConstant(Name))
     return true;
 
   TypeIdCompatibleVtableInfo &TI =
       Index->getOrInsertTypeIdCompatibleVtableSummary(Name);
-  if (ParseToken(lltok::comma, "expected ',' here") ||
-      ParseToken(lltok::kw_summary, "expected 'summary' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::comma, "expected ',' here") ||
+      parseToken(lltok::kw_summary, "expected 'summary' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   IdToIndexMapType IdToIndexMap;
-  // Parse each call edge
+  // parse each call edge
   do {
     uint64_t Offset;
-    if (ParseToken(lltok::lparen, "expected '(' here") ||
-        ParseToken(lltok::kw_offset, "expected 'offset' here") ||
-        ParseToken(lltok::colon, "expected ':' here") || ParseUInt64(Offset) ||
-        ParseToken(lltok::comma, "expected ',' here"))
+    if (parseToken(lltok::lparen, "expected '(' here") ||
+        parseToken(lltok::kw_offset, "expected 'offset' here") ||
+        parseToken(lltok::colon, "expected ':' here") || parseUInt64(Offset) ||
+        parseToken(lltok::comma, "expected ',' here"))
       return true;
 
     LocTy Loc = Lex.getLoc();
     unsigned GVId;
     ValueInfo VI;
-    if (ParseGVReference(VI, GVId))
+    if (parseGVReference(VI, GVId))
       return true;
 
     // Keep track of the TypeIdCompatibleVtableInfo array index needing a
@@ -7748,25 +8012,23 @@ bool LLParser::ParseTypeIdCompatibleVtableEntry(unsigned ID) {
       IdToIndexMap[GVId].push_back(std::make_pair(TI.size(), Loc));
     TI.push_back({Offset, VI});
 
-    if (ParseToken(lltok::rparen, "expected ')' in call"))
+    if (parseToken(lltok::rparen, "expected ')' in call"))
       return true;
   } while (EatIfPresent(lltok::comma));
 
   // Now that the TI vector is finalized, it is safe to save the locations
   // of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Infos = ForwardRefValueInfos[I.first];
     for (auto P : I.second) {
       assert(TI[P.first].VTableVI == EmptyVI &&
              "Forward referenced ValueInfo expected to be empty");
-      auto FwdRef = ForwardRefValueInfos.insert(std::make_pair(
-          I.first, std::vector<std::pair<ValueInfo *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&TI[P.first].VTableVI, P.second));
+      Infos.emplace_back(&TI[P.first].VTableVI, P.second);
     }
   }
 
-  if (ParseToken(lltok::rparen, "expected ')' here") ||
-      ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here") ||
+      parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   // Check if this ID was forward referenced, and if so, update the
@@ -7790,12 +8052,12 @@ bool LLParser::ParseTypeIdCompatibleVtableEntry(unsigned ID) {
 ///         'sizeM1BitWidth' ':' SizeM1BitWidth [',' 'alignLog2' ':' UInt64]?
 ///         [',' 'sizeM1' ':' UInt64]? [',' 'bitMask' ':' UInt8]?
 ///         [',' 'inlinesBits' ':' UInt64]? ')'
-bool LLParser::ParseTypeTestResolution(TypeTestResolution &TTRes) {
-  if (ParseToken(lltok::kw_typeTestRes, "expected 'typeTestRes' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseToken(lltok::kw_kind, "expected 'kind' here") ||
-      ParseToken(lltok::colon, "expected ':' here"))
+bool LLParser::parseTypeTestResolution(TypeTestResolution &TTRes) {
+  if (parseToken(lltok::kw_typeTestRes, "expected 'typeTestRes' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here") ||
+      parseToken(lltok::kw_kind, "expected 'kind' here") ||
+      parseToken(lltok::colon, "expected ':' here"))
     return true;
 
   switch (Lex.getKind()) {
@@ -7818,34 +8080,34 @@ bool LLParser::ParseTypeTestResolution(TypeTestResolution &TTRes) {
     TTRes.TheKind = TypeTestResolution::AllOnes;
     break;
   default:
-    return Error(Lex.getLoc(), "unexpected TypeTestResolution kind");
+    return error(Lex.getLoc(), "unexpected TypeTestResolution kind");
   }
   Lex.Lex();
 
-  if (ParseToken(lltok::comma, "expected ',' here") ||
-      ParseToken(lltok::kw_sizeM1BitWidth, "expected 'sizeM1BitWidth' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseUInt32(TTRes.SizeM1BitWidth))
+  if (parseToken(lltok::comma, "expected ',' here") ||
+      parseToken(lltok::kw_sizeM1BitWidth, "expected 'sizeM1BitWidth' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseUInt32(TTRes.SizeM1BitWidth))
     return true;
 
-  // Parse optional fields
+  // parse optional fields
   while (EatIfPresent(lltok::comma)) {
     switch (Lex.getKind()) {
     case lltok::kw_alignLog2:
       Lex.Lex();
-      if (ParseToken(lltok::colon, "expected ':'") ||
-          ParseUInt64(TTRes.AlignLog2))
+      if (parseToken(lltok::colon, "expected ':'") ||
+          parseUInt64(TTRes.AlignLog2))
         return true;
       break;
     case lltok::kw_sizeM1:
       Lex.Lex();
-      if (ParseToken(lltok::colon, "expected ':'") || ParseUInt64(TTRes.SizeM1))
+      if (parseToken(lltok::colon, "expected ':'") || parseUInt64(TTRes.SizeM1))
         return true;
       break;
     case lltok::kw_bitMask: {
       unsigned Val;
       Lex.Lex();
-      if (ParseToken(lltok::colon, "expected ':'") || ParseUInt32(Val))
+      if (parseToken(lltok::colon, "expected ':'") || parseUInt32(Val))
         return true;
       assert(Val <= 0xff);
       TTRes.BitMask = (uint8_t)Val;
@@ -7853,16 +8115,16 @@ bool LLParser::ParseTypeTestResolution(TypeTestResolution &TTRes) {
     }
     case lltok::kw_inlineBits:
       Lex.Lex();
-      if (ParseToken(lltok::colon, "expected ':'") ||
-          ParseUInt64(TTRes.InlineBits))
+      if (parseToken(lltok::colon, "expected ':'") ||
+          parseUInt64(TTRes.InlineBits))
         return true;
       break;
     default:
-      return Error(Lex.getLoc(), "expected optional TypeTestResolution field");
+      return error(Lex.getLoc(), "expected optional TypeTestResolution field");
     }
   }
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -7871,26 +8133,26 @@ bool LLParser::ParseTypeTestResolution(TypeTestResolution &TTRes) {
 /// OptionalWpdResolutions
 ///   ::= 'wpsResolutions' ':' '(' WpdResolution [',' WpdResolution]* ')'
 /// WpdResolution ::= '(' 'offset' ':' UInt64 ',' WpdRes ')'
-bool LLParser::ParseOptionalWpdResolutions(
+bool LLParser::parseOptionalWpdResolutions(
     std::map<uint64_t, WholeProgramDevirtResolution> &WPDResMap) {
-  if (ParseToken(lltok::kw_wpdResolutions, "expected 'wpdResolutions' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::kw_wpdResolutions, "expected 'wpdResolutions' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   do {
     uint64_t Offset;
     WholeProgramDevirtResolution WPDRes;
-    if (ParseToken(lltok::lparen, "expected '(' here") ||
-        ParseToken(lltok::kw_offset, "expected 'offset' here") ||
-        ParseToken(lltok::colon, "expected ':' here") || ParseUInt64(Offset) ||
-        ParseToken(lltok::comma, "expected ',' here") || ParseWpdRes(WPDRes) ||
-        ParseToken(lltok::rparen, "expected ')' here"))
+    if (parseToken(lltok::lparen, "expected '(' here") ||
+        parseToken(lltok::kw_offset, "expected 'offset' here") ||
+        parseToken(lltok::colon, "expected ':' here") || parseUInt64(Offset) ||
+        parseToken(lltok::comma, "expected ',' here") || parseWpdRes(WPDRes) ||
+        parseToken(lltok::rparen, "expected ')' here"))
       return true;
     WPDResMap[Offset] = WPDRes;
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -7904,12 +8166,12 @@ bool LLParser::ParseOptionalWpdResolutions(
 ///         [',' OptionalResByArg]? ')'
 ///   ::= 'wpdRes' ':' '(' 'kind' ':' 'branchFunnel'
 ///         [',' OptionalResByArg]? ')'
-bool LLParser::ParseWpdRes(WholeProgramDevirtResolution &WPDRes) {
-  if (ParseToken(lltok::kw_wpdRes, "expected 'wpdRes' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseToken(lltok::kw_kind, "expected 'kind' here") ||
-      ParseToken(lltok::colon, "expected ':' here"))
+bool LLParser::parseWpdRes(WholeProgramDevirtResolution &WPDRes) {
+  if (parseToken(lltok::kw_wpdRes, "expected 'wpdRes' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here") ||
+      parseToken(lltok::kw_kind, "expected 'kind' here") ||
+      parseToken(lltok::colon, "expected ':' here"))
     return true;
 
   switch (Lex.getKind()) {
@@ -7923,30 +8185,30 @@ bool LLParser::ParseWpdRes(WholeProgramDevirtResolution &WPDRes) {
     WPDRes.TheKind = WholeProgramDevirtResolution::BranchFunnel;
     break;
   default:
-    return Error(Lex.getLoc(), "unexpected WholeProgramDevirtResolution kind");
+    return error(Lex.getLoc(), "unexpected WholeProgramDevirtResolution kind");
   }
   Lex.Lex();
 
-  // Parse optional fields
+  // parse optional fields
   while (EatIfPresent(lltok::comma)) {
     switch (Lex.getKind()) {
     case lltok::kw_singleImplName:
       Lex.Lex();
-      if (ParseToken(lltok::colon, "expected ':' here") ||
-          ParseStringConstant(WPDRes.SingleImplName))
+      if (parseToken(lltok::colon, "expected ':' here") ||
+          parseStringConstant(WPDRes.SingleImplName))
         return true;
       break;
     case lltok::kw_resByArg:
-      if (ParseOptionalResByArg(WPDRes.ResByArg))
+      if (parseOptionalResByArg(WPDRes.ResByArg))
         return true;
       break;
     default:
-      return Error(Lex.getLoc(),
+      return error(Lex.getLoc(),
                    "expected optional WholeProgramDevirtResolution field");
     }
   }
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -7959,22 +8221,22 @@ bool LLParser::ParseWpdRes(WholeProgramDevirtResolution &WPDRes) {
 ///                  'virtualConstProp' )
 ///                [',' 'info' ':' UInt64]? [',' 'byte' ':' UInt32]?
 ///                [',' 'bit' ':' UInt32]? ')'
-bool LLParser::ParseOptionalResByArg(
+bool LLParser::parseOptionalResByArg(
     std::map<std::vector<uint64_t>, WholeProgramDevirtResolution::ByArg>
         &ResByArg) {
-  if (ParseToken(lltok::kw_resByArg, "expected 'resByArg' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::kw_resByArg, "expected 'resByArg' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   do {
     std::vector<uint64_t> Args;
-    if (ParseArgs(Args) || ParseToken(lltok::comma, "expected ',' here") ||
-        ParseToken(lltok::kw_byArg, "expected 'byArg here") ||
-        ParseToken(lltok::colon, "expected ':' here") ||
-        ParseToken(lltok::lparen, "expected '(' here") ||
-        ParseToken(lltok::kw_kind, "expected 'kind' here") ||
-        ParseToken(lltok::colon, "expected ':' here"))
+    if (parseArgs(Args) || parseToken(lltok::comma, "expected ',' here") ||
+        parseToken(lltok::kw_byArg, "expected 'byArg here") ||
+        parseToken(lltok::colon, "expected ':' here") ||
+        parseToken(lltok::lparen, "expected '(' here") ||
+        parseToken(lltok::kw_kind, "expected 'kind' here") ||
+        parseToken(lltok::colon, "expected ':' here"))
       return true;
 
     WholeProgramDevirtResolution::ByArg ByArg;
@@ -7992,45 +8254,45 @@ bool LLParser::ParseOptionalResByArg(
       ByArg.TheKind = WholeProgramDevirtResolution::ByArg::VirtualConstProp;
       break;
     default:
-      return Error(Lex.getLoc(),
+      return error(Lex.getLoc(),
                    "unexpected WholeProgramDevirtResolution::ByArg kind");
     }
     Lex.Lex();
 
-    // Parse optional fields
+    // parse optional fields
     while (EatIfPresent(lltok::comma)) {
       switch (Lex.getKind()) {
       case lltok::kw_info:
         Lex.Lex();
-        if (ParseToken(lltok::colon, "expected ':' here") ||
-            ParseUInt64(ByArg.Info))
+        if (parseToken(lltok::colon, "expected ':' here") ||
+            parseUInt64(ByArg.Info))
           return true;
         break;
       case lltok::kw_byte:
         Lex.Lex();
-        if (ParseToken(lltok::colon, "expected ':' here") ||
-            ParseUInt32(ByArg.Byte))
+        if (parseToken(lltok::colon, "expected ':' here") ||
+            parseUInt32(ByArg.Byte))
           return true;
         break;
       case lltok::kw_bit:
         Lex.Lex();
-        if (ParseToken(lltok::colon, "expected ':' here") ||
-            ParseUInt32(ByArg.Bit))
+        if (parseToken(lltok::colon, "expected ':' here") ||
+            parseUInt32(ByArg.Bit))
           return true;
         break;
       default:
-        return Error(Lex.getLoc(),
+        return error(Lex.getLoc(),
                      "expected optional whole program devirt field");
       }
     }
 
-    if (ParseToken(lltok::rparen, "expected ')' here"))
+    if (parseToken(lltok::rparen, "expected ')' here"))
       return true;
 
     ResByArg[Args] = ByArg;
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -8038,20 +8300,20 @@ bool LLParser::ParseOptionalResByArg(
 
 /// OptionalResByArg
 ///   ::= 'args' ':' '(' UInt64[, UInt64]* ')'
-bool LLParser::ParseArgs(std::vector<uint64_t> &Args) {
-  if (ParseToken(lltok::kw_args, "expected 'args' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+bool LLParser::parseArgs(std::vector<uint64_t> &Args) {
+  if (parseToken(lltok::kw_args, "expected 'args' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   do {
     uint64_t Val;
-    if (ParseUInt64(Val))
+    if (parseUInt64(Val))
       return true;
     Args.push_back(Val);
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   return false;
@@ -8412,16 +8676,14 @@ bool LLParser::ParseAliasSummary(std::string Name, GlobalValue::GUID GUID,
 
   // Record forward reference if the aliasee is not parsed yet.
   if (AliaseeVI.getRef() == FwdVIRef) {
-    auto FwdRef = ForwardRefAliasees.insert(
-        std::make_pair(GVId, std::vector<std::pair<AliasSummary *, LocTy>>()));
-    FwdRef.first->second.push_back(std::make_pair(AS.get(), Loc));
+    ForwardRefAliasees[GVId].emplace_back(AS.get(), Loc);
   } else {
     auto Summary = Index->findSummaryInModule(AliaseeVI, ModulePath);
     assert(Summary && "Aliasee must be a definition");
     AS->setAliasee(AliaseeVI, Summary);
   }
 
-  AddGlobalValueToIndex(Name, GUID, (GlobalValue::LinkageTypes)GVFlags.Linkage,
+  addGlobalValueToIndex(Name, GUID, (GlobalValue::LinkageTypes)GVFlags.Linkage,
                         ID, std::move(AS));
 
   return false;
@@ -8548,24 +8810,22 @@ bool LLParser::ParseOptionalCalls(std::vector<FunctionSummary::EdgeTy> &Calls) {
   // Now that the Calls vector is finalized, it is safe to save the locations
   // of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Infos = ForwardRefValueInfos[I.first];
     for (auto P : I.second) {
       assert(Calls[P.first].first.getRef() == FwdVIRef &&
              "Forward referenced ValueInfo expected to be empty");
-      auto FwdRef = ForwardRefValueInfos.insert(std::make_pair(
-          I.first, std::vector<std::pair<ValueInfo *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&Calls[P.first].first, P.second));
+      Infos.emplace_back(&Calls[P.first].first, P.second);
     }
   }
@@ -8635,55 +8895,53 @@ bool LLParser::ParseOptionalVTableFuncs(VTableFuncList &VTableFuncs) {
   // Now that the VTableFuncs vector is finalized, it is safe to save the
   // locations of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Infos = ForwardRefValueInfos[I.first];
     for (auto P : I.second) {
       assert(VTableFuncs[P.first].FuncVI == EmptyVI &&
              "Forward referenced ValueInfo expected to be empty");
-      auto FwdRef = ForwardRefValueInfos.insert(std::make_pair(
-          I.first, std::vector<std::pair<ValueInfo *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&VTableFuncs[P.first].FuncVI, P.second));
+      Infos.emplace_back(&VTableFuncs[P.first].FuncVI, P.second);
     }
   }
@@ -8697,26 +8955,29 @@ bool LLParser::ParseParamAccessOffset(ConstantRange &Range) {
 
 /// ParamAccessCall
 ///   := '(' 'callee' ':' GVReference ',' ParamNo ',' ParamAccessOffset ')'
-bool LLParser::ParseParamAccessCall(FunctionSummary::ParamAccess::Call &Call) {
-  if (ParseToken(lltok::lparen, "expected '(' here") ||
-      ParseToken(lltok::kw_callee, "expected 'callee' here") ||
-      ParseToken(lltok::colon, "expected ':' here"))
+bool LLParser::parseParamAccessCall(FunctionSummary::ParamAccess::Call &Call,
+                                    IdLocListType &IdLocList) {
+  if (parseToken(lltok::lparen, "expected '(' here") ||
+      parseToken(lltok::kw_callee, "expected 'callee' here") ||
+      parseToken(lltok::colon, "expected ':' here"))
     return true;
 
   unsigned GVId;
   ValueInfo VI;
-  if (ParseGVReference(VI, GVId))
+  LocTy Loc = Lex.getLoc();
+  if (parseGVReference(VI, GVId))
     return true;
 
-  Call.Callee = VI.getGUID();
+  Call.Callee = VI;
+  IdLocList.emplace_back(GVId, Loc);
@@ -8756,36 +9018,53 @@ bool LLParser::ParseParamAccess(FunctionSummary::ParamAccess &Param) {
 
 /// OptionalParamAccesses
 ///   := 'params' ':' '(' ParamAccess [',' ParamAccess]* ')'
-bool LLParser::ParseOptionalParamAccesses(
+bool LLParser::parseOptionalParamAccesses(
     std::vector<FunctionSummary::ParamAccess> &Params) {
   assert(Lex.getKind() == lltok::kw_params);
   Lex.Lex();
 
-  if (ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
+  IdLocListType VContexts;
+  size_t CallsNum = 0;
   do {
     FunctionSummary::ParamAccess ParamAccess;
-    if (ParseParamAccess(ParamAccess))
+    if (parseParamAccess(ParamAccess, VContexts))
       return true;
-    Params.push_back(ParamAccess);
+    CallsNum += ParamAccess.Calls.size();
+    assert(VContexts.size() == CallsNum);
+    Params.emplace_back(std::move(ParamAccess));
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
+  // Now that the Params is finalized, it is safe to save the locations
+  // of any forward GV references that need updating later.
+  IdLocListType::const_iterator ItContext = VContexts.begin();
+  for (auto &PA : Params) {
+    for (auto &C : PA.Calls) {
+      if (C.Callee.getRef() == FwdVIRef)
+        ForwardRefValueInfos[ItContext->first].emplace_back(&C.Callee,
+                                                            ItContext->second);
+      ++ItContext;
+    }
+  }
+  assert(ItContext == VContexts.end());
+
   return false;
 }
@@ -8823,16 +9102,15 @@ bool LLParser::ParseOptionalRefs(std::vector<ValueInfo> &Refs) {
   // Now that the Refs vector is finalized, it is safe to save the locations
   // of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Infos = ForwardRefValueInfos[I.first];
     for (auto P : I.second) {
       assert(Refs[P.first].getRef() == FwdVIRef &&
              "Forward referenced ValueInfo expected to be empty");
-      auto FwdRef = ForwardRefValueInfos.insert(std::make_pair(
-          I.first, std::vector<std::pair<ValueInfo *, LocTy>>()));
-      FwdRef.first->second.push_back(std::make_pair(&Refs[P.first], P.second));
+      Infos.emplace_back(&Refs[P.first], P.second);
     }
   }
@@ -8918,17 +9196,15 @@ bool LLParser::ParseTypeTests(std::vector<GlobalValue::GUID> &TypeTests) {
   // Now that the TypeTests vector is finalized, it is safe to save the
   // locations of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Ids = ForwardRefTypeIds[I.first];
     for (auto P : I.second) {
       assert(TypeTests[P.first] == 0 &&
              "Forward referenced type id GUID expected to be 0");
-      auto FwdRef = ForwardRefTypeIds.insert(std::make_pair(
-          I.first, std::vector<std::pair<GlobalValue::GUID *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&TypeTests[P.first], P.second));
+      Ids.emplace_back(&TypeTests[P.first], P.second);
     }
   }
@@ -8936,36 +9212,34 @@ bool LLParser::ParseTypeTests(std::vector<GlobalValue::GUID> &TypeTests) {
   // Now that the VFuncIdList vector is finalized, it is safe to save the
   // locations of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Ids = ForwardRefTypeIds[I.first];
     for (auto P : I.second) {
       assert(VFuncIdList[P.first].GUID == 0 &&
              "Forward referenced type id GUID expected to be 0");
-      auto FwdRef = ForwardRefTypeIds.insert(std::make_pair(
-          I.first, std::vector<std::pair<GlobalValue::GUID *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&VFuncIdList[P.first].GUID, P.second));
+      Ids.emplace_back(&VFuncIdList[P.first].GUID, P.second);
     }
   }
 
@@ -8974,37 +9248,35 @@ bool LLParser::ParseVFuncIdList(
 
 /// ConstVCallList
 ///   ::= Kind ':' '(' ConstVCall [',' ConstVCall]* ')'
-bool LLParser::ParseConstVCallList(
+bool LLParser::parseConstVCallList(
     lltok::Kind Kind,
     std::vector<FunctionSummary::ConstVCall> &ConstVCallList) {
   assert(Lex.getKind() == Kind);
   Lex.Lex();
 
-  if (ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::lparen, "expected '(' here"))
+  if (parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::lparen, "expected '(' here"))
     return true;
 
   IdToIndexMapType IdToIndexMap;
   do {
     FunctionSummary::ConstVCall ConstVCall;
-    if (ParseConstVCall(ConstVCall, IdToIndexMap, ConstVCallList.size()))
+    if (parseConstVCall(ConstVCall, IdToIndexMap, ConstVCallList.size()))
       return true;
     ConstVCallList.push_back(ConstVCall);
   } while (EatIfPresent(lltok::comma));
 
-  if (ParseToken(lltok::rparen, "expected ')' here"))
+  if (parseToken(lltok::rparen, "expected ')' here"))
     return true;
 
   // Now that the ConstVCallList vector is finalized, it is safe to save the
   // locations of any forward GV references that need updating later.
   for (auto I : IdToIndexMap) {
+    auto &Ids = ForwardRefTypeIds[I.first];
     for (auto P : I.second) {
       assert(ConstVCallList[P.first].VFunc.GUID == 0 &&
              "Forward referenced type id GUID expected to be 0");
-      auto FwdRef = ForwardRefTypeIds.insert(std::make_pair(
-          I.first, std::vector<std::pair<GlobalValue::GUID *, LocTy>>()));
-      FwdRef.first->second.push_back(
-          std::make_pair(&ConstVCallList[P.first].VFunc.GUID, P.second));
+      Ids.emplace_back(&ConstVCallList[P.first].VFunc.GUID, P.second);
     }
   }
@@ -9167,19 +9439,19 @@ bool LLParser::ParseGVarFlags(GlobalVarSummary::GVarFlags &GVarFlags) {
 /// ModuleReference
 ///   ::= 'module' ':' UInt
-bool LLParser::ParseModuleReference(StringRef &ModulePath) {
-  // Parse module id.
-  if (ParseToken(lltok::kw_module, "expected 'module' here") ||
-      ParseToken(lltok::colon, "expected ':' here") ||
-      ParseToken(lltok::SummaryID, "expected module ID"))
+bool LLParser::parseModuleReference(StringRef &ModulePath) {
+  // parse module id.
+  if (parseToken(lltok::kw_module, "expected 'module' here") ||
+      parseToken(lltok::colon, "expected ':' here") ||
+      parseToken(lltok::SummaryID, "expected module ID"))
     return true;
 
   unsigned ModuleID = Lex.getUIntVal();
diff --git a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLParser.h b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLParser.h
index ebd8655..aa79823 100644
--- a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLParser.h
+++ b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLParser.h
@@ -46,7 +46,7 @@ namespace llvm {
       t_LocalID, t_GlobalID,           // ID in UIntVal.
       t_LocalName, t_GlobalName,       // Name in StrVal.
       t_APSInt, t_APFloat,             // Value in APSIntVal/APFloatVal.
-      t_Null, t_Undef, t_Zero, t_None, // No value.
+      t_Null, t_Undef, t_Zero, t_None, t_Poison, // No value.
       t_EmptyArray,                    // No value:  []
       t_Constant,                      // Value in ConstantVal.
       t_InlineAsm,                     // Value in FTy/StrVal/StrVal2/UIntVal.
@@ -166,8 +166,8 @@ namespace llvm {
         : Context(Context), Lex(F, SM, Err, Context), M(M), Index(Index),
           Slots(Slots), BlockAddressPFS(nullptr) {}
     bool Run(
-        bool UpgradeDebugInfo,
-        DataLayoutCallbackTy DataLayoutCallback = [](Module *) {});
+        bool UpgradeDebugInfo, DataLayoutCallbackTy DataLayoutCallback =
+                                   [](StringRef) { return None; });
 
     bool parseStandaloneConstantValue(Constant *&C, const SlotMapping *Slots);
@@ -240,80 +235,81 @@ namespace llvm {
       }
       return false;
     }
-    bool ParseStringConstant(std::string &Result);
-    bool ParseUInt32(unsigned &Val);
-    bool ParseUInt32(unsigned &Val, LocTy &Loc) {
+    bool parseStringConstant(std::string &Result);
+    bool parseUInt32(unsigned &Val);
+    bool parseUInt32(unsigned &Val, LocTy &Loc) {
       Loc = Lex.getLoc();
-      return ParseUInt32(Val);
+      return parseUInt32(Val);
     }
-    bool ParseUInt64(uint64_t &Val);
-    bool ParseUInt64(uint64_t &Val, LocTy &Loc) {
+    bool parseUInt64(uint64_t &Val);
+    bool parseUInt64(uint64_t &Val, LocTy &Loc) {
       Loc = Lex.getLoc();
-      return ParseUInt64(Val);
+      return parseUInt64(Val);
     }
-    bool ParseFlag(unsigned &Val);
+    bool parseFlag(unsigned &Val);
 
-    bool ParseStringAttribute(AttrBuilder &B);
+    bool parseStringAttribute(AttrBuilder &B);
 
-    bool ParseTLSModel(GlobalVariable::ThreadLocalMode &TLM);
-    bool ParseOptionalThreadLocal(GlobalVariable::ThreadLocalMode &TLM);
-    bool ParseOptionalUnnamedAddr(GlobalVariable::UnnamedAddr &UnnamedAddr);
-    bool ParseOptionalAddrSpace(unsigned &AddrSpace, unsigned DefaultAS = 0);
-    bool ParseOptionalProgramAddrSpace(unsigned &AddrSpace) {
-      return ParseOptionalAddrSpace(
+    bool parseTLSModel(GlobalVariable::ThreadLocalMode &TLM);
+    bool parseOptionalThreadLocal(GlobalVariable::ThreadLocalMode &TLM);
+    bool parseOptionalUnnamedAddr(GlobalVariable::UnnamedAddr &UnnamedAddr);
+    bool parseOptionalAddrSpace(unsigned &AddrSpace, unsigned DefaultAS = 0);
+    bool parseOptionalProgramAddrSpace(unsigned &AddrSpace) {
+      return parseOptionalAddrSpace(
           AddrSpace, M->getDataLayout().getProgramAddressSpace());
     };
-    bool ParseOptionalParamAttrs(AttrBuilder &B);
-    bool ParseOptionalReturnAttrs(AttrBuilder &B);
-    bool ParseOptionalLinkage(unsigned &Res, bool &HasLinkage,
+    bool parseOptionalParamAttrs(AttrBuilder &B);
+    bool parseOptionalReturnAttrs(AttrBuilder &B);
+    bool parseOptionalLinkage(unsigned &Res, bool &HasLinkage,
                               unsigned &Visibility, unsigned &DLLStorageClass,
                               bool &DSOLocal);
-    void ParseOptionalDSOLocal(bool &DSOLocal);
-    void ParseOptionalVisibility(unsigned &Res);
-    void ParseOptionalDLLStorageClass(unsigned &Res);
-    bool ParseOptionalCallingConv(unsigned &CC);
-    bool ParseOptionalAlignment(MaybeAlign &Alignment,
+    void parseOptionalDSOLocal(bool &DSOLocal);
+    void parseOptionalVisibility(unsigned &Res);
+    void parseOptionalDLLStorageClass(unsigned &Res);
+    bool parseOptionalCallingConv(unsigned &CC);
+    bool parseOptionalAlignment(MaybeAlign &Alignment,
                                 bool AllowParens = false);
-    bool ParseOptionalDerefAttrBytes(lltok::Kind AttrKind, uint64_t &Bytes);
-    bool ParseScopeAndOrdering(bool isAtomic, SyncScope::ID &SSID,
+    bool parseOptionalDerefAttrBytes(lltok::Kind AttrKind, uint64_t &Bytes);
+    bool parseScopeAndOrdering(bool IsAtomic, SyncScope::ID &SSID,
                                AtomicOrdering &Ordering);
-    bool ParseScope(SyncScope::ID &SSID);
-    bool ParseOrdering(AtomicOrdering &Ordering);
-    bool ParseOptionalStackAlignment(unsigned &Alignment);
-    bool ParseOptionalCommaAlign(MaybeAlign &Alignment, bool &AteExtraComma);
-    bool ParseOptionalCommaAddrSpace(unsigned &AddrSpace, LocTy &Loc,
+    bool parseScope(SyncScope::ID &SSID);
+    bool parseOrdering(AtomicOrdering &Ordering);
+    bool parseOptionalStackAlignment(unsigned &Alignment);
+    bool parseOptionalCommaAlign(MaybeAlign &Alignment, bool &AteExtraComma);
+    bool parseOptionalCommaAddrSpace(unsigned &AddrSpace, LocTy &Loc,
                                      bool &AteExtraComma);
-    bool ParseOptionalCommaInAlloca(bool &IsInAlloca);
+    bool parseOptionalCommaInAlloca(bool &IsInAlloca);
     bool parseAllocSizeArguments(unsigned &BaseSizeArg,
                                  Optional<unsigned> &HowManyArg);
-    bool ParseIndexList(SmallVectorImpl<unsigned> &Indices,
+    bool parseIndexList(SmallVectorImpl<unsigned> &Indices,
                         bool &AteExtraComma);
-    bool ParseIndexList(SmallVectorImpl<unsigned> &Indices) {
+    bool parseIndexList(SmallVectorImpl<unsigned> &Indices) {
       bool AteExtraComma;
-      if (ParseIndexList(Indices, AteExtraComma)) return true;
+      if (parseIndexList(Indices, AteExtraComma))
+        return true;
       if (AteExtraComma)
-        return TokError("expected index");
+        return tokError("expected index");
       return false;
     }
 
     // Top-Level Entities
-    bool ParseTopLevelEntities();
-    bool ValidateEndOfModule(bool UpgradeDebugInfo);
-    bool ValidateEndOfIndex();
-    bool ParseTargetDefinitions();
-    bool ParseTargetDefinition();
-    bool ParseModuleAsm();
-    bool ParseSourceFileName();
-    bool ParseDepLibs();        // FIXME: Remove in 4.0.
-    bool ParseUnnamedType();
-    bool ParseNamedType();
-    bool ParseDeclare();
-    bool ParseDefine();
-
-    bool ParseGlobalType(bool &IsConstant);
-    bool ParseUnnamedGlobal();
-    bool ParseNamedGlobal();
-    bool ParseGlobal(const std::string &Name, LocTy NameLoc, unsigned Linkage,
+    bool parseTopLevelEntities();
+    bool validateEndOfModule(bool UpgradeDebugInfo);
+    bool validateEndOfIndex();
+    bool parseTargetDefinitions();
+    bool parseTargetDefinition();
+    bool parseModuleAsm();
+    bool parseSourceFileName();
+    bool parseDepLibs(); // FIXME: Remove in 4.0.
+    bool parseUnnamedType();
+    bool parseNamedType();
+    bool parseDeclare();
+    bool parseDefine();
+
+    bool parseGlobalType(bool &IsConstant);
+    bool parseUnnamedGlobal();
+    bool parseNamedGlobal();
+    bool parseGlobal(const std::string &Name, LocTy NameLoc, unsigned Linkage,
                      bool HasLinkage, unsigned Visibility,
                      unsigned DLLStorageClass, bool DSOLocal,
                      GlobalVariable::ThreadLocalMode TLM,
@@ -324,92 +320,96 @@ namespace llvm {
-    bool ParseByValWithOptionalType(Type *&Result);
-    bool ParsePreallocated(Type *&Result);
+    bool parseRequiredTypeAttr(Type *&Result, lltok::Kind AttrName);
+    bool parsePreallocated(Type *&Result);
+    bool parseByRef(Type *&Result);
 
     // Module Summary Index Parsing.
-    bool SkipModuleSummaryEntry();
-    bool ParseSummaryEntry();
-    bool ParseModuleEntry(unsigned ID);
-    bool ParseModuleReference(StringRef &ModulePath);
-    bool ParseGVReference(ValueInfo &VI, unsigned &GVId);
-    bool ParseSummaryIndexFlags();
-    bool ParseBlockCount();
-    bool ParseGVEntry(unsigned ID);
-    bool ParseFunctionSummary(std::string Name, GlobalValue::GUID, unsigned ID);
-    bool ParseVariableSummary(std::string Name, GlobalValue::GUID, unsigned ID);
-    bool ParseAliasSummary(std::string Name, GlobalValue::GUID, unsigned ID);
-    bool ParseGVFlags(GlobalValueSummary::GVFlags &GVFlags);
-    bool ParseGVarFlags(GlobalVarSummary::GVarFlags &GVarFlags);
-    bool ParseOptionalFFlags(FunctionSummary::FFlags &FFlags);
-    bool ParseOptionalCalls(std::vector<FunctionSummary::EdgeTy> &Calls);
-    bool ParseHotness(CalleeInfo::HotnessType &Hotness);
-    bool ParseOptionalTypeIdInfo(FunctionSummary::TypeIdInfo &TypeIdInfo);
-    bool ParseTypeTests(std::vector<GlobalValue::GUID> &TypeTests);
-    bool ParseVFuncIdList(lltok::Kind Kind,
+    bool skipModuleSummaryEntry();
+    bool parseSummaryEntry();
+    bool parseModuleEntry(unsigned ID);
+    bool parseModuleReference(StringRef &ModulePath);
+    bool parseGVReference(ValueInfo &VI, unsigned &GVId);
+    bool parseSummaryIndexFlags();
+    bool parseBlockCount();
+    bool parseGVEntry(unsigned ID);
+    bool parseFunctionSummary(std::string Name, GlobalValue::GUID, unsigned ID);
+    bool parseVariableSummary(std::string Name, GlobalValue::GUID, unsigned ID);
+    bool parseAliasSummary(std::string Name, GlobalValue::GUID, unsigned ID);
+    bool parseGVFlags(GlobalValueSummary::GVFlags &GVFlags);
+    bool parseGVarFlags(GlobalVarSummary::GVarFlags &GVarFlags);
+    bool parseOptionalFFlags(FunctionSummary::FFlags &FFlags);
+    bool parseOptionalCalls(std::vector<FunctionSummary::EdgeTy> &Calls);
+    bool parseHotness(CalleeInfo::HotnessType &Hotness);
+    bool parseOptionalTypeIdInfo(FunctionSummary::TypeIdInfo &TypeIdInfo);
+    bool parseTypeTests(std::vector<GlobalValue::GUID> &TypeTests);
+    bool parseVFuncIdList(lltok::Kind Kind,
                           std::vector<FunctionSummary::VFuncId> &VFuncIdList);
-    bool ParseConstVCallList(
+    bool parseConstVCallList(
         lltok::Kind Kind,
         std::vector<FunctionSummary::ConstVCall> &ConstVCallList);
     using IdToIndexMapType =
         std::map<unsigned, std::vector<std::pair<unsigned, LocTy>>>;
-    bool ParseConstVCall(FunctionSummary::ConstVCall &ConstVCall,
+    bool parseConstVCall(FunctionSummary::ConstVCall &ConstVCall,
                          IdToIndexMapType &IdToIndexMap, unsigned Index);
-    bool ParseVFuncId(FunctionSummary::VFuncId &VFuncId,
+    bool parseVFuncId(FunctionSummary::VFuncId &VFuncId,
                       IdToIndexMapType &IdToIndexMap, unsigned Index);
-    bool ParseOptionalVTableFuncs(VTableFuncList &VTableFuncs);
-    bool ParseOptionalParamAccesses(
+    bool parseOptionalVTableFuncs(VTableFuncList &VTableFuncs);
+    bool parseOptionalParamAccesses(
         std::vector<FunctionSummary::ParamAccess> &Params);
-    bool ParseParamNo(uint64_t &ParamNo);
-    bool ParseParamAccess(FunctionSummary::ParamAccess &Param);
-    bool ParseParamAccessCall(FunctionSummary::ParamAccess::Call &Call);
-    bool ParseParamAccessOffset(ConstantRange &range);
-    bool ParseOptionalRefs(std::vector<ValueInfo> &Refs);
-    bool ParseTypeIdEntry(unsigned ID);
-    bool ParseTypeIdSummary(TypeIdSummary &TIS);
-    bool ParseTypeIdCompatibleVtableEntry(unsigned ID);
-    bool ParseTypeTestResolution(TypeTestResolution &TTRes);
-    bool ParseOptionalWpdResolutions(
+    bool parseParamNo(uint64_t &ParamNo);
+    using IdLocListType = std::vector<std::pair<unsigned, LocTy>>;
+    bool parseParamAccess(FunctionSummary::ParamAccess &Param,
+                          IdLocListType &IdLocList);
+    bool parseParamAccessCall(FunctionSummary::ParamAccess::Call &Call,
+                              IdLocListType &IdLocList);
+    bool parseParamAccessOffset(ConstantRange &Range);
+    bool parseOptionalRefs(std::vector<ValueInfo> &Refs);
+    bool parseTypeIdEntry(unsigned ID);
+    bool parseTypeIdSummary(TypeIdSummary &TIS);
+    bool parseTypeIdCompatibleVtableEntry(unsigned ID);
+    bool parseTypeTestResolution(TypeTestResolution &TTRes);
+    bool parseOptionalWpdResolutions(
         std::map<uint64_t, WholeProgramDevirtResolution> &WPDResMap);
-    bool ParseWpdRes(WholeProgramDevirtResolution &WPDRes);
-    bool ParseOptionalResByArg(
+    bool parseWpdRes(WholeProgramDevirtResolution &WPDRes);
+    bool parseOptionalResByArg(
         std::map<std::vector<uint64_t>, WholeProgramDevirtResolution::ByArg>
             &ResByArg);
-    bool ParseArgs(std::vector<uint64_t> &Args);
-    void AddGlobalValueToIndex(std::string Name, GlobalValue::GUID,
+    bool parseArgs(std::vector<uint64_t> &Args);
+    void addGlobalValueToIndex(std::string Name, GlobalValue::GUID,
                                GlobalValue::LinkageTypes Linkage, unsigned ID,
                                std::unique_ptr<GlobalValueSummary> Summary);
 
     // Type Parsing.
-    bool ParseType(Type *&Result, const Twine &Msg, bool AllowVoid = false);
-    bool ParseType(Type *&Result, bool AllowVoid = false) {
-      return ParseType(Result, "expected type", AllowVoid);
+    bool parseType(Type *&Result, const Twine &Msg, bool AllowVoid = false);
+    bool parseType(Type *&Result, bool AllowVoid = false) {
+      return parseType(Result, "expected type", AllowVoid);
     }
-    bool ParseType(Type *&Result, const Twine &Msg, LocTy &Loc,
+    bool parseType(Type *&Result, const Twine &Msg, LocTy &Loc,
                    bool AllowVoid = false) {
       Loc = Lex.getLoc();
-      return ParseType(Result, Msg, AllowVoid);
+      return parseType(Result, Msg, AllowVoid);
     }
-    bool ParseType(Type *&Result, LocTy &Loc, bool AllowVoid = false) {
+    bool parseType(Type *&Result, LocTy &Loc, bool AllowVoid = false) {
       Loc = Lex.getLoc();
-      return ParseType(Result, AllowVoid);
+      return parseType(Result, AllowVoid);
     }
-    bool ParseAnonStructType(Type *&Result, bool Packed);
-    bool ParseStructBody(SmallVectorImpl<Type*> &Body);
-    bool ParseStructDefinition(SMLoc TypeLoc, StringRef Name,
-                               std::pair<Type*, LocTy> &Entry,
+    bool parseAnonStructType(Type *&Result, bool Packed);
+    bool parseStructBody(SmallVectorImpl<Type *> &Body);
+    bool parseStructDefinition(SMLoc TypeLoc, StringRef Name,
+                               std::pair<Type *, LocTy> &Entry,
                                Type *&ResultTy);
 
-    bool ParseArrayVectorType(Type *&Result, bool isVector);
-    bool ParseFunctionType(Type *&Result);
+    bool parseArrayVectorType(Type *&Result, bool IsVector);
+    bool parseFunctionType(Type *&Result);
 
     // Function Semantic Analysis.
     class PerFunctionState {
@@ -428,67 +428,65 @@ namespace llvm {
-    bool ParseTypeAndValue(Value *&V, PerFunctionState *PFS);
-    bool ParseTypeAndValue(Value *&V, PerFunctionState &PFS) {
-      return ParseTypeAndValue(V, &PFS);
+    bool parseTypeAndValue(Value *&V, PerFunctionState *PFS);
+    bool parseTypeAndValue(Value *&V, PerFunctionState &PFS) {
+      return parseTypeAndValue(V, &PFS);
     }
-    bool ParseTypeAndValue(Value *&V, LocTy &Loc, PerFunctionState &PFS) {
+    bool parseTypeAndValue(Value *&V, LocTy &Loc, PerFunctionState &PFS) {
       Loc = Lex.getLoc();
-      return ParseTypeAndValue(V, PFS);
+      return parseTypeAndValue(V, PFS);
     }
-    bool ParseTypeAndBasicBlock(BasicBlock *&BB, LocTy &Loc,
+    bool parseTypeAndBasicBlock(BasicBlock *&BB, LocTy &Loc,
                                 PerFunctionState &PFS);
-    bool ParseTypeAndBasicBlock(BasicBlock *&BB, PerFunctionState &PFS) {
+    bool parseTypeAndBasicBlock(BasicBlock *&BB, PerFunctionState &PFS) {
       LocTy Loc;
-      return ParseTypeAndBasicBlock(BB, Loc, PFS);
+      return parseTypeAndBasicBlock(BB, Loc, PFS);
     }
 
-
     struct ParamInfo {
       LocTy Loc;
       Value *V;
@@ -550,64 +546,64 @@ namespace llvm {
       ArgInfo(LocTy L, Type *ty, AttributeSet Attr, const std::string &N)
           : Loc(L), Ty(ty), Attrs(Attr), Name(N) {}
     };
     enum TailCallType { TCT_None, TCT_Tail, TCT_MustTail };
 
     // Instruction Parsing.  Each instruction parsing routine can return with a
     // normal result, an error result, or return having eaten an extra comma.
     enum InstResult { InstNormal = 0, InstError = 1, InstExtraComma = 2 };
-    bool ParseCmpPredicate(unsigned &P, unsigned Opc);
-
-    bool ParseRet(Instruction *&Inst, BasicBlock *BB, PerFunctionState &PFS);
-    bool ParseBr(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseSwitch(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseIndirectBr(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseInvoke(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseResume(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCleanupRet(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCatchRet(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCatchSwitch(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCatchPad(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCleanupPad(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCallBr(Instruction *&Inst, PerFunctionState &PFS);
-
-    bool ParseUnaryOp(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc,
+    bool parseCmpPredicate(unsigned &P, unsigned Opc);
+
+    bool parseRet(Instruction *&Inst, BasicBlock *BB, PerFunctionState &PFS);
+    bool parseBr(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseSwitch(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseIndirectBr(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseInvoke(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseResume(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCleanupRet(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCatchRet(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCatchSwitch(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCatchPad(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCleanupPad(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCallBr(Instruction *&Inst, PerFunctionState &PFS);
+
+    bool parseUnaryOp(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc,
                       bool IsFP);
-    bool ParseArithmetic(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc,
-                         bool IsFP);
-    bool ParseLogical(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
-    bool ParseCompare(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
-    bool ParseCast(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
-    bool ParseSelect(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseVA_Arg(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseExtractElement(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseInsertElement(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseShuffleVector(Instruction *&Inst, PerFunctionState &PFS);
-    int ParsePHI(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseLandingPad(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseCall(Instruction *&Inst, PerFunctionState &PFS,
+    bool parseArithmetic(Instruction *&Inst, PerFunctionState &PFS,
+                         unsigned Opc, bool IsFP);
+    bool parseLogical(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
+    bool parseCompare(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
+    bool parseCast(Instruction *&Inst, PerFunctionState &PFS, unsigned Opc);
+    bool parseSelect(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseVAArg(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseExtractElement(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseInsertElement(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseShuffleVector(Instruction *&Inst, PerFunctionState &PFS);
+    int parsePHI(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseLandingPad(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseCall(Instruction *&Inst, PerFunctionState &PFS,
                    CallInst::TailCallKind TCK);
-    int ParseAlloc(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseLoad(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseStore(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseCmpXchg(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseAtomicRMW(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseFence(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseExtractValue(Instruction *&Inst, PerFunctionState &PFS);
-    int ParseInsertValue(Instruction *&Inst, PerFunctionState &PFS);
-    bool ParseFreeze(Instruction *&I, PerFunctionState &PFS);
+    int parseAlloc(Instruction *&Inst, PerFunctionState &PFS);
+    int parseLoad(Instruction *&Inst, PerFunctionState &PFS);
+    int parseStore(Instruction *&Inst, PerFunctionState &PFS);
+    int parseCmpXchg(Instruction *&Inst, PerFunctionState &PFS);
+    int parseAtomicRMW(Instruction *&Inst, PerFunctionState &PFS);
+    int parseFence(Instruction *&Inst, PerFunctionState &PFS);
+    int parseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS);
+    int parseExtractValue(Instruction *&Inst, PerFunctionState &PFS);
+    int parseInsertValue(Instruction *&Inst, PerFunctionState &PFS);
+    bool parseFreeze(Instruction *&I, PerFunctionState &PFS);
 
     // Use-list order directives.
-    bool ParseUseListOrder(PerFunctionState *PFS = nullptr);
-    bool ParseUseListOrderBB();
-    bool ParseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes);
+    bool parseUseListOrder(PerFunctionState *PFS = nullptr);
+    bool parseUseListOrderBB();
+    bool parseUseListOrderIndexes(SmallVectorImpl<unsigned> &Indexes);
     bool sortUseListOrder(Value *V, ArrayRef<unsigned> Indexes, SMLoc Loc);
   };
 } // End llvm namespace
diff --git a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLToken.h b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLToken.h
index 0fb3bae..5149f86 100644
--- a/llvm-project-llvmorg-11.0.0/llvm/lib/AsmParser/LLToken.h
+++ b/llvm-project-llvmorg-12.0.0/llvm/lib/AsmParser/LLToken.h
@@ -74,6 +74,7 @@ enum Kind {
   kw_localexec,
   kw_zeroinitializer,
   kw_undef,
+  kw_poison,
   kw_null,
   kw_none,
   kw_to,
@@ -170,6 +171,7 @@ enum Kind {
   kw_amdgpu_ps,
   kw_amdgpu_cs,
   kw_amdgpu_kernel,
+  kw_amdgpu_gfx,
   kw_tailcc,
 
   // Attributes:
@@ -198,6 +200,7 @@ enum Kind {
   kw_noalias,
   kw_noundef,
   kw_nobuiltin,
+  kw_nocallback,
   kw_nocapture,
   kw_noduplicate,
   kw_nofree,
@@ -207,6 +210,7 @@ enum Kind {
   kw_nonlazybind,
   kw_nomerge,
   kw_nonnull,
+  kw_noprofile,
   kw_noredzone,
   kw_noreturn,
   kw_nosync,
@@ -240,6 +244,8 @@ enum Kind {
   kw_writeonly,
   kw_zeroext,
   kw_immarg,
+  kw_byref,
+  kw_mustprogress,
 
   kw_type,
   kw_opaque,
@@ -357,6 +363,7 @@ enum Kind {
   kw_extractvalue,
   kw_insertvalue,
   kw_blockaddress,
+  kw_dso_local_equivalent,
 
   kw_freeze,
